#ifndef lint
static const char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif

#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYPATCH 20100610

#define YYEMPTY        (-1)
#define yyclearin      (yychar = YYEMPTY)
#define yyerrok        (yyerrflag = 0)
#define YYRECOVERING() (yyerrflag != 0)

#define YYPREFIX "yy"

#define YYPURE 0

#line 29 "parser_gram.y"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <sys/types.h>
#include <locale.h>
#include <sys/utsname.h>
#include <sys/statvfs.h>
#ifdef HAVE_STDINT_H
#include <stdint.h>
#endif
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#ifdef HAVE_LIBTECLA
#include <libtecla.h>
#endif
#include "parsertypes.h"
#include "filebench.h"
#include "utils.h"
#include "stats.h"
#include "vars.h"
#include "eventgen.h"
#ifdef HAVE_LIBTECLA
#include "auto_comp.h"
#endif
#include "multi_client_sync.h"

extern int yylex(void);

int dofile = FS_FALSE;
static const char cmdname[] = "filebench";
static const char cmd_options[] = "pa:f:hi:s:m:";
static void usage(int);

#ifdef HAVE_LIBTECLA
static GetLine *gl;			/* GetLine resource object */
#endif

char *execname;
char *fbbasepath = FILEBENCHDIR;
char *fscriptname;
int noproc = 0;
var_t *var_list = NULL;
pidlist_t *pidlist = NULL;
char *cwd = NULL;
FILE *parentscript = NULL;

static int filecreate_done = 0;

/* OSprof enable flag. */
int osprof_enabled;

/* yacc externals */
extern FILE *yyin;
extern int yydebug;
extern void yyerror(char *s);

/* utilities */
static cmd_t *alloc_cmd(void);
static attr_t *alloc_attr(void);
static attr_t *alloc_lvar_attr(var_t *var);
static attr_t *get_attr(cmd_t *cmd, int64_t name);
static attr_t *get_attr_fileset(cmd_t *cmd, int64_t name);
static attr_t *get_attr_integer(cmd_t *cmd, int64_t name);
static attr_t *get_attr_bool(cmd_t *cmd, int64_t name);
static void get_attr_lvars(cmd_t *cmd, flowop_t *flowop);
static list_t *alloc_list();
static probtabent_t *alloc_probtabent(void);
static void add_lvar_to_list(var_t *newlvar, var_t **lvar_list);

/* Info Commands */
static void parser_list(cmd_t *);
static void parser_flowop_list(cmd_t *);

/* Define Commands */
static void parser_proc_define(cmd_t *);
static void parser_thread_define(cmd_t *, procflow_t *, int instances);
static void parser_flowop_define(cmd_t *, threadflow_t *, flowop_t **, int);
static void parser_file_define(cmd_t *);
static void parser_fileset_define(cmd_t *);
static void parser_posset_define(cmd_t *);
static void parser_randvar_define(cmd_t *);
static void parser_randvar_set(cmd_t *);
static void parser_composite_flowop_define(cmd_t *);

/* Create Commands */
static void parser_proc_create(cmd_t *);
static void parser_fileset_create(cmd_t *);

/* set commands */
static void parser_set_integer(cmd_t *cmd);
static void parser_set_var(cmd_t *cmd);
static void parser_set_var_op_int(cmd_t *cmd);
static void parser_set_int_op_var(cmd_t *cmd);
static void parser_set_var_op_var(cmd_t *cmd);

/* Shutdown Commands */
static void parser_proc_shutdown(cmd_t *);
static void parser_filebench_shutdown(cmd_t *cmd);
static void parser_fileset_shutdown(cmd_t *cmd);

/* Other Commands */
static void parser_echo(cmd_t *cmd);
static void parser_foreach_integer(cmd_t *cmd);
static void parser_foreach_string(cmd_t *cmd);
static void parser_fscheck(cmd_t *cmd);
static void parser_fsflush(cmd_t *cmd);
static void parser_log(cmd_t *cmd);
static void parser_statscmd(cmd_t *cmd);
static void parser_statsdump(cmd_t *cmd);
static void parser_statsxmldump(cmd_t *cmd);
static void parser_statsmultidump(cmd_t *cmd);
static void parser_usage(cmd_t *cmd);
static void parser_vars(cmd_t *cmd);
static void parser_printvars(cmd_t *cmd);
static void parser_system(cmd_t *cmd);
static void parser_statssnap(cmd_t *cmd);
static void parser_directory(cmd_t *cmd);
static void parser_eventgen(cmd_t *cmd);
static void parser_enable_mc(cmd_t *cmd);
static void parser_domultisync(cmd_t *cmd);
static void parser_run(cmd_t *cmd);
static void parser_run_variable(cmd_t *cmd);
static void parser_sleep(cmd_t *cmd);
static void parser_sleep_variable(cmd_t *cmd);
static void parser_warmup(cmd_t *cmd);
static void parser_warmup_variable(cmd_t *cmd);
static void parser_help(cmd_t *cmd);
static void arg_parse(const char *command);
static void parser_abort(int arg);
static void parser_version(cmd_t *cmd);
static void parser_osprof_enable(cmd_t *cmd);
static void parser_osprof_disable(cmd_t *cmd);

#line 168 "parser_gram.y"
typedef union {
	int64_t		 ival;
	unsigned char	 bval;
	char *		 sval;
	double       dbl;
	fs_u		 val;
	avd_t		 avd;
	cmd_t		*cmd;
	attr_t		*attr;
	list_t		*list;
	probtabent_t	*rndtb;
} YYSTYPE;
#line 170 "parser_gram.c"
/* compatibility with bison */
#ifdef YYPARSE_PARAM
/* compatibility with FreeBSD */
# ifdef YYPARSE_PARAM_TYPE
#  define YYPARSE_DECL() yyparse(YYPARSE_PARAM_TYPE YYPARSE_PARAM)
# else
#  define YYPARSE_DECL() yyparse(void *YYPARSE_PARAM)
# endif
#else
# define YYPARSE_DECL() yyparse(void)
#endif

/* Parameters sent to lex. */
#ifdef YYLEX_PARAM
# define YYLEX_DECL() yylex(void *YYLEX_PARAM)
# define YYLEX yylex(YYLEX_PARAM)
#else
# define YYLEX_DECL() yylex(void)
# define YYLEX yylex()
#endif

extern int YYPARSE_DECL();
extern int YYLEX_DECL();

#define FSC_LIST 257
#define FSC_DEFINE 258
#define FSC_EXEC 259
#define FSC_QUIT 260
#define FSC_DEBUG 261
#define FSC_CREATE 262
#define FSC_SLEEP 263
#define FSC_STATS 264
#define FSC_FOREACH 265
#define FSC_SET 266
#define FSC_SHUTDOWN 267
#define FSC_LOG 268
#define FSC_SYSTEM 269
#define FSC_FLOWOP 270
#define FSC_EVENTGEN 271
#define FSC_ECHO 272
#define FSC_LOAD 273
#define FSC_RUN 274
#define FSC_WARMUP 275
#define FSC_NOUSESTATS 276
#define FSC_FSCHECK 277
#define FSC_FSFLUSH 278
#define FSC_USAGE 279
#define FSC_HELP 280
#define FSC_VARS 281
#define FSC_VERSION 282
#define FSC_ENABLE 283
#define FSC_DOMULTISYNC 284
#define FSV_STRING 285
#define FSV_VAL_INT 286
#define FSV_VAL_BOOLEAN 287
#define FSV_VARIABLE 288
#define FSV_WHITESTRING 289
#define FSV_RANDUNI 290
#define FSV_RANDTAB 291
#define FSV_RANDVAR 292
#define FSV_URAND 293
#define FSV_RAND48 294
#define FST_INT 295
#define FST_BOOLEAN 296
#define FSE_FILE 297
#define FSE_PROC 298
#define FSE_THREAD 299
#define FSE_CLEAR 300
#define FSE_ALL 301
#define FSE_SNAP 302
#define FSE_DUMP 303
#define FSE_DIRECTORY 304
#define FSE_COMMAND 305
#define FSE_FILESET 306
#define FSE_POSSET 307
#define FSE_XMLDUMP 308
#define FSE_RAND 309
#define FSE_MODE 310
#define FSE_MULTI 311
#define FSE_MULTIDUMP 312
#define FSK_SEPLST 313
#define FSK_OPENLST 314
#define FSK_CLOSELST 315
#define FSK_ASSIGN 316
#define FSK_IN 317
#define FSK_QUOTE 318
#define FSK_DIRSEPLST 319
#define FSK_PLUS 320
#define FSK_MINUS 321
#define FSK_MULTIPLY 322
#define FSK_DIVIDE 323
#define FSA_SIZE 324
#define FSA_PREALLOC 325
#define FSA_PARALLOC 326
#define FSA_PATH 327
#define FSA_REUSE 328
#define FSA_PROCESS 329
#define FSA_MEMSIZE 330
#define FSA_RATE 331
#define FSA_CACHED 332
#define FSA_READONLY 333
#define FSA_TRUSTTREE 334
#define FSA_IOSIZE 335
#define FSA_FILE 336
#define FSA_POSSET 337
#define FSA_WSS 338
#define FSA_NAME 339
#define FSA_RANDOM 340
#define FSA_INSTANCES 341
#define FSA_DSYNC 342
#define FSA_TARGET 343
#define FSA_ITERS 344
#define FSA_NICE 345
#define FSA_VALUE 346
#define FSA_BLOCKING 347
#define FSA_HIGHWATER 348
#define FSA_DIRECTIO 349
#define FSA_DIRWIDTH 350
#define FSA_FD 351
#define FSA_SRCFD 352
#define FSA_ROTATEFD 353
#define FSA_NAMELENGTH 354
#define FSA_FILESIZE 355
#define FSA_ENTRIES 356
#define FSA_FILESIZEGAMMA 357
#define FSA_DIRDEPTHRV 358
#define FSA_DIRGAMMA 359
#define FSA_USEISM 360
#define FSA_TYPE 361
#define FSA_RANDTABLE 362
#define FSA_RANDSRC 363
#define FSA_RANDROUND 364
#define FSA_LEAFDIRS 365
#define FSA_INDEXED 366
#define FSA_FSTYPE 367
#define FSA_RANDSEED 368
#define FSA_RANDGAMMA 369
#define FSA_RANDMEAN 370
#define FSA_RANDMIN 371
#define FSA_RANDMAX 372
#define FSA_MASTER 373
#define FSA_CLIENT 374
#define FSS_TYPE 375
#define FSS_SEED 376
#define FSS_GAMMA 377
#define FSS_MEAN 378
#define FSS_MIN 379
#define FSS_SRC 380
#define FSS_ROUND 381
#define FSV_SET_LOCAL_VAR 382
#define FSA_LVAR_ASSIGN 383
#define FSA_ALLDONE 384
#define FSA_FIRSTDONE 385
#define FSA_TIMEOUT 386
#define FSC_OSPROF_ENABLE 387
#define FSC_OSPROF_DISABLE 388
#define FSA_NOREADAHEAD 389
#define FSA_DSRC 390
#define FSA_ENTROPY 391
#define FSV_VAL_DBL 392
#define FSA_DUMMY 393
#define YYERRCODE 256
static const short yylhs[] = {                           -1,
    0,    0,    0,    5,    5,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,   20,   20,   20,   69,
   69,   70,   70,   24,   24,   22,   29,   33,   41,   42,
   30,   32,   34,   34,   35,   71,   71,   73,   73,   72,
   72,   72,   72,   72,   74,   74,   75,   75,   75,   75,
   75,   75,   75,   75,    8,    8,   37,   37,   38,   21,
   14,   18,   18,   39,   39,   39,   39,   40,   40,   40,
   40,   40,   40,   40,   40,   40,   40,   17,   17,   17,
   17,   17,   17,   17,   25,   26,   26,   28,   27,   27,
    9,    9,   10,   10,   10,   10,   11,   11,   12,   13,
   13,   15,   19,   36,   36,   16,   16,    7,    7,    7,
   31,   23,   23,    6,    2,    2,    2,    2,    3,    3,
    3,    1,   47,   47,   48,   48,   49,   49,   46,   46,
   45,   45,   43,   43,   44,   57,   57,   57,   56,   56,
   56,   56,   99,   98,   98,   51,   51,   50,   50,   53,
   53,   53,   52,   52,   55,   55,   54,   54,   65,   65,
   66,   67,   68,   96,   96,   96,   96,   84,   84,   85,
   86,   86,   87,   88,   81,   81,   81,   76,   76,   76,
   76,   76,   76,   76,   76,   79,   79,   79,   79,   79,
   79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
   79,   97,   97,   80,   80,   80,   80,   80,   89,   89,
   89,   89,   89,   89,   93,   93,   93,   93,   93,   93,
   93,   91,   91,   91,   91,   91,   58,   90,   90,   90,
   59,   92,   92,   77,   77,   77,   77,   77,   78,   78,
   78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
   78,   78,   78,   78,   78,   78,   82,   94,   94,   95,
   95,   64,   64,   64,   63,   62,   62,   62,   62,   62,
   62,   83,   83,   60,   60,   60,   60,   60,   61,   61,
   61,   61,   61,  100,  100,
};
static const short yylen[] = {                            2,
    2,    2,    0,    1,    2,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    7,    7,    1,
    3,    3,    5,    1,    2,    2,    2,    1,    1,    1,
    2,    1,    2,    2,    2,    1,    3,    1,    1,    1,
    2,    2,    2,    2,    2,    2,    2,    2,    3,    2,
    2,    3,    2,    2,    1,    2,    2,    2,    2,    2,
    2,    1,    1,    4,    4,    3,    3,    4,    6,    4,
    4,    4,    4,    3,    5,    5,    5,    2,    2,    3,
    3,    3,    3,    3,    1,    1,    2,    5,    1,    2,
    6,    2,    2,    2,    2,    4,    2,    2,    3,    6,
    2,    2,    2,    2,    2,    2,    2,    2,    2,    1,
    1,    2,    2,    2,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    3,    1,    3,    3,    1,    3,    1,
    3,    5,    1,    3,    3,    1,    3,    7,    3,    1,
    3,    3,    7,    1,    3,    1,    3,    3,    1,    1,
    3,    3,    3,    1,    1,    3,    3,    1,    1,    3,
    3,    3,    3,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    3,    3,    3,    3,    3,    5,    3,    3,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,
};
static const short yydefred[] = {                         3,
    0,    2,   75,    0,  105,    0,    0,    0,    0,   37,
    0,    0,    0,    0,   44,    0,    0,    0,    0,    0,
    0,    0,  131,   52,   48,    0,    0,   49,   50,    1,
   22,   24,    0,    0,    0,    0,    9,    0,   11,   13,
   27,   29,   25,   26,    0,   23,   30,    0,   36,   14,
   15,   20,   16,   31,    0,   35,   28,    0,   19,    0,
   83,   32,   33,    0,  113,    0,  114,  117,    0,   81,
  138,  135,  136,  137,  122,  126,  127,   99,   98,    0,
    0,    0,    0,    0,    0,    0,    0,  123,    0,    0,
    0,    0,    0,  134,  128,  129,  124,  125,  280,  281,
   77,    0,   79,    0,   53,    0,   55,   76,  254,  256,
  196,  197,  195,  257,  166,    0,  191,  192,    0,  198,
  204,  205,  200,  203,  218,  201,  202,  199,  209,  219,
  216,  210,  217,  220,  221,  143,    0,  188,  189,    0,
  224,  227,  225,  226,  228,    0,  145,  190,    0,  292,
  293,  282,    0,    0,    0,  277,  175,    0,  194,    0,
  278,  279,    0,  179,    0,   78,  184,  185,  186,  187,
    0,    0,    0,  229,    0,    0,  234,  230,  231,  232,
  233,  156,    0,    0,    0,   59,   58,    0,    0,    0,
    0,    0,    0,    0,  242,  243,  244,  245,    0,  246,
    0,    0,   94,   65,   66,   68,   67,    0,   74,   71,
   70,    0,   73,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   86,   87,
    0,    0,    0,    0,    0,    0,   63,   64,   61,   62,
   90,   84,   88,   85,    0,    0,    0,    0,   92,   93,
   91,  235,  237,  238,  239,  240,  236,  241,   69,   72,
  183,  294,  295,  296,  297,  298,  182,  167,  168,    0,
  116,  144,   59,  301,  302,   58,  149,    0,  146,  147,
    0,  284,  283,  285,   40,    0,    0,    0,  176,  177,
  180,  181,    0,    0,    0,    0,    0,  109,  248,  249,
  250,  161,  247,  252,  253,  162,  251,    0,  157,  159,
    0,   95,   96,   97,    0,    0,    0,    0,    0,    0,
    0,  142,  132,  275,  260,  261,  259,  262,  263,  267,
  270,  271,  272,  273,  274,  268,  264,  265,  266,  269,
  276,  170,    0,  193,    0,  120,    0,    0,  111,  110,
    0,   89,    0,  289,  287,  286,  290,    0,   42,   41,
    4,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   38,    5,    0,   39,  171,  172,  173,    0,    0,    0,
  164,  222,  223,    0,  153,    0,  288,   43,  108,  304,
  305,    0,    0,  158,    0,    0,    0,  165,  154,  155,
    0,    0,    0,  163,
};
static const short yydgoto[] = {                          1,
  323,   75,    0,  361,  362,   31,   32,   33,   34,   35,
   36,   37,   38,   39,   40,   41,   42,   43,   44,   45,
   46,   47,  294,   48,   49,  295,  297,  298,   50,   51,
   52,   53,   54,   55,   56,   57,   58,   59,   60,   61,
   62,   63,  384,  385,  271,  136,  137,  146,  147,  115,
  116,  342,  343,  157,  158,  182,  183,  302,  306,  267,
  277,  282,  152,  153,  163,  164,  107,  101,  287,  288,
    0,  278,  189,   90,   91,  138,  117,  344,  139,  148,
  118,  159,  154,  140,  149,  119,  345,  160,  184,  303,
  201,  307,  259,  165,  102,  171,  386,  380,  381,  392,
};
static const short yysindex[] = {                         0,
 -225,    0,    0, -149,    0, -262, -278, -132,    7,    0,
 -284, -278, -239, -239,    0, -239, -255, -120, -113, -322,
 -322, -239,    0,    0,    0, -160, -187,    0,    0,    0,
    0,    0,  -96, -108,  100, -192,    0, -213,    0,    0,
    0,    0,    0,    0, -109,    0,    0, -133,    0,    0,
    0,    0,    0,    0, -185,    0,    0, -322,    0, -178,
    0,    0,    0, -213,    0, -108,    0,    0,   11,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, -239,
 -153, -239, -239, -239, -114,   65, -249,    0,  -50, -111,
  -63,  -63,  -63,    0,    0,    0,    0,    0,    0,    0,
    0, -100,    0,  -63,    0,  -92,    0,    0,    0,    0,
    0,    0,    0,    0,    0, -129,    0,    0,  -89,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  -93,    0,    0,  -81,
    0,    0,    0,    0,    0,  -68,    0,    0,  -65,    0,
    0,    0,  -57,  -56,  -75,    0,    0,  -36,    0,  -30,
    0,    0,  -20,    0,  -19,    0,    0,    0,    0,    0,
  -71,  -60,    8,    0,  -14,  -10,    0,    0,    0,    0,
    0,    0,   -5,   -3,  -63,    0,    0, -151, -135,  -63,
  -63,  -63, -147,    4,    0,    0,    0,    0,   28,    0,
   33,  -54,    0,    0,    0,    0,    0,  101,    0,    0,
    0,  101,    0,   32, -270, -108, -270,  235,  -38, -192,
  -38, -215, -270, -163, -133, -270, -185, -270,    0,    0,
   54,   57, -268,   43,  -16,  -38,    0,    0,    0,    0,
    0,    0,    0,    0,   78, -268,   43, -270,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   52,
    0,    0,    0,    0,    0,    0,    0, -151,    0,    0,
   55,    0,    0,    0,    0,   81,   25,   29,    0,    0,
    0,    0,   91,  357, -264, -108, -286,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   61,    0,    0,
   60,    0,    0,    0,   98,  -74,   66,   99, 1109,   68,
 1109,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   74,    0,   79,    0,  357,   51,    0,    0,
   76,    0,  108,    0,    0,    0,    0,  123,    0,    0,
    0, -197,  133, -169,  -48, -270,   54,  115, -157,  105,
    0,    0,  112,    0,    0,    0,    0, -208,  -58,  -72,
    0,    0,    0,  118,    0,  119,    0,    0,    0,    0,
    0,  124,  115,    0, -157, -270,  -58,    0,    0,    0,
  125,  -58,  121,    0,
};
static const short yyrindex[] = {                         0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0, 1607,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, 1636, 1675, 1704, 1769,    0, 1837,    0,    0,
    0,    0,    0,    0, 1866,    0,    0, 1926,    0,    0,
    0,    0,    0,    0, 2000,    0,    0, 2060,    0, 2089,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 2151, 2222, 2251,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, 2290,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0, 1171,    0,    0, 1081,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  541,    0,    0,  271,
    0,    0,    0,    0,    0, 1405,    0,    0, 1272,    0,
    0,    0,  580,    0,    0,    0,    0,  850,    0,  715,
    0,    0, 1474,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, 2319, 1542, 2384,    0,    0, 2452,    1, 2481,
 2541, 2615,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  406,
    0,    0,    0,    0,    0,    0,    0,  136,    0,    0,
  946,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, -154,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, 1253,    0, -143,    0, -150,    0,    0,    0,
    0,    0,  676,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  811,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,
};
static const short yygindex[] = {                         0,
    0,  435,    0,   -1,  127,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, -288,    0,    0,   85,    0,  156,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   59,    0,  237,    0,    0,  246,  251,
  -64,  106,    0,  247,    0,  238,    0,  228,  236, -214,
 -211,  120,  262,  423,    0,  261,    0,  109,    0,    0,
    0,  408,    0,    0,  103,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  279,    0,    0,    0,    0,    0,  107, -269,
};
#define YYTABLESIZE 3003
static const short yytable[] = {                         30,
   60,  173,  269,   85,   99,  293,  347,   86,  284,  280,
  202,  290,  296,  292,  262,  263,  264,  265,   71,   72,
   73,  299,  300,   70,  310,   87,  203,   74,  349,   94,
    2,    3,    4,  314,    5,    6,    7,    8,    9,   10,
   11,   12,   13,   14,  100,   15,   16,   17,   18,   19,
  346,   20,   21,   22,   23,   24,   25,   26,   27,    3,
    4,  293,    5,    6,    7,    8,    9,   10,   11,   12,
   13,   14,  281,   15,   16,   17,   18,   19,   89,   20,
   21,   22,   23,   24,   25,   26,   27,    3,    4,  347,
    5,    6,    7,    8,    9,   10,   11,   12,   13,   14,
  301,   15,   16,   17,   18,   19,  389,   20,   21,   22,
   23,   24,   25,   26,   27,  106,   92,  371,   93,  107,
   64,  266,  285,  150,  104,  150,  174,  401,  151,  103,
  151,  186,  403,  237,  187,  299,  238,  241,  242,  243,
  244,  167,  168,  169,  170,  374,  141,   65,   66,  239,
  105,  377,  240,   76,  286,   77,   67,   68,  106,   69,
  106,   28,   29,  142,  107,   95,  166,   96,  143,  174,
  245,  174,   97,  108,   98,  144,  206,  207,  155,  145,
  208,  400,  185,  216,  190,  191,  192,  161,  162,   28,
   29,  174,  174,  174,  174,  174,  174,  156,  174,  174,
  174,  193,  174,  174,  174,  174,  209,  174,  174,  174,
  354,  355,  356,  357,  229,  214,  230,   28,   29,  218,
  109,  110,  174,  215,  210,  211,  217,  390,  212,  391,
  111,  348,  112,  382,  219,  383,  113,  204,  205,  281,
  393,  224,  394,  358,  220,  174,  273,  274,  275,  276,
  221,  114,  222,  231,  213,  222,   60,   60,   60,  223,
   60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
  150,   60,   60,   60,   60,   60,  225,   60,   60,   60,
   60,   60,   60,   60,   60,  226,  324,  325,  326,  327,
  328,  329,  227,  330,  331,  332,  228,  333,  334,  335,
  336,  233,  337,  338,  339,  234,   78,  235,   79,   80,
   81,   82,  236,   60,   83,   60,  261,  340,   84,  246,
  216,  232,  174,  293,   60,   60,   60,   60,   60,  249,
  250,  251,   60,   60,   60,  304,  305,  318,  319,   60,
  341,  320,  321,  247,  175,  308,  176,  177,  248,  174,
   60,  178,  179,  180,  181,  296,   60,   60,   60,   60,
  372,   60,  372,  216,  367,   60,  311,  315,   60,  317,
  316,  175,   60,  176,  177,  322,  351,  352,  178,  179,
  180,  181,  353,  359,  360,  363,  365,   60,   60,  368,
   60,  299,  299,  299,  366,  299,  299,  299,  299,  299,
  299,  299,  299,  299,  299,  221,  299,  299,  299,  299,
  299,  370,  299,  299,  299,  299,  299,  299,  299,  299,
  369,  373,  387,  120,  121,  122,  123,  124,  379,  388,
  395,  125,  126,  127,  396,  404,  397,  402,  128,  194,
  195,  196,  197,  198,  199,  200,   88,  364,  299,  129,
  299,  378,  350,  399,  272,  130,  131,  132,  133,  299,
  299,  299,  299,  299,  134,  279,  268,  299,  299,  299,
  375,  289,  309,  312,  299,  252,  253,  254,  255,  256,
  257,  258,  313,  283,  376,  299,  172,  291,  188,  135,
  260,  299,  299,  299,  299,    0,  299,    0,    0,  398,
  299,    0,    0,  299,    0,    0,    0,  299,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  299,  299,    0,  299,  150,  150,  150,    0,
  150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
  115,  150,  150,  150,  150,  150,    0,  150,  150,  150,
  150,  150,  150,  150,  150,    0,    0,    0,  120,  121,
  122,  123,  124,    0,    0,    0,  125,  126,  127,    0,
    0,    0,    0,  128,    0,    0,    0,    0,    0,  121,
    0,    0,    0,  150,  129,  150,    0,    0,    0,    0,
  130,  131,  132,  133,  150,  150,  150,  150,  150,  134,
    0,    0,  150,  150,  150,    0,    0,    0,    0,  150,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  150,    0,    0,    0,  270,    0,  150,  150,  150,  150,
    0,    0,    0,    0,    0,  150,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  150,  150,    0,
  150,  221,  221,  221,    0,  221,  221,  221,  221,  221,
  221,  221,  221,  221,  221,  151,  221,  221,  221,  221,
  221,    0,  221,  221,  221,  221,  221,  221,  221,  221,
    0,  324,  325,  326,  327,  328,  329,    0,  330,  331,
  332,    0,  333,  334,  335,  336,    0,  337,  338,  339,
    0,    0,    0,    0,  178,    0,    0,    0,  221,    0,
  221,    0,  340,    0,    0,    0,    0,    0,    0,  221,
  221,  221,  221,  221,    0,    0,    0,  221,  221,  221,
    0,    0,    0,    0,  221,  341,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  221,    0,    0,    0,    0,
    0,  221,  221,  221,  221,    0,    0,    0,    0,    0,
  221,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  221,  221,    0,  221,  115,  115,  115,    0,
  115,  115,  115,  115,  115,  115,  115,  115,  115,  115,
  152,  115,  115,  115,  115,  115,    0,  115,  115,  115,
  115,  115,  115,  115,  115,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  121,  121,  121,    0,  121,
  121,  121,  121,  121,  121,  121,  121,  121,  121,   45,
  121,  121,  121,  121,  121,  115,  121,  121,  121,  121,
  121,  121,  121,  121,  115,  115,  115,  115,  115,    0,
    0,    0,  115,  115,  115,    0,    0,    0,    0,  115,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  115,    0,    0,    0,  121,    0,  115,  115,  115,  115,
    0,    0,    0,    0,    0,  115,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  121,    0,
    0,    0,    0,  121,    0,    0,    0,  115,  115,    0,
  115,  151,  151,  151,    0,  151,  151,  151,  151,  151,
  151,  151,  151,  151,  151,  291,  151,  151,  151,  151,
  151,    0,  151,  151,  151,  151,  151,  151,  151,  151,
    0,    0,    0,    0,    0,    0,  121,  121,    0,    0,
  178,  178,  178,    0,  178,  178,  178,  178,  178,  178,
  178,  178,  178,  178,    0,  178,  178,  178,  178,  178,
  151,  178,  178,  178,  178,  178,  178,  178,  178,  151,
  151,  151,  151,  151,    0,    0,    0,  151,  151,  151,
    0,    0,    0,    0,  151,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  151,    0,  178,    0,  178,
    0,  151,  151,  151,  151,    0,    0,    0,    0,    0,
  151,    0,    0,    0,    0,  178,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  151,  151,    0,  151,  152,  152,  152,    0,
  152,  152,  152,  152,  152,  152,  152,  152,  152,  152,
  169,  152,  152,  152,  152,  152,    0,  152,  152,  152,
  152,  152,  152,  152,  152,    0,    0,    0,    0,    0,
    0,  178,  178,    0,    0,   45,   45,   45,    0,   45,
   45,   45,   45,   45,   45,   45,   45,   45,   45,    0,
   45,   45,   45,   45,   45,  152,   45,   45,   45,   45,
   45,   45,   45,   45,  152,  152,  152,  152,  152,    0,
    0,    0,  152,  152,  152,    0,    0,    0,    0,  152,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  152,    0,    0,    0,   45,    0,  152,  152,  152,  152,
  112,    0,    0,    0,    0,  152,    0,    0,    0,    0,
   45,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  152,  152,    0,
  152,  291,  291,  291,    0,  291,  291,  291,  291,  291,
  291,  291,  291,  291,  291,  291,  291,  291,  291,  291,
  291,    0,  291,  291,  291,  291,  291,  291,  291,  291,
    0,    0,    0,    0,    0,    0,   45,   45,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  291,  291,
  291,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  148,    0,    0,    0,    0,    0,    0,    0,    0,
  291,  291,  291,  291,  291,  291,    0,  291,  291,  291,
    0,  291,  291,  291,  291,    0,  291,  291,  291,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  291,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  291,  291,  291,    0,  169,  169,  169,    0,
  169,  169,  169,  169,  169,  169,  169,  169,  169,  169,
    0,  169,  169,  169,  169,  169,    0,  169,  169,  169,
  169,  169,  169,  169,  169,    3,    4,    0,    5,    6,
    7,    8,    9,   10,   11,   12,   13,   14,    0,   15,
   16,   17,   18,   19,    0,   20,   21,   22,   23,   24,
   25,   26,   27,  169,  169,  169,    0,    0,    0,    0,
    0,    0,    0,    0,  118,    0,    0,    0,    0,  169,
  169,    0,    0,    0,    0,    0,    0,    0,    0,  169,
    0,  169,    0,    0,    0,  169,  112,  112,  112,    0,
  112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
  169,  112,  112,  112,  112,  112,    0,  112,  112,  112,
  112,  112,  112,  112,  112,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  169,  169,    0,
    0,    0,    0,   54,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  112,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   28,   29,    0,    0,  112,
  112,    0,    0,    0,    0,    0,    0,    0,    0,  112,
    0,  112,    0,    0,    0,  112,    0,    0,    0,    0,
    0,    0,  133,    0,    0,    0,    0,  148,  148,  148,
  112,  148,  148,  148,  148,  148,  148,  148,  148,  148,
  148,  160,  148,  148,  148,  148,  148,    0,  148,  148,
  148,  148,  148,  148,  148,  148,    0,  112,  112,    0,
    0,    0,    0,    0,    0,    0,    0,  133,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  148,    0,  148,  133,  133,  133,
  133,  133,  133,    0,  133,  133,  133,    0,  133,  133,
  133,  133,    0,  133,  133,  133,  130,    0,    0,    0,
  148,    0,    0,    0,    0,    0,    0,    0,  133,    0,
    0,    0,    0,    0,    0,    0,    0,  148,    0,    0,
    0,    0,  148,    0,    0,   21,    0,    0,    0,  148,
    0,  133,    0,  148,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  148,  148,
  118,  118,  118,    0,  118,  118,  118,  118,  118,  118,
  118,  118,  118,  118,    6,  118,  118,  118,  118,  118,
    0,  118,  118,  118,  118,  118,  118,  118,  118,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    7,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  118,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   54,
   54,   54,    0,   54,   54,   54,   54,   54,   54,   54,
   54,   54,   54,  118,   54,   54,   54,   54,   54,    0,
   54,   54,   54,   54,   54,   54,   54,   54,    0,    0,
  118,    0,    0,    0,    0,  118,    0,    0,    8,    0,
    0,    0,  118,    0,    0,    0,  118,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   54,    0,
    0,  118,  118,    0,    0,    0,    0,  160,  160,  160,
    0,  160,  160,  160,  160,  160,  160,  160,  160,  160,
  160,    0,  160,  160,  160,  160,  160,    0,  160,  160,
  160,  160,  160,  160,  160,  160,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   10,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   54,   54,    0,    0,
    0,    0,    0,    0,  160,    0,  160,    0,    0,    0,
   54,   54,  130,  130,  130,   17,  130,  130,  130,  130,
  130,  130,  130,  130,  130,  130,    0,  130,  130,  130,
  130,  130,    0,  130,  130,  130,  130,  130,  130,  130,
  130,   21,   21,   21,    0,   21,   21,   21,   21,   21,
   21,   21,   21,   21,   21,    0,   21,   21,   21,   21,
   21,    0,   21,   21,   21,   21,   21,   21,   21,   21,
    0,  130,    0,    0,    0,   12,    0,    0,  160,  160,
    6,    6,    6,    0,    6,    6,    6,    6,    6,    6,
    6,    6,    6,    6,    0,    6,    6,    6,    6,    6,
   21,    6,    6,    6,    6,    6,    6,    6,    6,    7,
    7,    7,    0,    7,    7,    7,    7,    7,    7,    7,
    7,    7,    7,    0,    7,    7,    7,    7,    7,    0,
    7,    7,    7,    7,    7,    7,    7,    7,    0,    6,
    0,    0,    0,  130,  130,    0,    0,    0,    0,   34,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    7,    0,
    0,    0,   21,   21,    8,    8,    8,    0,    8,    8,
    8,    8,    8,    8,    8,    8,    8,    8,    0,    8,
    8,    8,    8,    8,    0,    8,    8,    8,    8,    8,
    8,    8,    8,    0,    0,    0,    0,    0,    0,   18,
    0,    6,    6,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    8,    0,    0,    0,    0,   82,    0,
    7,    7,   10,   10,   10,    0,   10,   10,   10,   10,
   10,   10,   10,   10,   10,   10,    0,   10,   10,   10,
   10,   10,    0,   10,   10,   10,   10,   10,   10,   10,
   10,   17,   17,   17,    0,   17,   17,   17,   17,   17,
   17,   17,   17,   17,   17,    0,   17,   17,   17,   17,
   17,    0,   17,   17,   17,   17,   17,   17,   17,   17,
   80,   10,    0,    0,    0,    8,    8,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   17,   12,   12,   12,    0,   12,   12,   12,   12,   12,
   12,   12,   12,   12,   12,    0,   12,   12,   12,   12,
   12,    0,   12,   12,   12,   12,   12,   12,   12,   12,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   46,    0,   10,   10,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   12,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   47,    0,   17,   17,    0,   34,   34,   34,    0,   34,
   34,   34,   34,   34,   34,   34,   34,   34,   34,    0,
   34,   34,   34,   34,   34,    0,   34,   34,   34,   34,
   34,   34,   34,   34,    0,    0,    0,    0,    0,   51,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   12,   12,   34,   18,   18,   18,  119,   18,
   18,   18,   18,   18,   18,   18,   18,   18,   18,    0,
   18,   18,   18,   18,   18,    0,   18,   18,   18,   18,
   18,   18,   18,   18,   82,   82,   82,    0,   82,   82,
   82,   82,   82,   82,   82,   82,   82,   82,    0,   82,
   82,   82,   82,   82,    0,   82,   82,   82,   82,   82,
   82,   82,   82,    0,   18,    0,    0,    0,    0,    0,
    0,    0,    0,  102,    0,    0,   34,   34,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   82,    0,    0,   80,   80,   80,    0,
   80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
    0,   80,   80,   80,   80,   80,    0,   80,   80,   80,
   80,   80,   80,   80,   80,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   18,   18,    0,    0,
    0,  100,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   80,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   82,   82,   46,   46,   46,
  101,   46,   46,   46,   46,   46,   46,   46,   46,   46,
   46,    0,   46,   46,   46,   46,   46,    0,   46,   46,
   46,   46,   46,   46,   46,   46,   47,   47,   47,    0,
   47,   47,   47,   47,   47,   47,   47,   47,   47,   47,
    0,   47,   47,   47,   47,   47,    0,   47,   47,   47,
   47,   47,   47,   47,   47,    0,   46,   80,   80,    0,
  103,    0,    0,    0,    0,   51,   51,   51,    0,   51,
   51,   51,   51,   51,   51,   51,   51,   51,   51,    0,
   51,   51,   51,   51,   51,   47,   51,   51,   51,   51,
   51,   51,   51,   51,  119,  119,  119,    0,  119,  119,
  119,  119,  119,  119,  119,  119,  119,  119,    0,  119,
  119,  119,  119,  119,    0,  119,  119,  119,  119,  119,
  119,  119,  119,    0,   51,    0,    0,    0,   46,   46,
    0,    0,    0,    0,  104,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  119,    0,    0,    0,   47,   47,  102,
  102,  102,    0,  102,  102,  102,  102,  102,  102,  102,
  102,  102,  102,    0,  102,  102,  102,  102,  102,    0,
  102,  102,  102,  102,  102,  102,  102,  102,    0,    0,
    0,    0,    0,    0,    0,    0,   51,   51,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  102,    0,
    0,    0,    0,    0,    0,  119,  119,  100,  100,  100,
    0,  100,  100,  100,  100,  100,  100,  100,  100,  100,
  100,    0,  100,  100,  100,  100,  100,    0,  100,  100,
  100,  100,  100,  100,  100,  100,  101,  101,  101,    0,
  101,  101,  101,  101,  101,  101,  101,  101,  101,  101,
    0,  101,  101,  101,  101,  101,    0,  101,  101,  101,
  101,  101,  101,  101,  101,    0,  100,    0,    0,    0,
  102,  102,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  101,  103,  103,  103,    0,
  103,  103,  103,  103,  103,  103,  103,  103,  103,  103,
    0,  103,  103,  103,  103,  103,    0,  103,  103,  103,
  103,  103,  103,  103,  103,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  100,  100,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  103,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  101,  101,    0,
  104,  104,  104,    0,  104,  104,  104,  104,  104,  104,
  104,  104,  104,  104,    0,  104,  104,  104,  104,  104,
    0,  104,  104,  104,  104,  104,  104,  104,  104,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  103,  103,  104,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  104,  104,
};
static const short yycheck[] = {                          1,
    0,   66,  217,  288,  327,  270,  295,  292,  223,  221,
  260,  226,  299,  228,  285,  286,  287,  288,  297,  298,
  299,  290,  291,  286,  236,  310,  276,  306,  315,  285,
  256,  257,  258,  248,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,  367,  271,  272,  273,  274,  275,
  315,  277,  278,  279,  280,  281,  282,  283,  284,  257,
  258,  270,  260,  261,  262,  263,  264,  265,  266,  267,
  268,  269,  288,  271,  272,  273,  274,  275,  318,  277,
  278,  279,  280,  281,  282,  283,  284,  257,  258,  378,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
  369,  271,  272,  273,  274,  275,  315,  277,  278,  279,
  280,  281,  282,  283,  284,  270,   14,  315,   16,  270,
  270,  392,  286,  339,   22,  339,  270,  397,  344,   21,
  344,  285,  402,  285,  288,    0,  288,  285,  286,  287,
  288,  320,  321,  322,  323,  315,  339,  297,  298,  285,
  311,  366,  288,  286,  318,  288,  306,  307,  346,  309,
  315,  387,  388,  356,  315,  286,   58,  288,  361,  313,
  318,  315,  286,  270,  288,  368,  288,  289,  288,  372,
  292,  396,   80,  313,   82,   83,   84,  373,  374,  387,
  388,  335,  336,  337,  338,  339,  340,  331,  342,  343,
  344,  316,  346,  347,  348,  349,  318,  351,  352,  353,
  285,  286,  287,  288,  286,  316,  288,  387,  388,  313,
  329,  330,  366,  316,  288,  289,  316,  286,  292,  288,
  339,  296,  341,  391,  316,  393,  345,  288,  289,  288,
  313,  317,  315,  318,  313,  389,  285,  286,  287,  288,
  316,  360,  313,  314,  318,  313,  256,  257,  258,  316,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
    0,  271,  272,  273,  274,  275,  313,  277,  278,  279,
  280,  281,  282,  283,  284,  316,  335,  336,  337,  338,
  339,  340,  313,  342,  343,  344,  316,  346,  347,  348,
  349,  316,  351,  352,  353,  316,  300,  313,  302,  303,
  304,  305,  316,  313,  308,  315,  285,  366,  312,  316,
  313,  314,  339,  270,  324,  325,  326,  327,  328,  384,
  385,  386,  332,  333,  334,  293,  294,  313,  314,  339,
  389,  313,  314,  316,  361,  362,  363,  364,  316,  339,
  350,  368,  369,  370,  371,  299,  356,  357,  358,  359,
  362,  361,  364,  313,  314,  365,  289,  316,  368,  289,
  316,  361,  372,  363,  364,  285,  316,  318,  368,  369,
  370,  371,  285,  318,  286,  318,  313,  387,  388,  314,
  390,  256,  257,  258,  316,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,    0,  271,  272,  273,  274,
  275,  289,  277,  278,  279,  280,  281,  282,  283,  284,
  313,  289,  318,  324,  325,  326,  327,  328,  314,  318,
  313,  332,  333,  334,  316,  315,  313,  313,  339,  375,
  376,  377,  378,  379,  380,  381,   12,  321,  313,  350,
  315,  367,  297,  395,  218,  356,  357,  358,  359,  324,
  325,  326,  327,  328,  365,  220,  216,  332,  333,  334,
  365,  225,  235,  246,  339,  375,  376,  377,  378,  379,
  380,  381,  247,  222,  365,  350,   64,  227,   81,  390,
  212,  356,  357,  358,  359,   -1,  361,   -1,   -1,  393,
  365,   -1,   -1,  368,   -1,   -1,   -1,  372,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  387,  388,   -1,  390,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
    0,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,   -1,   -1,   -1,  324,  325,
  326,  327,  328,   -1,   -1,   -1,  332,  333,  334,   -1,
   -1,   -1,   -1,  339,   -1,   -1,   -1,   -1,   -1,    0,
   -1,   -1,   -1,  313,  350,  315,   -1,   -1,   -1,   -1,
  356,  357,  358,  359,  324,  325,  326,  327,  328,  365,
   -1,   -1,  332,  333,  334,   -1,   -1,   -1,   -1,  339,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  350,   -1,   -1,   -1,  390,   -1,  356,  357,  358,  359,
   -1,   -1,   -1,   -1,   -1,  365,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,
  390,  256,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,    0,  271,  272,  273,  274,
  275,   -1,  277,  278,  279,  280,  281,  282,  283,  284,
   -1,  335,  336,  337,  338,  339,  340,   -1,  342,  343,
  344,   -1,  346,  347,  348,  349,   -1,  351,  352,  353,
   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,  313,   -1,
  315,   -1,  366,   -1,   -1,   -1,   -1,   -1,   -1,  324,
  325,  326,  327,  328,   -1,   -1,   -1,  332,  333,  334,
   -1,   -1,   -1,   -1,  339,  389,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  350,   -1,   -1,   -1,   -1,
   -1,  356,  357,  358,  359,   -1,   -1,   -1,   -1,   -1,
  365,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  387,  388,   -1,  390,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
    0,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  256,  257,  258,   -1,  260,
  261,  262,  263,  264,  265,  266,  267,  268,  269,    0,
  271,  272,  273,  274,  275,  315,  277,  278,  279,  280,
  281,  282,  283,  284,  324,  325,  326,  327,  328,   -1,
   -1,   -1,  332,  333,  334,   -1,   -1,   -1,   -1,  339,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  350,   -1,   -1,   -1,  315,   -1,  356,  357,  358,  359,
   -1,   -1,   -1,   -1,   -1,  365,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  339,   -1,
   -1,   -1,   -1,  344,   -1,   -1,   -1,  387,  388,   -1,
  390,  256,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,    0,  271,  272,  273,  274,
  275,   -1,  277,  278,  279,  280,  281,  282,  283,  284,
   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,   -1,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,   -1,  271,  272,  273,  274,  275,
  315,  277,  278,  279,  280,  281,  282,  283,  284,  324,
  325,  326,  327,  328,   -1,   -1,   -1,  332,  333,  334,
   -1,   -1,   -1,   -1,  339,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  350,   -1,  313,   -1,  315,
   -1,  356,  357,  358,  359,   -1,   -1,   -1,   -1,   -1,
  365,   -1,   -1,   -1,   -1,  331,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  387,  388,   -1,  390,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
    0,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,   -1,   -1,   -1,   -1,   -1,
   -1,  387,  388,   -1,   -1,  256,  257,  258,   -1,  260,
  261,  262,  263,  264,  265,  266,  267,  268,  269,   -1,
  271,  272,  273,  274,  275,  315,  277,  278,  279,  280,
  281,  282,  283,  284,  324,  325,  326,  327,  328,   -1,
   -1,   -1,  332,  333,  334,   -1,   -1,   -1,   -1,  339,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  350,   -1,   -1,   -1,  315,   -1,  356,  357,  358,  359,
    0,   -1,   -1,   -1,   -1,  365,   -1,   -1,   -1,   -1,
  331,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,
  390,  256,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,  270,  271,  272,  273,  274,
  275,   -1,  277,  278,  279,  280,  281,  282,  283,  284,
   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  313,  314,
  315,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  335,  336,  337,  338,  339,  340,   -1,  342,  343,  344,
   -1,  346,  347,  348,  349,   -1,  351,  352,  353,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  366,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  387,  388,  389,   -1,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,  257,  258,   -1,  260,  261,
  262,  263,  264,  265,  266,  267,  268,  269,   -1,  271,
  272,  273,  274,  275,   -1,  277,  278,  279,  280,  281,
  282,  283,  284,  313,  314,  315,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,  329,
  330,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  339,
   -1,  341,   -1,   -1,   -1,  345,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
  360,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,
   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  315,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,   -1,  329,
  330,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  339,
   -1,  341,   -1,   -1,   -1,  345,   -1,   -1,   -1,   -1,
   -1,   -1,  270,   -1,   -1,   -1,   -1,  256,  257,  258,
  360,  260,  261,  262,  263,  264,  265,  266,  267,  268,
  269,    0,  271,  272,  273,  274,  275,   -1,  277,  278,
  279,  280,  281,  282,  283,  284,   -1,  387,  388,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  315,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  313,   -1,  315,  335,  336,  337,
  338,  339,  340,   -1,  342,  343,  344,   -1,  346,  347,
  348,  349,   -1,  351,  352,  353,    0,   -1,   -1,   -1,
  339,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  366,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  356,   -1,   -1,
   -1,   -1,  361,   -1,   -1,    0,   -1,   -1,   -1,  368,
   -1,  389,   -1,  372,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,    0,  271,  272,  273,  274,  275,
   -1,  277,  278,  279,  280,  281,  282,  283,  284,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  315,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  256,
  257,  258,   -1,  260,  261,  262,  263,  264,  265,  266,
  267,  268,  269,  339,  271,  272,  273,  274,  275,   -1,
  277,  278,  279,  280,  281,  282,  283,  284,   -1,   -1,
  356,   -1,   -1,   -1,   -1,  361,   -1,   -1,    0,   -1,
   -1,   -1,  368,   -1,   -1,   -1,  372,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  315,   -1,
   -1,  387,  388,   -1,   -1,   -1,   -1,  256,  257,  258,
   -1,  260,  261,  262,  263,  264,  265,  266,  267,  268,
  269,   -1,  271,  272,  273,  274,  275,   -1,  277,  278,
  279,  280,  281,  282,  283,  284,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  373,  374,   -1,   -1,
   -1,   -1,   -1,   -1,  313,   -1,  315,   -1,   -1,   -1,
  387,  388,  256,  257,  258,    0,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,   -1,  271,  272,  273,
  274,  275,   -1,  277,  278,  279,  280,  281,  282,  283,
  284,  256,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,   -1,  271,  272,  273,  274,
  275,   -1,  277,  278,  279,  280,  281,  282,  283,  284,
   -1,  315,   -1,   -1,   -1,    0,   -1,   -1,  387,  388,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,   -1,  271,  272,  273,  274,  275,
  315,  277,  278,  279,  280,  281,  282,  283,  284,  256,
  257,  258,   -1,  260,  261,  262,  263,  264,  265,  266,
  267,  268,  269,   -1,  271,  272,  273,  274,  275,   -1,
  277,  278,  279,  280,  281,  282,  283,  284,   -1,  315,
   -1,   -1,   -1,  387,  388,   -1,   -1,   -1,   -1,    0,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  315,   -1,
   -1,   -1,  387,  388,  256,  257,  258,   -1,  260,  261,
  262,  263,  264,  265,  266,  267,  268,  269,   -1,  271,
  272,  273,  274,  275,   -1,  277,  278,  279,  280,  281,
  282,  283,  284,   -1,   -1,   -1,   -1,   -1,   -1,    0,
   -1,  387,  388,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  315,   -1,   -1,   -1,   -1,    0,   -1,
  387,  388,  256,  257,  258,   -1,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,   -1,  271,  272,  273,
  274,  275,   -1,  277,  278,  279,  280,  281,  282,  283,
  284,  256,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,   -1,  271,  272,  273,  274,
  275,   -1,  277,  278,  279,  280,  281,  282,  283,  284,
    0,  315,   -1,   -1,   -1,  387,  388,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  315,  256,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,   -1,  271,  272,  273,  274,
  275,   -1,  277,  278,  279,  280,  281,  282,  283,  284,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,    0,   -1,  387,  388,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  315,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
    0,   -1,  387,  388,   -1,  256,  257,  258,   -1,  260,
  261,  262,  263,  264,  265,  266,  267,  268,  269,   -1,
  271,  272,  273,  274,  275,   -1,  277,  278,  279,  280,
  281,  282,  283,  284,   -1,   -1,   -1,   -1,   -1,    0,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  387,  388,  315,  256,  257,  258,    0,  260,
  261,  262,  263,  264,  265,  266,  267,  268,  269,   -1,
  271,  272,  273,  274,  275,   -1,  277,  278,  279,  280,
  281,  282,  283,  284,  256,  257,  258,   -1,  260,  261,
  262,  263,  264,  265,  266,  267,  268,  269,   -1,  271,
  272,  273,  274,  275,   -1,  277,  278,  279,  280,  281,
  282,  283,  284,   -1,  315,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,    0,   -1,   -1,  387,  388,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  315,   -1,   -1,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,   -1,
   -1,    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  315,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  387,  388,  256,  257,  258,
    0,  260,  261,  262,  263,  264,  265,  266,  267,  268,
  269,   -1,  271,  272,  273,  274,  275,   -1,  277,  278,
  279,  280,  281,  282,  283,  284,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,   -1,  315,  387,  388,   -1,
    0,   -1,   -1,   -1,   -1,  256,  257,  258,   -1,  260,
  261,  262,  263,  264,  265,  266,  267,  268,  269,   -1,
  271,  272,  273,  274,  275,  315,  277,  278,  279,  280,
  281,  282,  283,  284,  256,  257,  258,   -1,  260,  261,
  262,  263,  264,  265,  266,  267,  268,  269,   -1,  271,
  272,  273,  274,  275,   -1,  277,  278,  279,  280,  281,
  282,  283,  284,   -1,  315,   -1,   -1,   -1,  387,  388,
   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  315,   -1,   -1,   -1,  387,  388,  256,
  257,  258,   -1,  260,  261,  262,  263,  264,  265,  266,
  267,  268,  269,   -1,  271,  272,  273,  274,  275,   -1,
  277,  278,  279,  280,  281,  282,  283,  284,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  315,   -1,
   -1,   -1,   -1,   -1,   -1,  387,  388,  256,  257,  258,
   -1,  260,  261,  262,  263,  264,  265,  266,  267,  268,
  269,   -1,  271,  272,  273,  274,  275,   -1,  277,  278,
  279,  280,  281,  282,  283,  284,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,   -1,  315,   -1,   -1,   -1,
  387,  388,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  315,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  315,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,   -1,  271,  272,  273,  274,  275,
   -1,  277,  278,  279,  280,  281,  282,  283,  284,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,  315,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  387,  388,
};
#define YYFINAL 1
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 393
#if YYDEBUG
static const char *yyname[] = {

"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"FSC_LIST","FSC_DEFINE",
"FSC_EXEC","FSC_QUIT","FSC_DEBUG","FSC_CREATE","FSC_SLEEP","FSC_STATS",
"FSC_FOREACH","FSC_SET","FSC_SHUTDOWN","FSC_LOG","FSC_SYSTEM","FSC_FLOWOP",
"FSC_EVENTGEN","FSC_ECHO","FSC_LOAD","FSC_RUN","FSC_WARMUP","FSC_NOUSESTATS",
"FSC_FSCHECK","FSC_FSFLUSH","FSC_USAGE","FSC_HELP","FSC_VARS","FSC_VERSION",
"FSC_ENABLE","FSC_DOMULTISYNC","FSV_STRING","FSV_VAL_INT","FSV_VAL_BOOLEAN",
"FSV_VARIABLE","FSV_WHITESTRING","FSV_RANDUNI","FSV_RANDTAB","FSV_RANDVAR",
"FSV_URAND","FSV_RAND48","FST_INT","FST_BOOLEAN","FSE_FILE","FSE_PROC",
"FSE_THREAD","FSE_CLEAR","FSE_ALL","FSE_SNAP","FSE_DUMP","FSE_DIRECTORY",
"FSE_COMMAND","FSE_FILESET","FSE_POSSET","FSE_XMLDUMP","FSE_RAND","FSE_MODE",
"FSE_MULTI","FSE_MULTIDUMP","FSK_SEPLST","FSK_OPENLST","FSK_CLOSELST",
"FSK_ASSIGN","FSK_IN","FSK_QUOTE","FSK_DIRSEPLST","FSK_PLUS","FSK_MINUS",
"FSK_MULTIPLY","FSK_DIVIDE","FSA_SIZE","FSA_PREALLOC","FSA_PARALLOC","FSA_PATH",
"FSA_REUSE","FSA_PROCESS","FSA_MEMSIZE","FSA_RATE","FSA_CACHED","FSA_READONLY",
"FSA_TRUSTTREE","FSA_IOSIZE","FSA_FILE","FSA_POSSET","FSA_WSS","FSA_NAME",
"FSA_RANDOM","FSA_INSTANCES","FSA_DSYNC","FSA_TARGET","FSA_ITERS","FSA_NICE",
"FSA_VALUE","FSA_BLOCKING","FSA_HIGHWATER","FSA_DIRECTIO","FSA_DIRWIDTH",
"FSA_FD","FSA_SRCFD","FSA_ROTATEFD","FSA_NAMELENGTH","FSA_FILESIZE",
"FSA_ENTRIES","FSA_FILESIZEGAMMA","FSA_DIRDEPTHRV","FSA_DIRGAMMA","FSA_USEISM",
"FSA_TYPE","FSA_RANDTABLE","FSA_RANDSRC","FSA_RANDROUND","FSA_LEAFDIRS",
"FSA_INDEXED","FSA_FSTYPE","FSA_RANDSEED","FSA_RANDGAMMA","FSA_RANDMEAN",
"FSA_RANDMIN","FSA_RANDMAX","FSA_MASTER","FSA_CLIENT","FSS_TYPE","FSS_SEED",
"FSS_GAMMA","FSS_MEAN","FSS_MIN","FSS_SRC","FSS_ROUND","FSV_SET_LOCAL_VAR",
"FSA_LVAR_ASSIGN","FSA_ALLDONE","FSA_FIRSTDONE","FSA_TIMEOUT",
"FSC_OSPROF_ENABLE","FSC_OSPROF_DISABLE","FSA_NOREADAHEAD","FSA_DSRC",
"FSA_ENTROPY","FSV_VAL_DBL","FSA_DUMMY",
};
static const char *yyrule[] = {
"$accept : commands",
"commands : commands command",
"commands : commands error",
"commands :",
"inner_commands : command",
"inner_commands : inner_commands command",
"command : proc_define_command",
"command : files_define_command",
"command : posset_define_command",
"command : randvar_define_command",
"command : fo_define_command",
"command : debug_command",
"command : eventgen_command",
"command : create_command",
"command : echo_command",
"command : usage_command",
"command : vars_command",
"command : foreach_command",
"command : fscheck_command",
"command : fsflush_command",
"command : help_command",
"command : list_command",
"command : load_command",
"command : log_command",
"command : run_command",
"command : set_command",
"command : shutdown_command",
"command : sleep_command",
"command : warmup_command",
"command : stats_command",
"command : system_command",
"command : version_command",
"command : osprof_enable_command",
"command : osprof_disable_command",
"command : enable_command",
"command : multisync_command",
"command : quit_command",
"foreach_command : FSC_FOREACH",
"foreach_command : foreach_command FSV_VARIABLE FSK_IN integer_seplist FSK_OPENLST inner_commands FSK_CLOSELST",
"foreach_command : foreach_command FSV_VARIABLE FSK_IN string_seplist FSK_OPENLST inner_commands FSK_CLOSELST",
"integer_seplist : FSV_VAL_INT",
"integer_seplist : integer_seplist FSK_SEPLST FSV_VAL_INT",
"string_seplist : FSK_QUOTE FSV_WHITESTRING FSK_QUOTE",
"string_seplist : string_seplist FSK_SEPLST FSK_QUOTE FSV_WHITESTRING FSK_QUOTE",
"eventgen_command : FSC_EVENTGEN",
"eventgen_command : eventgen_command ev_attr_ops",
"system_command : FSC_SYSTEM whitevar_string_list",
"echo_command : FSC_ECHO whitevar_string_list",
"version_command : FSC_VERSION",
"osprof_enable_command : FSC_OSPROF_ENABLE",
"osprof_disable_command : FSC_OSPROF_DISABLE",
"usage_command : FSC_USAGE whitevar_string_list",
"vars_command : FSC_VARS",
"enable_command : FSC_ENABLE FSE_MULTI",
"enable_command : enable_command enable_multi_ops",
"multisync_command : FSC_DOMULTISYNC multisync_op",
"string_list : FSV_VARIABLE",
"string_list : string_list FSK_SEPLST FSV_VARIABLE",
"var_string : FSV_VARIABLE",
"var_string : FSV_STRING",
"var_string_list : var_string",
"var_string_list : var_string FSV_STRING",
"var_string_list : var_string FSV_VARIABLE",
"var_string_list : var_string_list FSV_STRING",
"var_string_list : var_string_list FSV_VARIABLE",
"whitevar_string : FSK_QUOTE FSV_VARIABLE",
"whitevar_string : FSK_QUOTE FSV_WHITESTRING",
"whitevar_string_list : whitevar_string FSV_WHITESTRING",
"whitevar_string_list : whitevar_string FSV_VARIABLE",
"whitevar_string_list : whitevar_string FSV_RANDVAR randvar_attr_tsp",
"whitevar_string_list : whitevar_string_list FSV_WHITESTRING",
"whitevar_string_list : whitevar_string_list FSV_VARIABLE",
"whitevar_string_list : whitevar_string_list FSV_RANDVAR randvar_attr_tsp",
"whitevar_string_list : whitevar_string_list FSK_QUOTE",
"whitevar_string_list : whitevar_string FSK_QUOTE",
"list_command : FSC_LIST",
"list_command : list_command FSC_FLOWOP",
"fscheck_command : FSC_FSCHECK fscheck_attr_op",
"fscheck_command : fscheck_command fscheck_attr_op",
"fsflush_command : FSC_FSFLUSH fscheck_attr_op",
"log_command : FSC_LOG whitevar_string_list",
"debug_command : FSC_DEBUG FSV_VAL_INT",
"set_command : set_integer_command",
"set_command : set_other_command",
"set_integer_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSV_VAL_INT",
"set_integer_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSV_VARIABLE",
"set_integer_command : set_integer_command binary_op FSV_VAL_INT",
"set_integer_command : set_integer_command binary_op FSV_VARIABLE",
"set_other_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSV_VAL_BOOLEAN",
"set_other_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSK_QUOTE FSV_WHITESTRING FSK_QUOTE",
"set_other_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSV_STRING",
"set_other_command : FSC_SET FSE_MODE FSC_QUIT FSA_TIMEOUT",
"set_other_command : FSC_SET FSE_MODE FSC_QUIT FSA_ALLDONE",
"set_other_command : FSC_SET FSE_MODE FSC_QUIT FSA_FIRSTDONE",
"set_other_command : FSC_SET FSE_MODE FSC_NOUSESTATS",
"set_other_command : FSC_SET FSV_RANDVAR FSS_TYPE FSK_ASSIGN randvar_attr_typop",
"set_other_command : FSC_SET FSV_RANDVAR FSS_SRC FSK_ASSIGN randvar_attr_srcop",
"set_other_command : FSC_SET FSV_RANDVAR randvar_attr_param FSK_ASSIGN attr_value",
"stats_command : FSC_STATS FSE_SNAP",
"stats_command : FSC_STATS FSE_CLEAR",
"stats_command : FSC_STATS FSE_DIRECTORY var_string_list",
"stats_command : FSC_STATS FSE_COMMAND whitevar_string_list",
"stats_command : FSC_STATS FSE_DUMP whitevar_string_list",
"stats_command : FSC_STATS FSE_XMLDUMP whitevar_string_list",
"stats_command : FSC_STATS FSE_MULTIDUMP whitevar_string_list",
"quit_command : FSC_QUIT",
"flowop_list : flowop_command",
"flowop_list : flowop_list flowop_command",
"thread : FSE_THREAD pt_attr_ops FSK_OPENLST flowop_list FSK_CLOSELST",
"thread_list : thread",
"thread_list : thread_list thread",
"proc_define_command : FSC_DEFINE FSE_PROC pt_attr_ops FSK_OPENLST thread_list FSK_CLOSELST",
"proc_define_command : proc_define_command pt_attr_ops",
"files_define_command : FSC_DEFINE FSE_FILE",
"files_define_command : FSC_DEFINE FSE_FILESET",
"files_define_command : files_define_command files_attr_ops",
"files_define_command : files_define_command files_attr_ops FSK_SEPLST source_type",
"posset_define_command : FSC_DEFINE FSE_POSSET",
"posset_define_command : posset_define_command posset_attr_ops",
"randvar_define_command : FSC_DEFINE FSE_RAND randvar_attr_ops",
"fo_define_command : FSC_DEFINE FSC_FLOWOP comp_attr_ops FSK_OPENLST flowop_list FSK_CLOSELST",
"fo_define_command : fo_define_command comp_attr_ops",
"create_command : FSC_CREATE entity",
"shutdown_command : FSC_SHUTDOWN entity",
"warmup_command : FSC_WARMUP FSV_VAL_INT",
"warmup_command : FSC_WARMUP FSV_VARIABLE",
"sleep_command : FSC_SLEEP FSV_VAL_INT",
"sleep_command : FSC_SLEEP FSV_VARIABLE",
"run_command : FSC_RUN FSV_VAL_INT",
"run_command : FSC_RUN FSV_VARIABLE",
"run_command : FSC_RUN",
"help_command : FSC_HELP",
"flowop_command : FSC_FLOWOP name",
"flowop_command : flowop_command fo_attr_ops",
"load_command : FSC_LOAD FSV_STRING",
"entity : FSE_PROC",
"entity : FSE_THREAD",
"entity : FSE_FILESET",
"entity : FSE_FILE",
"value : FSV_VAL_INT",
"value : FSV_STRING",
"value : FSV_VAL_BOOLEAN",
"name : FSV_STRING",
"files_attr_ops : files_attr_op",
"files_attr_ops : files_attr_ops FSK_SEPLST files_attr_op",
"posset_attr_ops : posset_attr_op",
"posset_attr_ops : posset_attr_ops FSK_SEPLST posset_attr_op",
"posset_attr_op : posset_attr_name FSK_ASSIGN attr_list_value",
"posset_attr_op : posset_attr_name",
"files_attr_op : files_attr_name FSK_ASSIGN attr_list_value",
"files_attr_op : files_attr_name",
"source_type : FSA_DSRC FSK_ASSIGN FSV_STRING",
"source_type : FSA_DSRC FSK_ASSIGN FSV_STRING FSK_SEPLST source_define_params",
"source_define_params : source_define_param",
"source_define_params : source_define_params FSK_SEPLST source_define_param",
"source_define_param : source_params_name FSK_ASSIGN attr_value",
"randvar_attr_ops : randvar_attr_op",
"randvar_attr_ops : randvar_attr_ops FSK_SEPLST randvar_attr_op",
"randvar_attr_ops : randvar_attr_ops FSK_SEPLST FSA_RANDTABLE FSK_ASSIGN FSK_OPENLST probtabentry_list FSK_CLOSELST",
"randvar_attr_op : randvar_attr_name FSK_ASSIGN attr_list_value",
"randvar_attr_op : randvar_attr_name",
"randvar_attr_op : FSA_TYPE FSK_ASSIGN randvar_attr_typop",
"randvar_attr_op : FSA_RANDSRC FSK_ASSIGN randvar_attr_srcop",
"probtabentry : FSK_OPENLST var_int_val FSK_SEPLST var_int_val FSK_SEPLST var_int_val FSK_CLOSELST",
"probtabentry_list : probtabentry",
"probtabentry_list : probtabentry_list FSK_SEPLST probtabentry",
"pt_attr_ops : pt_attr_op",
"pt_attr_ops : pt_attr_ops FSK_SEPLST pt_attr_op",
"pt_attr_op : pt_attr_name FSK_ASSIGN attr_value",
"pt_attr_op : pt_attr_name",
"fo_attr_ops : fo_attr_op",
"fo_attr_ops : fo_attr_ops FSK_SEPLST fo_attr_op",
"fo_attr_ops : fo_attr_ops FSK_SEPLST comp_lvar_def",
"fo_attr_op : fo_attr_name FSK_ASSIGN attr_value",
"fo_attr_op : fo_attr_name",
"ev_attr_ops : ev_attr_op",
"ev_attr_ops : ev_attr_ops FSK_SEPLST ev_attr_op",
"ev_attr_op : ev_attr_name FSK_ASSIGN attr_value",
"ev_attr_op : ev_attr_name",
"enable_multi_ops : enable_multi_op",
"enable_multi_ops : enable_multi_ops FSK_SEPLST enable_multi_op",
"enable_multi_op : em_attr_name FSK_ASSIGN attr_value",
"multisync_op : FSA_VALUE FSK_ASSIGN attr_value",
"fscheck_attr_op : fscheck_attr_name FSK_ASSIGN FSV_STRING",
"binary_op : FSK_PLUS",
"binary_op : FSK_MINUS",
"binary_op : FSK_MULTIPLY",
"binary_op : FSK_DIVIDE",
"files_attr_name : attrs_define_file",
"files_attr_name : attrs_define_fileset",
"posset_attr_name : attrs_define_posset",
"pt_attr_name : attrs_define_thread",
"pt_attr_name : attrs_define_proc",
"fo_attr_name : attrs_flowop",
"ev_attr_name : attrs_eventgen",
"attrs_define_proc : FSA_NICE",
"attrs_define_proc : FSA_NAME",
"attrs_define_proc : FSA_INSTANCES",
"attrs_define_file : FSA_SIZE",
"attrs_define_file : FSA_NAME",
"attrs_define_file : FSA_PATH",
"attrs_define_file : FSA_READONLY",
"attrs_define_file : FSA_TRUSTTREE",
"attrs_define_file : FSA_REUSE",
"attrs_define_file : FSA_PREALLOC",
"attrs_define_file : FSA_PARALLOC",
"attrs_define_fileset : FSA_SIZE",
"attrs_define_fileset : FSA_NAME",
"attrs_define_fileset : FSA_PATH",
"attrs_define_fileset : FSA_DIRWIDTH",
"attrs_define_fileset : FSA_DIRDEPTHRV",
"attrs_define_fileset : FSA_PREALLOC",
"attrs_define_fileset : FSA_PARALLOC",
"attrs_define_fileset : FSA_REUSE",
"attrs_define_fileset : FSA_READONLY",
"attrs_define_fileset : FSA_TRUSTTREE",
"attrs_define_fileset : FSA_FILESIZEGAMMA",
"attrs_define_fileset : FSA_DIRGAMMA",
"attrs_define_fileset : FSA_CACHED",
"attrs_define_fileset : FSA_ENTRIES",
"attrs_define_fileset : FSA_LEAFDIRS",
"attrs_define_fileset : FSA_DSRC",
"source_params_name : FSA_ENTROPY",
"source_params_name : FSA_DUMMY",
"attrs_define_posset : FSA_NAME",
"attrs_define_posset : FSA_TYPE",
"attrs_define_posset : FSA_RANDSEED",
"attrs_define_posset : FSA_ENTRIES",
"attrs_define_posset : FSA_RANDMAX",
"randvar_attr_name : FSA_NAME",
"randvar_attr_name : FSA_RANDSEED",
"randvar_attr_name : FSA_RANDGAMMA",
"randvar_attr_name : FSA_RANDMEAN",
"randvar_attr_name : FSA_RANDMIN",
"randvar_attr_name : FSA_RANDROUND",
"randvar_attr_tsp : FSS_TYPE",
"randvar_attr_tsp : FSS_SRC",
"randvar_attr_tsp : FSS_SEED",
"randvar_attr_tsp : FSS_GAMMA",
"randvar_attr_tsp : FSS_MEAN",
"randvar_attr_tsp : FSS_MIN",
"randvar_attr_tsp : FSS_ROUND",
"randvar_attr_param : FSS_SEED",
"randvar_attr_param : FSS_GAMMA",
"randvar_attr_param : FSS_MEAN",
"randvar_attr_param : FSS_MIN",
"randvar_attr_param : FSS_ROUND",
"randvar_attr_typop : randtype_name",
"randtype_name : FSV_RANDUNI",
"randtype_name : FSV_RANDTAB",
"randtype_name : FSA_RANDGAMMA",
"randvar_attr_srcop : randsrc_name",
"randsrc_name : FSV_URAND",
"randsrc_name : FSV_RAND48",
"attrs_define_thread : FSA_PROCESS",
"attrs_define_thread : FSA_NAME",
"attrs_define_thread : FSA_MEMSIZE",
"attrs_define_thread : FSA_USEISM",
"attrs_define_thread : FSA_INSTANCES",
"attrs_flowop : FSA_WSS",
"attrs_flowop : FSA_FILE",
"attrs_flowop : FSA_POSSET",
"attrs_flowop : FSA_NAME",
"attrs_flowop : FSA_RANDOM",
"attrs_flowop : FSA_FD",
"attrs_flowop : FSA_SRCFD",
"attrs_flowop : FSA_ROTATEFD",
"attrs_flowop : FSA_DSYNC",
"attrs_flowop : FSA_DIRECTIO",
"attrs_flowop : FSA_INDEXED",
"attrs_flowop : FSA_TARGET",
"attrs_flowop : FSA_ITERS",
"attrs_flowop : FSA_VALUE",
"attrs_flowop : FSA_BLOCKING",
"attrs_flowop : FSA_HIGHWATER",
"attrs_flowop : FSA_IOSIZE",
"attrs_flowop : FSA_NOREADAHEAD",
"attrs_eventgen : FSA_RATE",
"em_attr_name : FSA_MASTER",
"em_attr_name : FSA_CLIENT",
"fscheck_attr_name : FSA_PATH",
"fscheck_attr_name : FSA_FSTYPE",
"comp_attr_ops : comp_attr_op",
"comp_attr_ops : comp_attr_ops FSK_SEPLST comp_attr_op",
"comp_attr_ops : comp_attr_ops FSK_SEPLST comp_lvar_def",
"comp_attr_op : attrs_define_comp FSK_ASSIGN attr_value",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSV_VAL_BOOLEAN",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSV_VAL_INT",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSK_QUOTE FSV_WHITESTRING FSK_QUOTE",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSV_STRING",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSV_VARIABLE",
"comp_lvar_def : FSV_VARIABLE",
"attrs_define_comp : FSA_NAME",
"attrs_define_comp : FSA_ITERS",
"attr_value : FSV_STRING",
"attr_value : FSV_VAL_INT",
"attr_value : FSV_VAL_BOOLEAN",
"attr_value : FSV_VARIABLE",
"attr_value : FSV_VAL_DBL",
"attr_list_value : var_string_list",
"attr_list_value : FSV_STRING",
"attr_list_value : FSV_VAL_INT",
"attr_list_value : FSV_VAL_BOOLEAN",
"attr_list_value : FSV_VARIABLE",
"var_int_val : FSV_VAL_INT",
"var_int_val : FSV_VARIABLE",

};
#endif
/* define the initial stack-sizes */
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH  YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH  500
#endif
#endif

#define YYINITSTACKSIZE 500

int      yydebug;
int      yynerrs;

typedef struct {
    unsigned stacksize;
    short    *s_base;
    short    *s_mark;
    short    *s_last;
    YYSTYPE  *l_base;
    YYSTYPE  *l_mark;
} YYSTACKDATA;
int      yyerrflag;
int      yychar;
YYSTYPE  yyval;
YYSTYPE  yylval;

/* variables for the parser stack */
static YYSTACKDATA yystack;
#line 1917 "parser_gram.y"

/*
 *  The following 'c' routines implement the various commands defined in the
 * above yacc parser code. The yacc portion checks the syntax of the commands
 * found in a workload file, or typed on interactive command lines, parsing
 * the commands' parameters into lists. The lists are then passed in a cmd_t
 * struct for each command to its related routine in the following section
 * for actual execution. This section also includes a few utility routines
 * and the main entry point for the program.
 */

/*
 * Entry point for filebench. Processes command line arguements. The -f
 * option will read in a workload file (the full name and extension must
 * must be given). The -a, -s, -m and -i options are used by worker process
 * to receive their name, the base address of shared memory, its path, and
 * the process' instance number, respectively. This information is supplied
 * by the master process when it execs worker processes under the process
 * model of execution. If the worker process arguments are passed then main
 * will call the procflow_exec routine which creates worker threadflows and
 * flowops and executes the procflow's portion of the workload model until
 * completion. If worker process arguments are not passed to the process,
 * then it becomes the master process for a filebench run. It initializes
 * the various filebench components and either executes the supplied workload
 * file, or enters interactive mode.
 */

int
main(int argc, char *argv[])
{
	int opt;
	int instance;
	char procname[128];
#if defined(_LP64) || (__WORDSIZE == 64)
	unsigned long long shmaddr;
#else
	unsigned int shmaddr;
#endif
	char dir[MAXPATHLEN];
#ifdef HAVE_SETRLIMIT
	struct rlimit rlp;
#endif
#ifdef HAVE_LIBTECLA
	char *line;
#else
	char line[1024];
#endif
	char shmpathtmp[1024];

#ifdef HAVE_PROC_SYS_KERNEL_SHMMAX
	/* Increase the maximum shared memory segment size till
	 * some large value. We save old value to restore it later.
	 * XXX: however we do not restore it now: to many places
	 * where we need to restore it on error paths.
	 */

	FILE *f;
	int ret;
	unsigned long long oldshmmax;

	f = fopen("/proc/sys/kernel/shmmax", "r+");
	if (!f) {
		filebench_log(LOG_ERROR, "Coud not open "
				"/proc/sys/kernel/shmmax file!");
		exit(1);
	}

	/* saving the old value */
	ret = fscanf(f, "%llu", &oldshmmax);

	/* writing new value */
#define SOME_LARGE_SHMAX "268435456" /* 256 MB */
	ret = fwrite(SOME_LARGE_SHMAX, sizeof(SOME_LARGE_SHMAX), 1, f);
	if (ret != 1) {
		filebench_log(LOG_ERROR, "Coud not write to "
				"/proc/sys/kernel/shmmax file!");
		exit(1);
	}
#undef SOME_LARGE_SHMAX
#endif

#ifdef HAVE_SETRLIMIT
	/* Increase the limit of opened files.
	 *
	 * We first set the limit to the hardlimit reported by the kernel; this
	 * call will always succeed.  Then we try to set the limit to some
	 * large number of files (unfortunately we can't set this ulimit to
	 * infinity), this will only succeed if the process is ran by root.
	 * Therefore, we set the maximum possible value for the limit for this
	 * given process (well, only if hardlimit is greater then the large
	 * number of files defined by us, it is not true).
	 *
	 * Increasing this limit is especially important when we use thread
	 * model, because opened files are accounted per-process, not
	 * per-thread.
	 */
	(void) getrlimit(RLIMIT_NOFILE, &rlp);
	rlp.rlim_cur = rlp.rlim_max;
	(void) setrlimit(RLIMIT_NOFILE, &rlp);
#define SOME_LARGE_NUMBER_OF_FILES 50000
	rlp.rlim_cur = rlp.rlim_max = SOME_LARGE_NUMBER_OF_FILES;
#undef SOME_LARGE_NUMBER_OF_FILES
	(void) setrlimit(RLIMIT_NOFILE, &rlp);
#endif

	yydebug = 0;
	execname = argv[0];
	*procname = 0;
	cwd = getcwd(dir, MAXPATHLEN);

	while ((opt = getopt(argc, argv, cmd_options)) != (int)EOF) {

		switch (opt) {
		case 'h':
			usage(2);
			break;

		case 'p':
			noproc = 1;
			break;

		case 'f':
			if (optarg == NULL)
				usage(1);
			if ((yyin = fopen(optarg, "r")) == NULL) {
				(void) fprintf(stderr,
				    "Cannot open file %s", optarg);
				exit(1);
			}
			dofile = FS_TRUE;
			fscriptname = optarg;

			break;

		case 'a':
			if (optarg == NULL)
				usage(1);
			sscanf(optarg, "%s", &procname[0]);
			break;

		case 's':
			if (optarg == NULL)
				usage(1);
#if defined(_LP64) || (__WORDSIZE == 64)
			sscanf(optarg, "%llx", &shmaddr);
#else
			sscanf(optarg, "%x", &shmaddr);
#endif
			break;

		case 'm':
			if (optarg == NULL)
				usage(1);
			sscanf(optarg, "%s", shmpathtmp);
			shmpath = shmpathtmp;
			break;

		case 'i':
			if (optarg == NULL)
				usage(1);
			sscanf(optarg, "%d", &instance);
			break;

		case '?':
		default:
			usage(1);
			break;
		}
	}

#ifdef USE_PROCESS_MODEL
	if (!(*procname))
#endif
	printf("FileBench Version %s\n", FILEBENCH_VERSION);
	filebench_init();

	/* get process pid for use with message logging */
	my_pid = getpid();

#ifdef USE_PROCESS_MODEL
	if (*procname) {
		/* A child FileBench instance */
		if (ipc_attach((char *)shmaddr) < 0) {
			filebench_log(LOG_ERROR, "Cannot attach shm for %s",
			    procname);
			exit(1);
		}

		/* get correct function pointer for each child process */
		filebench_plugin_funcvecinit();

		if (procflow_exec(procname, instance) < 0) {
			filebench_log(LOG_ERROR, "Cannot startup process %s",
			    procname);
			exit(1);
		}

		exit(0);
	}
#endif

	/* master (or only) process */
	ipc_init();

	if (fscriptname)
		(void) strcpy(filebench_shm->shm_fscriptname, fscriptname);

	filebench_plugin_funcvecinit();
	flowop_init();
	stats_init();
	eventgen_init();

	signal(SIGINT, parser_abort);

	if (dofile)
		yyparse();
	else {
#ifdef HAVE_LIBTECLA
		if ((gl = new_GetLine(MAX_LINE_LEN, MAX_CMD_HIST)) == NULL) {
			filebench_log(LOG_ERROR,
			    "Failed to create GetLine object");
			filebench_shutdown(1);
		}

		if (gl_customize_completion(gl, NULL, command_complete)) {
			filebench_log(LOG_ERROR,
			    "Failed to register auto-completion function");
			filebench_shutdown(1);
		}

		while ((line = gl_get_line(gl, FILEBENCH_PROMPT, NULL, -1))) {
			arg_parse(line);
			yyparse();
		}

		del_GetLine(gl);
#else
		while (!feof(stdin)) {
			printf(FILEBENCH_PROMPT);
			fflush(stdout);
			if (fgets(line, sizeof (line), stdin) == NULL) {
				if (errno == EINTR)
					continue;
				else
					break;
			}
			arg_parse(line);
			yyparse();
		}
		printf("\n");
#endif	/* HAVE_LIBTECLA */
	}

	parser_filebench_shutdown((cmd_t *)0);

	return (0);
}

/*
 * arg_parse() puts the parser into command parsing mode. Create a tmpfile
 * and instruct the parser to read instructions from this location by setting
 * yyin to the value returned by tmpfile. Write the command into the file.
 * Then seek back to to the start of the file so that the parser can read
 * the instructions.
 */
static void
arg_parse(const char *command)
{
	if ((yyin = tmpfile()) == NULL) {
		filebench_log(LOG_FATAL,
		    "Exiting: Cannot create tmpfile: %s", strerror(errno));
		exit(1);
	}

	if (fwrite(command, strlen(command), 1, yyin) != 1)
		filebench_log(LOG_FATAL,
		    "Cannot write tmpfile: %s", strerror(errno));

	if (fseek(yyin, 0, SEEK_SET) != 0)
		filebench_log(LOG_FATAL,
		    "Cannot seek tmpfile: %s", strerror(errno));
}

/*
 * Converts a list of var_strings or ordinary strings to a single ordinary
 * string. It returns a pointer to the string (in malloc'd memory) if found,
 * or NULL otherwise.
 */
char *
parser_list2string(list_t *list)
{
	list_t *l;
	char *string;
	char *tmp;
	if ((string = malloc(MAXPATHLEN)) == NULL) {
		filebench_log(LOG_ERROR, "Failed to allocate memory");
		return (NULL);
	}

	*string = 0;

	/*	printf("parser_list2string: called\n"); */
	/* Format args */
	for (l = list; l != NULL; l = l->list_next) {
		char *lstr = avd_get_str(l->list_string);

		filebench_log(LOG_DEBUG_SCRIPT,
		    "converting string '%s'", lstr);

		/* see if it is a random variable */
		if (l->list_integer) {
			fbint_t param_name;

			tmp = NULL;
			param_name = avd_get_int(l->list_integer);
			switch (param_name) {
			case FSS_TYPE:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_TYPE);
				break;

			case FSS_SRC:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_SRC);
				break;

			case FSS_SEED:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_SEED);
				break;

			case FSS_MIN:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_MIN);
				break;

			case FSS_MEAN:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_MEAN);
				break;

			case FSS_GAMMA:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_GAMMA);
				break;

			case FSS_ROUND:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_ROUND);
				break;
			}

			if (tmp) {
				(void) strcat(string, tmp);
				free(tmp);
			} else {
				(void) strcat(string, lstr);
			}
		} else {
			/* perhaps a normal variable? */
			if ((tmp = var_to_string(lstr)) != NULL) {
				(void) strcat(string, tmp);
				free(tmp);
			} else {
				(void) strcat(string, lstr);
			}
		}
	}
	return (string);
}

/*
 * If the list just contains a single string starting with '$', then find
 * or create the named var and return the var's var_string component.
 * Otherwise, convert the list to a string, and allocate a var_string
 * containing a copy of that string. On failure either returns NULL
 * or shuts down the run.
 */
avd_t
parser_list2varstring(list_t *list)
{
	char *lstr = avd_get_str(list->list_string);

	/*	printf("parser_list2varstring: Called\n"); */
	/* Special case - variable name */
	if ((list->list_next == NULL) && (*lstr == '$'))
		return (var_ref_attr(lstr));

	return (avd_str_alloc(parser_list2string(list)));
}

/*
 * Looks for the var named in list_string of the first element of the
 * supplied list. If found, returns the var_val portion of the var in
 * an attribute value descriptor. If the var is not found, cannot be
 * allocated, the supplied list is NULL, or the list_string filed is
 * empty, returns NULL.
 */
avd_t
parser_list2avd(list_t *list)
{
	avd_t avd;
	char *lstr;

	if (list && ((lstr = avd_get_str(list->list_string)) != NULL)) {
		avd = var_ref_attr(lstr);
		return (avd);
	}

	return (NULL);
}

/*
 * Sets the event generator rate from the attribute supplied with the
 * command. If the attribute doesn't exist the routine does nothing.
 */
static void
parser_eventgen(cmd_t *cmd)
{
	attr_t *attr;

	/* Get the rate from attribute */
	if ((attr = get_attr_integer(cmd, FSA_RATE))) {
		if (attr->attr_avd) {
			eventgen_setrate(attr->attr_avd);
		}
	}
}

/*
 * Assigns the designated integer variable successive values from the
 * supplied comma seperated integer list. After each successive integer
 * assignment, it executes the bracket enclosed list of commands. For
 * example, repeated runs of a workload with increasing io sizes can
 * be done using the following command line:
 * 	foreach $iosize in 2k, 4k, 8k {run 60}
 */
static void
parser_foreach_integer(cmd_t *cmd)
{
	list_t *list = cmd->cmd_param_list;
	cmd_t *inner_cmd;

	for (; list != NULL; list = list->list_next) {
		fbint_t list_int = avd_get_int(list->list_integer);

		var_assign_integer(cmd->cmd_tgt1, list_int);
		filebench_log(LOG_VERBOSE, "Iterating %s=%llu",
		    cmd->cmd_tgt1, (u_longlong_t)list_int);
		for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
		    inner_cmd = inner_cmd->cmd_next) {
			inner_cmd->cmd(inner_cmd);
		}
	}
}

/*
 * Similar to parser_foreach_integer(), except takes a list of strings after
 * the "in" token. For example, to run twice using a different directory,
 * perhaps using a different filesystem, the following command line
 * could be used:
 * 	foreach $dir in "/ufs_top/fbt", "/zfs_top/fbt" {run 60)
 */
static void
parser_foreach_string(cmd_t *cmd)
{
	list_t *list = cmd->cmd_param_list;

	for (; list != NULL; list = list->list_next) {
		cmd_t *inner_cmd;
		char *lstr = avd_get_str(list->list_string);
		var_assign_string(cmd->cmd_tgt1, lstr);
		filebench_log(LOG_VERBOSE, "Iterating %s=%s",
		    cmd->cmd_tgt1, lstr);
		for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
		    inner_cmd = inner_cmd->cmd_next) {
			inner_cmd->cmd(inner_cmd);
		}
	}
}

/*
 * Lists the fileset name, path name and average size for all defined
 * filesets.
 */
static void
parser_list(cmd_t *cmd)
{
	(void) fileset_iter(fileset_print);
}

/*
 * Lists the flowop name and instance number for all flowops.
 */
static void
parser_flowop_list(cmd_t *cmd)
{
	flowop_printall();
}

/*
 * Calls procflow_define() to allocate "instances" number of  procflow(s)
 * (processes) with the supplied name. The default number of instances is
 * one. An optional priority level attribute can be supplied and is stored in
 * pf_nice. Finally the routine loops through the list of inner commands, if
 * any, which are defines for threadflows, and passes them one at a time to
 * parser_thread_define() to allocate threadflow entities for the process(es).
 */
static void
parser_proc_define(cmd_t *cmd)
{
	procflow_t *procflow;
	char *name = NULL;
	attr_t *attr;
	avd_t var_instances;
	fbint_t instances;
	cmd_t *inner_cmd;

	/* Get the name of the process */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define proc: proc specifies no name");
		filebench_shutdown(1);
	}

	/* Get the memory size from attribute */
	if ((attr = get_attr_integer(cmd, FSA_INSTANCES))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "proc_define: Instances attr cannot be random");
			filebench_shutdown(1);
		}
		var_instances = attr->attr_avd;
		instances = avd_get_int(var_instances);
		filebench_log(LOG_DEBUG_IMPL,
		    "Setting instances = %llu", (u_longlong_t)instances);
	} else {
		filebench_log(LOG_DEBUG_IMPL,
		    "Defaulting to instances = 1");
		var_instances = avd_int_alloc(1);
		instances = 1;
	}

	if ((procflow = procflow_define(name, NULL, var_instances)) == NULL) {
		filebench_log(LOG_ERROR,
		    "Failed to instantiate %d %s process(es)\n",
		    instances, name);
		filebench_shutdown(1);
	}

	/* Get the pri from attribute */
	if ((attr = get_attr_integer(cmd, FSA_NICE))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "proc_define: priority cannot be random");
			filebench_shutdown(1);
		}
		filebench_log(LOG_DEBUG_IMPL, "Setting pri = %llu",
		    (u_longlong_t)avd_get_int(attr->attr_avd));
		procflow->pf_nice = attr->attr_avd;
	} else
		procflow->pf_nice = avd_int_alloc(0);


	/* Create the list of threads for this process  */
	for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
	    inner_cmd = inner_cmd->cmd_next) {
		parser_thread_define(inner_cmd, procflow, instances);
	}
}

/*
 * Calls threadflow_define() to allocate "instances" number of  threadflow(s)
 * (threads) with the supplied name. The default number of instances is
 * one. Two other optional attributes may be supplied, one to set the memory
 * size, stored in tf_memsize, and to select the use of Interprocess Shared
 * Memory, which sets the THREADFLOW_USEISM flag in tf_attrs. Finally
 * the routine loops through the list of inner commands, if any, which are
 * defines for flowops, and passes them one at a time to
 * parser_flowop_define() to allocate flowop entities for the threadflows.
 */
static void
parser_thread_define(cmd_t *cmd, procflow_t *procflow, int procinstances)
{
	threadflow_t *threadflow, template;
	attr_t *attr;
	avd_t instances;
	cmd_t *inner_cmd;
	char *name = NULL;

	memset(&template, 0, sizeof (threadflow_t));

	/* Get the name of the thread */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define thread: thread in process %s specifies no name",
		    procflow->pf_name);
		filebench_shutdown(1);
	}

	/* Get the number of instances from attribute */
	if ((attr = get_attr_integer(cmd, FSA_INSTANCES))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "define thread: Instances attr cannot be random");
			filebench_shutdown(1);
		}
		filebench_log(LOG_DEBUG_IMPL,
		    "define thread: Setting instances = %llu",
		    (u_longlong_t)avd_get_int(attr->attr_avd));
		instances = attr->attr_avd;
	} else
		instances = avd_int_alloc(1);

	/* Get the memory size from attribute */
	if ((attr = get_attr_integer(cmd, FSA_MEMSIZE))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "define thread: Memory size cannot be random");
			filebench_shutdown(1);
		}
		filebench_log(LOG_DEBUG_IMPL,
		    "define thread: Setting memsize = %llu",
		    (u_longlong_t)avd_get_int(attr->attr_avd));
		template.tf_memsize = attr->attr_avd;
	} else
		template.tf_memsize = avd_int_alloc(0);

	if ((threadflow = threadflow_define(procflow, name,
	    &template, instances)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define thread: Failed to instantiate thread\n");
		filebench_shutdown(1);
	}

	/* Use ISM Memory? */
	if ((attr = get_attr(cmd, FSA_USEISM))) {
		threadflow->tf_attrs |= THREADFLOW_USEISM;
	}

	/* Create the list of flowops */
	for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
	    inner_cmd = inner_cmd->cmd_next) {
		parser_flowop_define(inner_cmd, threadflow,
		    &threadflow->tf_thrd_fops, FLOW_MASTER);
	}
}

/*
 * Fills in the attributes for a newly allocated flowop
 */
static void
parser_flowop_get_attrs(cmd_t *cmd, flowop_t *flowop)
{
	attr_t *attr;

	/* Get the filename from attribute */
	if ((attr = get_attr(cmd, FSA_FILE))) {
		flowop->fo_filename = attr->attr_avd;
		if (flowop->fo_filename == NULL) {
			filebench_log(LOG_ERROR,
			    "define flowop: no filename specfied");
			filebench_shutdown(1);
		}
	} else {
		/* no filename attribute specified */
		flowop->fo_filename = NULL;
	}

#ifdef CONFIG_ENTROPY_DATA_EXPERIMENTAL
	if ((attr = get_attr_fileset(cmd, FSA_DSRC))) {
		flowop->fo_datasource = attr->attr_avd;
		if(flowop->fo_datasource == NULL) {
		   filebench_log(LOG_ERROR,"define flowop: no datasource specified");
		   filebench_shutdown(1);
		}
	} else {
		flowop->fo_datasource = NULL;
	}
#endif

	/* Get the possetname from attribute */
	if ((attr = get_attr(cmd, FSA_POSSET))) {
		flowop->fo_possetname = attr->attr_avd;
		if (flowop->fo_possetname == NULL) {
			filebench_log(LOG_ERROR,
			    "parser_flowop_get_attrs: no "
				"posset name specfied");
			filebench_shutdown(1);
		}
	} else {
		/* no possetname attribute specified */
		flowop->fo_possetname = NULL;
	}

	/* Get the iosize of the op */
	if ((attr = get_attr_integer(cmd, FSA_IOSIZE)))
		flowop->fo_iosize = attr->attr_avd;
	else
		flowop->fo_iosize = avd_int_alloc(0);

	/* Get the working set size of the op */
	if ((attr = get_attr_integer(cmd, FSA_WSS)))
		flowop->fo_wss = attr->attr_avd;
	else
		flowop->fo_wss = avd_int_alloc(0);

	/* Random I/O? */
	if ((attr = get_attr_bool(cmd, FSA_RANDOM)))
		flowop->fo_random = attr->attr_avd;
	else
		flowop->fo_random = avd_bool_alloc(FALSE);

	/* Sync I/O? */
	if ((attr = get_attr_bool(cmd, FSA_DSYNC)))
		flowop->fo_dsync = attr->attr_avd;
	else
		flowop->fo_dsync = avd_bool_alloc(FALSE);

	/* Target, for wakeup etc */
	if ((attr = get_attr(cmd, FSA_TARGET)))
		(void) strcpy(flowop->fo_targetname,
		    avd_get_str(attr->attr_avd));

	/* Value */
	if ((attr = get_attr_integer(cmd, FSA_VALUE)))
		flowop->fo_value = attr->attr_avd;
	else
		flowop->fo_value = avd_int_alloc(0);

	/* FD */
	if ((attr = get_attr_integer(cmd, FSA_FD))) {
		flowop->fo_fdnumber = avd_get_int(attr->attr_avd);
		if (flowop->fo_filename != NULL)
			filebench_log(LOG_DEBUG_SCRIPT, "It is not "
			    "advisable to supply both an fd number "
			    "and a fileset name in most cases");
	}

	/* Rotatefd? */
	if ((attr = get_attr_bool(cmd, FSA_ROTATEFD)))
		flowop->fo_rotatefd = attr->attr_avd;
	else
		flowop->fo_rotatefd = avd_bool_alloc(FALSE);

	/* SRC FD, for copies etc... */
	if ((attr = get_attr_integer(cmd, FSA_SRCFD)))
		flowop->fo_srcfdnumber = avd_get_int(attr->attr_avd);

	/* Blocking operation? */
	if ((attr = get_attr_bool(cmd, FSA_BLOCKING)))
		flowop->fo_blocking = attr->attr_avd;
	else
		flowop->fo_blocking = avd_bool_alloc(FALSE);

	/* Direct I/O Operation */
	if ((attr = get_attr_bool(cmd, FSA_DIRECTIO)))
		flowop->fo_directio = attr->attr_avd;
	else
		flowop->fo_directio = avd_bool_alloc(FALSE);

	/* Highwater mark */
	if ((attr = get_attr_integer(cmd, FSA_HIGHWATER))) {
		flowop->fo_highwater = attr->attr_avd;
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "define flowop: Highwater attr cannot be random");
			filebench_shutdown(1);
		}
	} else {
		flowop->fo_highwater = avd_int_alloc(1);
	}

	/* find file or leaf directory by index number */
	if ((attr = get_attr_integer(cmd, FSA_INDEXED)))
		flowop->fo_fileindex = attr->attr_avd;
	else
		flowop->fo_fileindex = NULL;

	/* Read Ahead Diable */
	if ((attr = get_attr_bool(cmd, FSA_NOREADAHEAD)))
		flowop->fo_noreadahead = attr->attr_avd;
	else
		flowop->fo_noreadahead = avd_bool_alloc(FALSE);


}

/*
 * defines the FLOW_MASTER flowops within a FLOW_MASTER instance of
 * a composit flowop. Default attributes from the FLOW_INNER_DEF instances
 * of the composit flowop's inner flowops are used if set. Otherwise
 * default attributes from the FLOW_MASTER instance of the composit flowop
 * are used, which may include defaults from the original FLOW_DEFINITION
 * of the composit flowop.
 */
static void
parser_inner_flowop_define(threadflow_t *thread, flowop_t *comp0_flow,
			   flowop_t *comp_mstr_flow)
{
	flowop_t *inner_flowtype, *inner_flowop;

	/* follow flowop list, creating composit names */
	inner_flowtype = comp0_flow->fo_comp_fops;
	comp_mstr_flow->fo_comp_fops = NULL;

	while (inner_flowtype) {
		char fullname[MAXPATHLEN];

		/* create composite_name.name for new flowop */
		snprintf(fullname, MAXPATHLEN, "%s.%s",
		    comp_mstr_flow->fo_name, inner_flowtype->fo_name);

		if ((inner_flowop = flowop_define(thread, fullname,
		    inner_flowtype, &comp_mstr_flow->fo_comp_fops,
		    FLOW_MASTER, 0)) == NULL) {
			filebench_log(LOG_ERROR,
			    "define flowop: Failed to instantiate flowop %s\n",
			    fullname);
			filebench_shutdown(1);
		}

		/* if applicable, update filename attribute */
		if (inner_flowop->fo_filename) {
			char *name;

			/* fix up avd_t */
			avd_update(&inner_flowop->fo_filename,
			    comp_mstr_flow->fo_lvar_list);

			/* see if ready to get the file or fileset */
			name = avd_get_str(inner_flowop->fo_filename);
			if (name) {

				inner_flowop->fo_fileset = fileset_find(name);

				if (inner_flowop->fo_fileset == NULL) {
					filebench_log(LOG_ERROR,
					    "inr flowop %s: file %s not found",
					    inner_flowop->fo_name, name);
					filebench_shutdown(1);
				}
			}
		}

		/* update attributes from local variables */
		avd_update(&inner_flowop->fo_iters,
		    comp_mstr_flow->fo_lvar_list);

		/* if the inner flowop is a composit flowop, recurse */
		if (inner_flowtype->fo_type == FLOW_TYPE_COMPOSITE) {
			var_t *newlvar, *proto_lvars, *lvar_ptr;

			proto_lvars = inner_flowop->fo_lvar_list;
			inner_flowop->fo_lvar_list = 0;

			for (lvar_ptr = inner_flowtype->fo_lvar_list; lvar_ptr;
			    lvar_ptr = lvar_ptr->var_next) {

				if ((newlvar = var_lvar_alloc_local(
				    lvar_ptr->var_name)) != NULL) {

					add_lvar_to_list(newlvar,
					    &inner_flowop->fo_lvar_list);

					var_update_comp_lvars(newlvar,
					    proto_lvars,
					    comp_mstr_flow->fo_lvar_list);
				}
			}
		  
			parser_inner_flowop_define(thread,
			    inner_flowtype,
			    inner_flowop);

			inner_flowtype = inner_flowtype->fo_exec_next;
			continue;
		}

		avd_update(&inner_flowop->fo_iosize,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_wss,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_iters,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_value,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_random,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_dsync,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_rotatefd,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_blocking,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_directio,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_highwater,
		    comp_mstr_flow->fo_lvar_list);

		inner_flowtype = inner_flowtype->fo_exec_next;
	}
}

/*
 * Calls flowop_define() to allocate a flowop with the supplied name.
 * The allocated flowop inherits attributes from a base flowop of the
 * same type.  If the new flowop has a file or fileset attribute specified,
 * it must specify a defined fileobj or fileset or an error will be logged.
 * The new flowop may  also have the following attributes set by
 * the program:
 *  - file size (fo_iosize)
 *  - working set size (fo_wss)
 *  - do random io (fo_random)
 *  - do synchronous io (fo_dsync)
 *  - perform each operation multiple times before advancing (fo_iter)
 *  - target name (fo_targetname)
 *  - An integer value (fo_value)
 *  - a file descriptor (fo_fd)
 *  - specify to rotate file descriptors (fo_rotatefd)
 *  - a source fd (fo_srcfdnumber)
 *  - specify a blocking operation (fo_blocking)
 *  - specify a highwater mark (fo_highwater)
 *
 * After all the supplied attributes are stored in their respective locations
 * in the flowop object, the flowop's init function is called. No errors are
 * returned, but the filebench run will be terminated if the flowtype is not
 * specified, a name for the new flowop is not supplied, the flowop_define
 * call fails, or a file or fileset name is supplied but the corresponding
 * fileobj or fileset cannot be located.
 */
static void
parser_flowop_define(cmd_t *cmd, threadflow_t *thread,
    flowop_t **flowoplist_hdp, int category)
{
	flowop_t *flowop, *flowop_type;
	char *type = (char *)cmd->cmd_name;
	char *name = NULL;
	attr_t *attr;

	/* Get the inherited flowop */
	flowop_type = flowop_find(type);
	if (flowop_type == NULL) {
		filebench_log(LOG_ERROR,
		    "define flowop: flowop type %s not found",
		    type);
		filebench_shutdown(1);
	}

	/* Get the name of the flowop */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define flowop: flowop %s specifies no name",
		    flowop_type->fo_name);
		filebench_shutdown(1);
	}

	if ((flowop = flowop_define(thread, name,
	    flowop_type, flowoplist_hdp, category, 0)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define flowop: Failed to instantiate flowop %s\n",
		    cmd->cmd_name);
		filebench_shutdown(1);
	}

	/* Iterations */
	if ((attr = get_attr_integer(cmd, FSA_ITERS)))
		flowop->fo_iters = attr->attr_avd;
	else
		flowop->fo_iters = avd_int_alloc(1);


	/* if this is a use of a composit flowop, create inner FLOW MASTERS */
	if (flowop_type->fo_type == FLOW_TYPE_COMPOSITE) {
		get_attr_lvars(cmd, flowop);
		if (category == FLOW_MASTER)
			parser_inner_flowop_define(thread,
			    flowop_type, flowop);
	}
	else {
		parser_flowop_get_attrs(cmd, flowop);
	}
}

static void
parser_composite_flowop_define(cmd_t *cmd)
{
	flowop_t *flowop;
	cmd_t *inner_cmd;
	char *name = NULL;
	attr_t *attr;

	/* Get the name of the flowop */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define flowop: Composit flowop specifies no name");

		filebench_shutdown(1);
	}

	if ((flowop = flowop_new_composite_define(name)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define flowop: Failed to instantiate flowop %s\n",
		    cmd->cmd_name);
		filebench_shutdown(1);
	}

	/* place any local var_t variables on the flowop's local list */
	get_attr_lvars(cmd, flowop);

	/* Iterations */
	if ((attr = get_attr_integer(cmd, FSA_ITERS)))
		flowop->fo_iters = attr->attr_avd;
	else
		flowop->fo_iters = avd_int_alloc(1);

	/* define inner flowops */
	for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
	    inner_cmd = inner_cmd->cmd_next) {
		parser_flowop_define(inner_cmd, NULL,
		    &flowop->fo_comp_fops, FLOW_INNER_DEF);
	}
}

/*static void
source_file_define(cmd_t *cmd)
{
	attr_t *attr;
	if((attr = get_attr_fileset(cmd,FSA_DSRC)))
	{
		printf("\nfound attr:");
	}
}*/
/*
 * Calls fileset_define() to allocate a fileset with the supplied name and
 * initializes the fileset's pathname attribute, and optionally the
 * fileset_cached, fileset_reuse, fileset_prealloc and fileset_size attributes.
 *
 */
static fileset_t *
parser_fileset_define_common(cmd_t *cmd)
{
	fileset_t *fileset;
	avd_t name;
	attr_t *attr;
	avd_t pathname;

	/*
	 * Make sure all plugin flowops are initialized.
	 * Defaults to local fs for now
	 */
	flowop_plugin_flowinit();

	/* Get the name of the file */
	printf("about to chk for FSA_DSRC\n");

	if ((attr = get_attr_fileset(cmd, FSA_NAME))) {
		name = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR,
		    "define fileset: file or fileset specifies no name");
		return (NULL);
	}

	if ((fileset = fileset_define(name)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define file: failed to instantiate file %s\n",
		    avd_get_str(name));
		return (NULL);
	}

	/* Get the pathname from attribute */
	if ((attr = get_attr(cmd, FSA_PATH)) == NULL) {
		filebench_log(LOG_ERROR, "define file: no pathname specified");
		return (NULL);
	}

	/* Expand variables in pathname */
	if ((pathname = parser_list2varstring(attr->attr_param_list))
	    == NULL) {
		filebench_log(LOG_ERROR, "Cannot interpret path");
		return (NULL);
	}

	fileset->fs_path = pathname;

	/* How much should we preallocate? */
	if ((attr = get_attr_integer(cmd, FSA_PREALLOC)) &&
	    attr->attr_avd) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "define fileset: Prealloc attr cannot be random");
			filebench_shutdown(1);
		}
		fileset->fs_preallocpercent = attr->attr_avd;
	} else if (attr && !attr->attr_avd) {
		fileset->fs_preallocpercent = avd_int_alloc(100);
	} else {
		fileset->fs_preallocpercent = avd_int_alloc(0);
	}

	/* Should we preallocate? */
	if ((attr = get_attr_bool(cmd, FSA_PREALLOC)))
		fileset->fs_prealloc = attr->attr_avd;
	else
		fileset->fs_prealloc = avd_bool_alloc(FALSE);

	/* Should we prealloc in parallel? */
	if ((attr = get_attr_bool(cmd, FSA_PARALLOC)))
		fileset->fs_paralloc = attr->attr_avd;
	else
		fileset->fs_paralloc = avd_bool_alloc(FALSE);

	/* Should we allow writes to the file? */
	if ((attr = get_attr_bool(cmd, FSA_READONLY)))
		fileset->fs_readonly = attr->attr_avd;
	else
		fileset->fs_readonly = avd_bool_alloc(FALSE);

	/* Should we reuse the existing file? */
	if ((attr = get_attr_bool(cmd, FSA_REUSE)))
		fileset->fs_reuse = attr->attr_avd;
	else
		fileset->fs_reuse = avd_bool_alloc(FALSE);

	/* Should we check for files actual existance? */
	if ((attr = get_attr_bool(cmd, FSA_TRUSTTREE)))
		fileset->fs_trust_tree = attr->attr_avd;
	else
		fileset->fs_trust_tree = avd_bool_alloc(FALSE);

	/* Should we leave in cache? */
	if ((attr = get_attr_bool(cmd, FSA_CACHED)))
		fileset->fs_cached = attr->attr_avd;
	else
		fileset->fs_cached = avd_bool_alloc(FALSE);

	/* Get the mean or absolute size of the file */
	if ((attr = get_attr_integer(cmd, FSA_SIZE)))
		fileset->fs_size = attr->attr_avd;
	else
		fileset->fs_size = avd_int_alloc(0);

	return (fileset);
}

/*
 * Calls parser_fileset_define_common() to allocate a fileset with
 * one entry and optionally the fileset_prealloc. sets the fileset_entries,
 * fileset_dirwidth, fileset_dirgamma, and fileset_sizegamma attributes
 * to appropriate values for emulating the old "fileobj" entity
 */
static void
parser_file_define(cmd_t *cmd)
{
	fileset_t *fileset;

	if ((fileset = parser_fileset_define_common(cmd)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define file: failed to instantiate file");
		filebench_shutdown(1);
		return;
	}

	/* fileset is emulating a single file */
	fileset->fs_attrs = FILESET_IS_FILE;

	/* Set the size of the fileset to 1 */
	fileset->fs_entries = avd_int_alloc(1);

	/* Set the mean dir width to more than 1 */
	fileset->fs_dirwidth = avd_int_alloc(10);

	/* Set the dir and size gammas to 0 */
	fileset->fs_dirgamma = avd_int_alloc(0);
	fileset->fs_sizegamma = avd_int_alloc(0);
}

/*
 * Calls parser_fileset_define_common() to allocate a fileset with the
 * supplied name and initializes the fileset's fileset_preallocpercent,
 * fileset_prealloc, fileset_entries, fileset_dirwidth, fileset_dirgamma,
 * and fileset_sizegamma attributes.
 */
static void
parser_fileset_define(cmd_t *cmd)
{
	fileset_t *fileset;
	attr_t *attr;

	if ((fileset = parser_fileset_define_common(cmd)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define fileset: failed to instantiate fileset");
		filebench_shutdown(1);
		return;
	}
	/* Get the number of files in the fileset */
	if ((attr = get_attr_integer(cmd, FSA_ENTRIES))) {
		fileset->fs_entries = attr->attr_avd;
	} else {
		fileset->fs_entries = avd_int_alloc(0);
	}

	/* Get the number of leafdirs in the fileset */
	if ((attr = get_attr_integer(cmd, FSA_LEAFDIRS))) {
		fileset->fs_leafdirs = attr->attr_avd;
	} else {
		fileset->fs_leafdirs = avd_int_alloc(0);
	}

	if ((avd_get_int(fileset->fs_entries) == 0) &&
	    (avd_get_int(fileset->fs_leafdirs) == 0)) {
		filebench_log(LOG_ERROR, "Fileset has no files or leafdirs");
	}

	/* Get the mean dir width of the fileset */
	if ((attr = get_attr_integer(cmd, FSA_DIRWIDTH))) {
		fileset->fs_dirwidth = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR, "Fileset has zero directory width");
		fileset->fs_dirwidth = avd_int_alloc(0);
	}

	/* Get the random variable for dir depth, if supplied */
	if ((attr = get_attr_integer(cmd, FSA_DIRDEPTHRV))) {
		if (!AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "Define fileset: dirdepthrv must be random var");
			filebench_shutdown(1);
		}
		fileset->fs_dirdepthrv = attr->attr_avd;
	} else {
		fileset->fs_dirdepthrv = NULL;
	}

	/* Get the gamma value for dir depth distributions */
	if ((attr = get_attr_integer(cmd, FSA_DIRGAMMA))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "Define fileset: dirgamma attr cannot be random");
			filebench_shutdown(1);
		}
		fileset->fs_dirgamma = attr->attr_avd;
	} else
		fileset->fs_dirgamma = avd_int_alloc(1500);

	/* Get the gamma value for dir width distributions */
	if ((attr = get_attr_integer(cmd, FSA_FILESIZEGAMMA))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "Define fileset: filesizegamma cannot be random");
			filebench_shutdown(1);
		}
		fileset->fs_sizegamma = attr->attr_avd;
	} else
		fileset->fs_sizegamma = avd_int_alloc(1500);
	/* Get the Data Source parameters if present */
	printf("about to chk for FSA_DSRC\n");
	if ((attr = get_attr_fileset(cmd, FSA_DSRC)))
	{
		fileset->fs_datasource = attr;
		printf("\npH print found=%d\n",attr->attr_name);
		printf("\npH attr value = %c\n",avd_get_str(attr->attr_avd)[0]);
		printf("\n type : %d",(int)attr->sub_attr_list->attr_avd->avd_type);
		printf("\npH src param list =%d->%d->%d\n",attr->attr_name,attr->sub_attr_list->attr_name,1);//,attr->sub_attr_list->attr_next->attr_name);
		printf("\npH src param list =%lf->%c\n",avd_get_dbl(attr->sub_attr_list->attr_avd),'c');//,avd_get_str(attr->sub_attr_list->attr_next)[0]);
	}
	else
		fileset->fs_datasource=NULL;
}

static void
parser_posset_define(cmd_t *cmd)
{
	attr_t *attr;
	avd_t name;
	avd_t type;
	avd_t seed;
	avd_t max;
	avd_t entries;
	int i;

	struct posset *ps;
	
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR,
		   "parser_posset_define: no name specified for the posset");
		filebench_shutdown(1);
		return;
	}

	if ((attr = get_attr(cmd, FSA_TYPE))) {
		type = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR,
		   "parser_posset_define: no type specified for the posset");
		filebench_shutdown(1);
		return;
	}

	if ((attr = get_attr_integer(cmd, FSA_ENTRIES))) {
		entries = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR,
		   "parser_posset_define: no entries number "
					"specified for the posset");
		filebench_shutdown(1);
		return;
	}

	/*
	 * two attributes below are mandatory only for specific types
	 * of possets, so postpone their validation for posset type
	 * specific functions.
	 */
	if ((attr = get_attr_integer(cmd, FSA_RANDSEED)))
		seed = attr->attr_avd;
	else
		seed = avd_int_alloc(0);

	if ((attr = get_attr_integer(cmd, FSA_RANDMAX)))
		max = attr->attr_avd;
	else
		max = avd_int_alloc(0);

	filebench_log(LOG_INFO,"Defining position set: %s type: %s",
				 avd_get_str(name), avd_get_str(type));

	ps = posset_alloc(name, type, seed, max, entries);
	if (!ps) {
		filebench_log(LOG_ERROR, "Cannot define fileset");
		filebench_shutdown(1);
		/* NOT REACHABLE */
		return;
	}

	/* printing all positions */
	for (i = 0; i < avd_get_int(ps->ps_entries); i++)
		filebench_log(LOG_INFO,"pos %d: %llu", i, ps->ps_positions[i]);

}

/*
 * Creates and starts all defined procflow processes. The call to
 * procflow_init() results in creation of the requested number of
 * process instances for each previously defined procflow. The
 * child processes exec() a new instance of filebench, passing it
 * the instance number and address of the shared memory region.
 * The child processes will then create their threads and flowops.
 * The routine then unlocks the run_lock to allow all the processes'
 * threads to start and  waits for all of them to begin execution.
 * Finally, it records the start time and resets the event generation
 * system.
 */
static void
parser_proc_create(cmd_t *cmd)
{
	filebench_shm->shm_1st_err = 0;
	filebench_shm->shm_f_abort = FILEBENCH_OK;

	if (procflow_init() != 0) {
		filebench_log(LOG_ERROR, "Failed to create processes\n");
		filebench_shutdown(1);
	}

	/* Release the read lock, allowing threads to start */
	(void) pthread_rwlock_unlock(&filebench_shm->shm_run_lock);

	/* Wait for all threads to start */
	if (procflow_allstarted() != 0) {
		filebench_log(LOG_ERROR, "Could not start run");
		return;
	}


	if (filebench_shm->shm_required &&
	    (ipc_ismcreate(filebench_shm->shm_required) < 0)) {
		filebench_log(LOG_ERROR, "Could not allocate shared memory");
		return;
	}

	filebench_shm->shm_starttime = gethrtime();
	eventgen_reset();
}

/*
 * Calls fileset_createset() to populate all files and filesets and
 * create all associated, initially existant,  files and subdirectories.
 * If errors are encountered, calls filebench_shutdown()
 * to exit filebench.
 */
static void
parser_fileset_create(cmd_t *cmd)
{
	if (!filecreate_done) {
		filecreate_done = 1;

		/* initialize the random number system first */
		randdist_init();

		/* create all the filesets */
		if (fileset_createset(NULL) != 0) {
			filebench_log(LOG_ERROR, "Failed to create filesets");
			filebench_shutdown(1);
		}
	} else {
		filebench_log(LOG_INFO,
		    "Attempting to create fileset more than once, ignoring");
	}

}

/*
 * Deletes the files and directories that represent files and filesets on the
 * storage medium.
 */
static void
parser_fileset_shutdown(cmd_t *cmd)
{
	filebench_log(LOG_INFO, "Shutting down filesets");
	fileset_delete_all_filesets();
}

/*
 * Shuts down all processes and their associated threads. When finished
 * it deletes interprocess shared memory and resets the event generator.
 * It does not exit the filebench program though.
 */
static void
parser_proc_shutdown(cmd_t *cmd)
{
	filebench_log(LOG_INFO, "Shutting down processes");
	filecreate_done = 0;
	procflow_shutdown();
	if (filebench_shm->shm_required)
		ipc_ismdelete();
	eventgen_reset();
}

/*
 * Ends filebench run after first destoring any interprocess
 * shared memory. The call to filebench_shutdown()
 * also causes filebench to exit.
 */
static void
parser_filebench_shutdown(cmd_t *cmd)
{
	int f_abort = filebench_shm->shm_f_abort;

	ipc_fini();

	if (f_abort == FILEBENCH_ABORT_ERROR)
		filebench_shutdown(1);
	else
		filebench_shutdown(0);
}

/*
 * This is Used for timing runs.Pauses the master thread in one second
 * intervals until the supplied ptime runs out or the f_abort flag
 * is raised. If given a time of zero or less, or the mode is stop on
 * lack of resources, it will pause until f_abort is raised.
 */
static int
parser_pause(int ptime)
{
	int timeslept = 0;

	if ((filebench_shm->shm_rmode == FILEBENCH_MODE_TIMEOUT) &&
	    (ptime > 0)) {
		while (timeslept < ptime) {
			(void) sleep(1);
			timeslept++;
			if (filebench_shm->shm_f_abort)
				break;
		}
	} else {
		/* initial runtime of 0 means run till abort */
		/* CONSTCOND */
		while (1) {
			(void) sleep(1);
			timeslept++;
			if (filebench_shm->shm_f_abort)
				break;
		}
	}
	return (timeslept);
}

/*
 * Do a file bench run. Calls routines to create file sets, files, and
 * processes. It resets the statistics counters, then sleeps for the runtime
 * passed as an argument to it on the command line in 1 second increments.
 * When it is finished sleeping, it collects a snapshot of the statistics
 * and ends the run.
 */
static void
parser_run(cmd_t *cmd)
{
	int runtime;
	int timeslept;

	runtime = cmd->cmd_qty;

	parser_fileset_create(cmd);
	parser_proc_create(cmd);

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	filebench_log(LOG_INFO, "Running...");
	stats_clear();

	timeslept = parser_pause(runtime);

	filebench_log(LOG_INFO, "Run took %d seconds...", timeslept);
	parser_statssnap(cmd);
	parser_proc_shutdown(cmd);
}

/*
 * Similar to parser_run, but gets the sleep time from a variable
 * whose name is supplied as an argument to the command.
 */
static void
parser_run_variable(cmd_t *cmd)
{
	avd_t integer = var_ref_attr(cmd->cmd_tgt1);
	int runtime;
	int timeslept;

	if (integer == NULL) {
		filebench_log(LOG_ERROR, "Unknown variable %s",
		cmd->cmd_tgt1);
		return;
	}

	runtime = avd_get_int(integer);

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	filebench_log(LOG_INFO, "Running...");
	stats_clear();

	timeslept = parser_pause(runtime);

	filebench_log(LOG_INFO, "Run took %d seconds...", timeslept);
	parser_statssnap(cmd);
	parser_proc_shutdown(cmd);
}

char *usagestr = NULL;

/*
 * Prints usage string if defined, else just a message requesting load of a
 * personality.
 */
static void
parser_help(cmd_t *cmd)
{
	if (usagestr) {
		filebench_log(LOG_INFO, "%s", usagestr);
	} else {
		filebench_log(LOG_INFO,
		    "load <personality> (ls "
		    "%s/workloads for list)", fbbasepath);
	}
}

char *varstr = NULL;

/*
 * Prints the string of all var definitions, if there is one.
 */
static void
parser_printvars(cmd_t *cmd)
{
	char *str, *c;

	if (varstr) {
		str = strdup(varstr);
		for (c = str; *c != '\0'; c++) {
			if ((char)*c == '$')
				*c = ' ';
		}
		filebench_log(LOG_INFO, "%s", str);
		free(str);
	}
}

/*
 * Establishes multi-client synchronization socket with synch server.
 */
static void
parser_enable_mc(cmd_t *cmd)
{
	attr_t *attr;
	char *master;
	char *client;

	if ((attr= get_attr(cmd, FSA_MASTER))) {
		master = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "enable multi: no master specified");
		return;
	}

	if ((attr= get_attr(cmd, FSA_CLIENT))) {
		client = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "enable multi: no client specified");
		return;
	}

	mc_sync_open_sock(master, 8001, client);
}

/*
 * Exchanges multi-client synchronization message with synch server.
 */
static void
parser_domultisync(cmd_t *cmd)
{
	attr_t *attr;
	fbint_t value;

	if ((attr = get_attr(cmd, FSA_VALUE)))
		value = avd_get_int(attr->attr_avd);
	else
		value = 1;

	mc_sync_synchronize((int)value);
}

/*
 * Used by the SET command to add a var and default value string to the
 * varstr string. It allocates a new, larger varstr string, copies the
 * old contents of varstr into it, then adds the new var string on the end.
 */
static void
parser_vars(cmd_t *cmd)
{
	char *string = cmd->cmd_tgt1;
	char *newvars;

	if (string == NULL)
		return;

	if (dofile)
		return;

	if (varstr == NULL) {
		newvars = malloc(strlen(string) + 2);
		*newvars = 0;
	} else {
		newvars = malloc(strlen(varstr) + strlen(string) + 2);
		(void) strcpy(newvars, varstr);
	}
	(void) strcat(newvars, string);
	(void) strcat(newvars, " ");

	if (varstr)
		free(varstr);

	varstr = newvars;
}

/*
 * used by the set command to set the integer part of a regular
 * variable, or the appropriate field of a random variable
 */
static void
parser_set_integer(cmd_t *cmd)
{
	var_assign_integer(cmd->cmd_tgt1, cmd->cmd_qty);
}

/*
 * used by the set command to set the integer part of a regular
 * variable from another variable, or the appropriate field of a
 * random variable from another variable
 */
static void
parser_set_var(cmd_t *cmd)
{
	var_assign_var(cmd->cmd_tgt1, cmd->cmd_tgt2);
}

/*
 * Used by the set command to set up for a binary operation of a
 * variable from a var, with an integer
 */
static void
parser_set_var_op_int(cmd_t *cmd)
{
	printf("parser_set_var_op_int: Called\n");
	switch (cmd->cmd_subtype) {
	case FSK_PLUS:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_SUM_IV,
		    cmd->cmd_tgt2, cmd->cmd_qty);
		break;

	case FSK_MINUS:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_IV_DIF_INT,
		    cmd->cmd_tgt2, cmd->cmd_qty);
		break;

	case FSK_MULTIPLY:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_MUL_IV,
		    cmd->cmd_tgt2, cmd->cmd_qty);
		break;

	case FSK_DIVIDE:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_IV_DIV_INT,
		    cmd->cmd_tgt2, cmd->cmd_qty);
		break;
	}
}

/*
 * Used by the set command to set up for a binary operation of an
 * integer with a variable from a var
 */
static void
parser_set_int_op_var(cmd_t *cmd)
{
	switch (cmd->cmd_subtype) {
	case FSK_PLUS:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_SUM_IV,
		    cmd->cmd_tgt3, cmd->cmd_qty);
		break;

	case FSK_MINUS:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_DIF_IV,
		    cmd->cmd_tgt3, cmd->cmd_qty);
		break;

	case FSK_MULTIPLY:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_MUL_IV,
		    cmd->cmd_tgt3, cmd->cmd_qty);
		break;

	case FSK_DIVIDE:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_DIV_IV,
		    cmd->cmd_tgt3, cmd->cmd_qty);
		break;
	}
}

/*
 * Used by the set command to set up for a binary operation of two
 * variables from other vars.
 */
static void
parser_set_var_op_var(cmd_t *cmd)
{
	switch (cmd->cmd_subtype) {
	case FSK_PLUS:
		var_assign_op_var_var(cmd->cmd_tgt1, VAR_IND_IV_SUM_IV,
		    cmd->cmd_tgt2, cmd->cmd_tgt3);
		break;

	case FSK_MINUS:
		var_assign_op_var_var(cmd->cmd_tgt1, VAR_IND_IV_DIF_IV,
		    cmd->cmd_tgt2, cmd->cmd_tgt3);
		break;

	case FSK_MULTIPLY:
		var_assign_op_var_var(cmd->cmd_tgt1, VAR_IND_IV_MUL_IV,
		    cmd->cmd_tgt2, cmd->cmd_tgt3);
		break;

	case FSK_DIVIDE:
		var_assign_op_var_var(cmd->cmd_tgt1, VAR_IND_IV_DIV_IV,
		    cmd->cmd_tgt2, cmd->cmd_tgt3);
		break;
	}
}


/*
 * Sleeps for cmd->cmd_qty seconds, one second at a time.
 */
static void
parser_warmup(cmd_t *cmd)
{
	int sleeptime;

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	sleeptime = cmd->cmd_qty;
	filebench_log(LOG_INFO, "Warming up...");

	(void) parser_pause(sleeptime);
}

/*
 * Same as parser_sleep, except the sleep time is obtained from a variable
 * whose name is passed to it as an argument on the command line.
 */
static void
parser_warmup_variable(cmd_t *cmd)
{
	avd_t integer = var_ref_attr(cmd->cmd_tgt1);
	int sleeptime;

	if (integer == NULL) {
		filebench_log(LOG_ERROR, "Unknown variable %s",
		cmd->cmd_tgt1);
		return;
	}

	sleeptime = avd_get_int(integer);

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	filebench_log(LOG_INFO, "Warming up...");

	(void) parser_pause(sleeptime);
}

/*
 * Sleeps for cmd->cmd_qty seconds, one second at a time.
 */
static void
parser_sleep(cmd_t *cmd)
{
	int sleeptime;
	int timeslept;

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	sleeptime = cmd->cmd_qty;
	filebench_log(LOG_INFO, "Running...");

	timeslept = parser_pause(sleeptime);

	filebench_log(LOG_INFO, "Run took %d seconds...", timeslept);
}

/*
 * Same as parser_sleep, except the sleep time is obtained from a variable
 * whose name is passed to it as an argument on the command line.
 */
static void
parser_sleep_variable(cmd_t *cmd)
{
	avd_t integer = var_ref_attr(cmd->cmd_tgt1);
	int sleeptime;
	int timeslept;

	if (integer == NULL) {
		filebench_log(LOG_ERROR, "Unknown variable %s",
		cmd->cmd_tgt1);
		return;
	}

	sleeptime = avd_get_int(integer);

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	filebench_log(LOG_INFO, "Running...");

	timeslept = parser_pause(sleeptime);

	filebench_log(LOG_INFO, "Run took %d seconds...", timeslept);
}

/*
 * Parser log prints the values of a list of variables to the log file.
 * The list of variables is placed on the command line, separated
 * by comas and the entire list is enclosed in quotes.
 * For example, if $dir contains "/export/home/tmp" and $filesize = 1048576,
 * then typing: log "$dir, $filesize" prints: log /export/home/tmp, 1048576
 */
static void
parser_log(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE, "log %s", string);
	filebench_log(LOG_LOG, "%s", string);
}

/*
 * Implements the stats directory command. changes the directory for
 * dumping statistics to supplied directory path. For example:
 * 	stats directory /tmp
 * changes the stats directory to "/tmp".
 */
static void
parser_directory(cmd_t *cmd)
{
	char newdir[MAXPATHLEN];
	char *dir;
	int ret;

	if ((dir = parser_list2string(cmd->cmd_param_list)) == NULL) {
		filebench_log(LOG_ERROR, "Cannot interpret directory");
		return;
	}

	*newdir = 0;
	/* Change dir relative to cwd if path not fully qualified */
	if (*dir != '/') {
		(void) strcat(newdir, cwd);
		(void) strcat(newdir, "/");
	}
	(void) strcat(newdir, dir);
	(void) mkdir(newdir, 0755);
	filebench_log(LOG_VERBOSE, "Change dir to %s", newdir);
	ret = chdir(newdir);
	free(dir);
}

#define	PIPE_PARENT 1
#define	PIPE_CHILD  0

/*
 * Runs the quoted unix command as a background process. Intended for
 * running statistics gathering utilities such as mpstat while the filebench
 * workload is running. Also records the pid's of the background processes
 * so that parser_statssnap() can terminate them when the run completes.
 */
static void
parser_statscmd(cmd_t *cmd)
{
	char *string;
	pid_t pid;
	pidlist_t *pidlistent;
	int pipe_fd[2];
	int newstdout;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	if ((pipe(pipe_fd)) < 0) {
		filebench_log(LOG_ERROR, "statscmd pipe failed");
		return;
	}

#ifdef HAVE_FORK1
	if ((pid = fork1()) < 0) {
		filebench_log(LOG_ERROR, "statscmd fork failed");
		return;
	}
#elif HAVE_FORK
	if ((pid = fork()) < 0) {
		filebench_log(LOG_ERROR, "statscmd fork failed");
		return;
	}
#else
	Crash! - Need code to deal with no fork1!
#endif /* HAVE_FORK1 */

	if (pid == 0) {

		setsid();

		filebench_log(LOG_VERBOSE,
		    "Backgrounding %s", string);
		/*
		 * Child
		 * - close stdout
		 * - dup to create new stdout
		 * - close pipe fds
		 */
		(void) close(1);

		if ((newstdout = dup(pipe_fd[PIPE_CHILD])) < 0) {
			filebench_log(LOG_ERROR,
			    "statscmd dup failed: %s",
			    strerror(errno));
		}

		(void) close(pipe_fd[PIPE_PARENT]);
		(void) close(pipe_fd[PIPE_CHILD]);

		if (system(string) < 0) {
			filebench_log(LOG_ERROR,
			    "statscmd exec failed: %s",
			    strerror(errno));
		}
		/* Failed! */
		exit(1);

	} else {

		/* Record pid in pidlist for subsequent reaping by stats snap */
		if ((pidlistent = (pidlist_t *)malloc(sizeof (pidlist_t)))
		    == NULL) {
			filebench_log(LOG_ERROR, "pidlistent malloc failed");
			return;
		}

		pidlistent->pl_pid = pid;
		pidlistent->pl_fd = pipe_fd[PIPE_PARENT];
		(void) close(pipe_fd[PIPE_CHILD]);

		/* Add fileobj to global list */
		if (pidlist == NULL) {
			pidlist = pidlistent;
			pidlistent->pl_next = NULL;
		} else {
			pidlistent->pl_next = pidlist;
			pidlist = pidlistent;
		}
	}
}

/*
 * Launches a shell to run the unix command supplied in the argument.
 * The command should be enclosed in quotes, as in:
 * 	system "rm xyz"
 * which would run the "rm" utility to delete the file "xyz".
 */
static void
parser_system(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE,
	    "Running '%s'", string);

	if (system(string) < 0) {
		filebench_log(LOG_ERROR,
		    "system exec failed: %s",
		    strerror(errno));
		filebench_shutdown(1);
	}
	free(string);
}

/*
 * Echos string supplied with command to the log.
 */
static void
parser_echo(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_INFO, "%s", string);
}

static void parser_fscheck(cmd_t *cmd) {
	return;
}

#if 0
/* XXX: do not support this command for now */
/*
 * Checks to see if the specified data directory exists and it's mounted file
 * system is the correct type.
 */
static void
parser_fscheck(cmd_t *cmd)
{
	int fstype_idx;
	char *pathname = NULL;
	char *filesys = "tmpfs";
	char string[MAXPATHLEN];
	struct statvfs64 statbuf;
	attr_t *attr;

	if (cmd->cmd_attr_list == NULL)
		return;

	for (attr = cmd->cmd_attr_list; attr; attr = attr->attr_next) {

		switch(attr->attr_name) {
		case FSA_PATH:
			pathname = avd_get_str(attr->attr_avd);
			break;
		case FSA_FSTYPE:
			filesys = avd_get_str(attr->attr_avd);
			break;
		}
	}

	if (pathname == NULL)
		return;

	if (statvfs64(pathname, &statbuf) < 0) {
		filebench_log(LOG_ERROR,
		    "%s error with supplied data path name: %s; exiting",
		    strerror(errno), pathname);
		filebench_shutdown(1);
		return;
	}

	if (strncmp(filesys, statbuf.f_basetype, FSTYPSZ) != 0) {
		filebench_log(LOG_ERROR,
		    "File System is of type %s, NOT %s as indicated",
		    statbuf.f_basetype, filesys);
		filebench_shutdown(1);
		return;
	}
}
#endif

/*
 * Checks to see if any filesets need to have their caches flushed, and
 * if so invokes the fs_flush script.
 */
static void
parser_fsflush(cmd_t *cmd)
{
	fileset_t *fileset;
	char **fspathlist;
	char *pathname = NULL;
	char *filesys = NULL;
	char string[MAXPATHLEN];
	attr_t *attr;
	int fsidx;

	if ((attr = cmd->cmd_attr_list) == NULL)
		return;

	/* Get supplied file system type */
	if (attr->attr_name == FSA_FSTYPE)
		filesys = avd_get_str(attr->attr_avd);

	if (filesys == NULL) {
		filebench_log(LOG_ERROR,
		    "FSFLUSH command lacks file system type");
		return;
	}

	/* Check all filesets for any that remain cached and count them*/
	fsidx = 0;
	for (fileset = filebench_shm->shm_filesetlist; fileset != NULL;
	     fileset = fileset->fs_next) {

		if (avd_get_bool(fileset->fs_cached))
			return;

		fsidx++;
	}

	/* allocated space for fileset path pointers */
	fspathlist = (char **)malloc(fsidx * sizeof(char *));

	/* If flushing still required, flush all filesets */
	fsidx = 0;
	for (fileset = filebench_shm->shm_filesetlist; fileset != NULL;
	     fileset = fileset->fs_next) {
		int idx;

		if ((pathname = avd_get_str(fileset->fs_path)) == NULL)
			return;

		for (idx = 0; idx < fsidx; idx++) {
			if (strcmp(pathname, fspathlist[idx]) == 0)
				break;
		}

		if (fsidx == idx) {

			/* found a new path */
			fspathlist[fsidx++] = pathname;

			/* now flush it */
			snprintf(string, MAXPATHLEN,
			    "%s/scripts/fs_flush %s %s", fbbasepath,
			    filesys, pathname);

			if (system(string) < 0) {
				filebench_log(LOG_ERROR,
				    "exec of fs_flush script failed: %s",
				    strerror(errno));
				filebench_shutdown(1);
			}
		}
	}
}

/*
 * Prints out the version of FileBench.
 */
static void
parser_version(cmd_t *cmd)
{
	filebench_log(LOG_INFO, "FileBench Version: %s", FILEBENCH_VERSION);
}

/*
 * Sets osprof_enabled option
 */
static void
parser_osprof_enable(cmd_t *cmd)
{
	osprof_enabled = 1;
	filebench_log(LOG_INFO, "OSprof enabled");
}

/*
 * Resets osprof_enabled option
 */
static void
parser_osprof_disable(cmd_t *cmd)
{
	osprof_enabled = 0;
	filebench_log(LOG_INFO, "OSprof disabled");
}

/*
 * Adds the string supplied as the argument to the usage command
 * to the end of the string printed by the help command.
 */
static void
parser_usage(cmd_t *cmd)
{
	char *string;
	char *newusage;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	if (dofile)
		return;

	if (usagestr == NULL) {
		newusage = malloc(strlen(string) + 2);
		*newusage = 0;
	} else {
		newusage = malloc(strlen(usagestr) + strlen(string) + 2);
		(void) strcpy(newusage, usagestr);
	}
	(void) strcat(newusage, "\n");
	(void) strcat(newusage, string);

	if (usagestr)
		free(usagestr);

	usagestr = newusage;

	filebench_log(LOG_INFO, "%s", string);
}

/*
 * Updates the global dump filename with the filename supplied
 * as the command's argument. Then dumps the statistics of each
 * worker flowop into the dump file, followed by a summary of
 * overall totals.
 */
static void
parser_statsdump(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE,
	    "Stats dump to file '%s'", string);

	stats_dump(string);

	free(string);
}

/*
 * Same as statsdump, but outputs in a computer friendly format.
 */
static void
parser_statsmultidump(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE,
	    "Stats dump to file '%s'", string);

	stats_multidump(string);

	free(string);
}

/*
 * Same as parser_statsdump, but in xml format.
 */
static void
parser_statsxmldump(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE,
	    "Stats dump to file '%s'", string);

	stats_xmldump(string);

	free(string);
}

/*
 * Kills off background statistics collection processes, then takes a snapshot
 * of the filebench run's collected statistics using stats_snap() from
 * stats.c.
 */
static void
parser_statssnap(cmd_t *cmd)
{
	pidlist_t *pidlistent;
	int stat;
	pid_t pid;

	for (pidlistent = pidlist; pidlistent != NULL;
	    pidlistent = pidlistent->pl_next) {
		filebench_log(LOG_VERBOSE, "Killing session %d for pid %d",
		    getsid(pidlistent->pl_pid),
		    pidlistent->pl_pid);
		if (pidlistent->pl_fd)
			(void) close(pidlistent->pl_fd);
#ifdef HAVE_SIGSEND
		sigsend(P_SID, getsid(pidlistent->pl_pid), SIGTERM);
#else
		(void) kill(-1, SIGTERM);
#endif

		/* Close pipe */
		if (pidlistent->pl_fd)
			(void) close(pidlistent->pl_fd);

		/* Wait for cmd and all its children */
		while ((pid = waitpid(pidlistent->pl_pid * -1, &stat, 0)) > 0)
			filebench_log(LOG_DEBUG_IMPL,
			"Waited for pid %d", (int)pid);
	}

	for (pidlistent = pidlist; pidlistent != NULL;
	    pidlistent = pidlistent->pl_next) {
		free(pidlistent);
	}

	pidlist = NULL;
	stats_snap();
}

/*
 * Shutdown filebench.
 */
static void
parser_abort(int arg)
{
	(void) sigignore(SIGINT);
	filebench_log(LOG_INFO, "Aborting...");
	filebench_shutdown(1);
}

/*
 * define a random variable and initialize the distribution parameters
 */
static void
parser_randvar_define(cmd_t *cmd)
{
	var_t		*var;
	randdist_t	*rndp;
	attr_t		*attr;
	char		*name;

	/* Get the name for the random variable */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define randvar: no name specified");
		return;
	}

	if ((var = var_define_randvar(name)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define randvar: failed for random variable %s",
		    name);
		return;
	}

	rndp = var->var_val.randptr;
	rndp->rnd_type = 0;

	/* Get the source of the random numbers */
	if ((attr = get_attr_integer(cmd, FSA_RANDSRC))) {
		int randsrc = (int)avd_get_int(attr->attr_avd);

		switch (randsrc) {
		case FSV_URAND:
			rndp->rnd_type |= RAND_SRC_URANDOM;
			break;
		case FSV_RAND48:
			rndp->rnd_type |= RAND_SRC_GENERATOR;
			break;
		}
	} else {
		/* default to rand48 random number generator */
		rndp->rnd_type |= RAND_SRC_GENERATOR;
	}

	/* Get the min value of the random distribution */
	if ((attr = get_attr_integer(cmd, FSA_RANDMIN)))
		rndp->rnd_min = attr->attr_avd;
	else
		rndp->rnd_min = avd_int_alloc(0);

	/* Get the roundoff value for the random distribution */
	if ((attr = get_attr_integer(cmd, FSA_RANDROUND)))
		rndp->rnd_round = attr->attr_avd;
	else
		rndp->rnd_round = avd_int_alloc(0);

	/* Get a tablular probablility distribution if there is one */
	if ((attr = get_attr(cmd, FSA_RANDTABLE))) {
		rndp->rnd_probtabs = (probtabent_t *)(attr->attr_obj);
		rndp->rnd_type |= RAND_TYPE_TABLE;

		/* no need for the rest of the attributes */
		return;
	} else {
		rndp->rnd_probtabs = NULL;
	}

	/* Get the type for the random variable */
	if ((attr = get_attr(cmd, FSA_TYPE))) {
		int disttype = (int)avd_get_int(attr->attr_avd);

		switch (disttype) {
		case FSV_RANDUNI:
			rndp->rnd_type |= RAND_TYPE_UNIFORM;
			break;
		case FSA_RANDGAMMA:
			rndp->rnd_type |= RAND_TYPE_GAMMA;
			break;
		case FSV_RANDTAB:
			filebench_log(LOG_ERROR,
			    "Table distribution type without prob table");
			break;
		}
	} else {
		/* default to gamma distribution type */
		rndp->rnd_type |= RAND_TYPE_GAMMA;
	}

	/* Get the seed for the random variable */
	if ((attr = get_attr_integer(cmd, FSA_RANDSEED)))
		rndp->rnd_seed = attr->attr_avd;
	else
		rndp->rnd_seed = avd_int_alloc(0);

	/* Get the gamma value of the random distribution */
	if ((attr = get_attr_integer(cmd, FSA_RANDGAMMA)))
		rndp->rnd_gamma = attr->attr_avd;
	else
		rndp->rnd_gamma = avd_int_alloc(1500);

	/* Get the mean value of the random distribution */
	if ((attr = get_attr_integer(cmd, FSA_RANDMEAN))) {
		rndp->rnd_mean = attr->attr_avd;
	} else if ((rndp->rnd_type & RAND_TYPE_MASK) == RAND_TYPE_GAMMA) {
		rndp->rnd_mean = NULL;
	} else {
		rndp->rnd_mean = avd_int_alloc(0);
	}
}

/*
 * Set a specified random distribution parameter in a random variable.
 */
static void
parser_randvar_set(cmd_t *cmd)
{
	var_t		*randvar;
	randdist_t	*rndp;
	avd_t	value;

	if ((randvar = var_find_randvar(cmd->cmd_tgt1)) == NULL) {
		filebench_log(LOG_ERROR,
		    "set randvar: failed",
		    cmd->cmd_tgt1);
		return;
	}

	rndp = randvar->var_val.randptr;
	value = cmd->cmd_attr_list->attr_avd;

	switch (cmd->cmd_qty) {
	case FSS_TYPE:
		{
			int disttype = (int)avd_get_int(value);

			rndp->rnd_type &= (~RAND_TYPE_MASK);

			switch (disttype) {
			case FSV_RANDUNI:
				rndp->rnd_type |= RAND_TYPE_UNIFORM;
				break;
			case FSA_RANDGAMMA:
				rndp->rnd_type |= RAND_TYPE_GAMMA;
				break;
			case FSV_RANDTAB:
				rndp->rnd_type |= RAND_TYPE_TABLE;
				break;
			}
			break;
		}

	case FSS_SRC:
		{
			int randsrc = (int)avd_get_int(value);

			rndp->rnd_type &=
			    (~(RAND_SRC_URANDOM | RAND_SRC_GENERATOR));

			switch (randsrc) {
			case FSV_URAND:
				rndp->rnd_type |= RAND_SRC_URANDOM;
				break;
			case FSV_RAND48:
				rndp->rnd_type |= RAND_SRC_GENERATOR;
				break;
			}
			break;
		}

	case FSS_SEED:
		rndp->rnd_seed = value;
		break;

	case FSS_GAMMA:
		rndp->rnd_gamma = value;
		break;

	case FSS_MEAN:
		rndp->rnd_mean = value;
		break;

	case FSS_MIN:
		rndp->rnd_min = value;
		break;

	case FSS_ROUND:
		rndp->rnd_round = value;
		break;

	default:
		filebench_log(LOG_ERROR, "setrandvar: undefined attribute");
	}
}

/*
 * alloc_cmd() allocates the required resources for a cmd_t. On failure, a
 * filebench_log is issued and NULL is returned.
 */
static cmd_t *
alloc_cmd(void)
{
	cmd_t *cmd;

	if ((cmd = malloc(sizeof (cmd_t))) == NULL) {
		filebench_log(LOG_ERROR, "Alloc cmd failed");
		return (NULL);
	}

	(void) memset(cmd, 0, sizeof (cmd_t));

	return (cmd);
}

/*
 * Allocates an attr_t structure and zeros it. Returns NULL on failure, or
 * a pointer to the attr_t.
 */
static attr_t *
alloc_attr(void)
{
	attr_t *attr;

	if ((attr = malloc(sizeof (attr_t))) == NULL) {
		return (NULL);
	}

	(void) memset(attr, 0, sizeof (attr_t));
	return (attr);
}

/*
 * Allocates a probtabent_t structure and zeros it. Returns NULL on failure, or
 * a pointer to the probtabent_t.
 */
static probtabent_t *
alloc_probtabent(void)
{
	probtabent_t *rte;

	if ((rte = malloc(sizeof (probtabent_t))) == NULL) {
		return (NULL);
	}

	(void) memset(rte, 0, sizeof (probtabent_t));
	return (rte);
}

/*
 * Allocates an attr_t structure and puts the supplied var_t into
 * its attr_avd location, and sets its name to FSA_LVAR_ASSIGN
 */
static attr_t *
alloc_lvar_attr(var_t *var)
{
	attr_t *attr;

	if ((attr = alloc_attr()) == NULL)
		return (NULL);

	attr->attr_name = FSA_LVAR_ASSIGN;
	attr->attr_avd = (avd_t)var;

	return (attr);
}


/*
 * Searches the attribute list for the command for the named attribute type.
 * The attribute list is created by the parser from the list of attributes
 * supplied with certain commands, such as the define and flowop commands.
 * Returns a pointer to the attribute structure if the named attribute is
 * found, otherwise returns NULL. If the attribute includes a parameter list,
 * the list is converted to a string and stored in the attr_avd field of
 * the returned attr_t struct.
 */
static attr_t *
get_attr_fileset(cmd_t *cmd, int64_t name)
{
	attr_t *attr;
	attr_t *rtn = NULL;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {
		filebench_log(LOG_DEBUG_IMPL,
		    "attr %d = %d %llx?",
		    attr->attr_name,
		    name,
		    attr->attr_avd);

		if (attr->attr_name == name)
			rtn = attr;
	}

	if (rtn == NULL)
		return (NULL);

	if (rtn->attr_param_list) {
		filebench_log(LOG_DEBUG_SCRIPT, "attr is param list");
		rtn->attr_avd = parser_list2varstring(rtn->attr_param_list);
	}

	return (rtn);
}


/*
 * Searches the attribute list for the command for the named attribute type.
 * The attribute list is created by the parser from the list of attributes
 * supplied with certain commands, such as the define and flowop commands.
 * Returns a pointer to the attribute structure if the named attribute is
 * found, otherwise returns NULL. If the attribute includes a parameter list,
 * the list is converted to a string and stored in the attr_avd field of
 * the returned attr_t struct.
 */
static attr_t *
get_attr(cmd_t *cmd, int64_t name)
{
	attr_t *attr;
	attr_t *rtn = NULL;
	char *string;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {
		filebench_log(LOG_DEBUG_IMPL,
		    "attr %d = %d %llx?",
		    attr->attr_name,
		    name,
		    attr->attr_avd);

		if (attr->attr_name == name)
			rtn = attr;
	}

	if (rtn == NULL)
		return (NULL);

	if (rtn->attr_param_list) {
		filebench_log(LOG_DEBUG_SCRIPT, "attr is param list");
		string = parser_list2string(rtn->attr_param_list);
		if (string != NULL) {
			rtn->attr_avd = avd_str_alloc(string);
			filebench_log(LOG_DEBUG_SCRIPT,
			    "attr string %s", string);
		}
	}

	return (rtn);
}

/*
 * Similar to get_attr, but converts the parameter string supplied with the
 * named attribute to an integer and stores the integer in the attr_avd
 * portion of the returned attr_t struct.
 */
static attr_t *
get_attr_integer(cmd_t *cmd, int64_t name)
{
	attr_t *attr;
	attr_t *rtn = NULL;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {
		if (attr->attr_name == name)
			rtn = attr;
	}

	if (rtn == NULL)
		return (NULL);

	if (rtn->attr_param_list)
		rtn->attr_avd = parser_list2avd(rtn->attr_param_list);

	return (rtn);
}

/*
 * Similar to get_attr, but converts the parameter string supplied with the
 * named attribute to an integer and stores the integer in the attr_avd
 * portion of the returned attr_t struct. If no parameter string is supplied
 * then it defaults to TRUE (1).
 */
static attr_t *
get_attr_bool(cmd_t *cmd, int64_t name)
{
	attr_t *attr;
	attr_t *rtn = NULL;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {
		if (attr->attr_name == name)
			rtn = attr;
	}

	if (rtn == NULL)
		return (NULL);

	if (rtn->attr_param_list) {
		rtn->attr_avd = parser_list2avd(rtn->attr_param_list);

	} else if (rtn->attr_avd == NULL) {
		rtn->attr_avd = avd_bool_alloc(TRUE);
	}

	/* boolean attributes cannot point to random variables */
	if (AVD_IS_RANDOM(rtn->attr_avd)) {
		filebench_log(LOG_ERROR,
		    "define flowop: Boolean attr %s cannot be random", name);
		filebench_shutdown(1);
		return (NULL);
	}

	return (rtn);
}

/*
 * removes the newly allocated local var from the shared local var
 * list, then puts it at the head of the private local var list
 * supplied as the second argument.
 */
static void
add_lvar_to_list(var_t *newlvar, var_t **lvar_list)
{
	var_t *prev;

	/* remove from shared local list, if there */
	if (newlvar == filebench_shm->shm_var_loc_list) {
		/* on top of list, just grap */
		filebench_shm->shm_var_loc_list = newlvar->var_next;
	} else {
		/* find newvar on list and remove */
		for (prev = filebench_shm->shm_var_loc_list; prev;
		    prev = prev->var_next) {
			if (prev->var_next == newlvar)
				prev->var_next = newlvar->var_next;
		}
	}
	newlvar->var_next = NULL;

	/* add to flowop private local list at head */
	newlvar->var_next = *lvar_list;
	*lvar_list = newlvar;
}

/*
 * Searches the attribute list for the command for any allocated local
 * variables. The attribute list is created by the parser from the list of
 * attributes supplied with certain commands, such as the define and flowop
 * commands. Places all found local vars onto the flowop's local variable
 * list. 
 */
static void
get_attr_lvars(cmd_t *cmd, flowop_t *flowop)
{
	attr_t *attr;
	var_t *orig_lvar_list;

	/* save the local var list */
	orig_lvar_list = flowop->fo_lvar_list;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {

		if (attr->attr_name == FSA_LVAR_ASSIGN) {
			var_t *newvar;

			if ((newvar = (var_t *)attr->attr_avd) == NULL)
				continue;

			add_lvar_to_list(newvar, &flowop->fo_lvar_list);
			var_update_comp_lvars(newvar, orig_lvar_list, NULL);
		}
	}
}

/*
 * Allocates memory for a list_t structure, initializes it to zero, and
 * returns a pointer to it. On failure, returns NULL.
 */
static list_t *
alloc_list()
{
	list_t *list;

	if ((list = malloc(sizeof (list_t))) == NULL) {
		return (NULL);
	}

	(void) memset(list, 0, sizeof (list_t));
	return (list);
}


#define	USAGE1	\
"Usage:\n" \
"go_filebench: interpret f script and generate file workload\n" \
"Options:\n" \
"   [-h] Display verbose help\n" \
"   [-p] Disable opening /proc to set uacct to enable truss\n"

#define	PARSER_CMDS \
"create [files|filesets|processes]\n" \
"stats [clear|snap]\n" \
"stats command \"shell command $var1,$var2...\"\n" \
"stats directory <directory>\n" \
"sleep <sleep-value>\n" \
"quit\n\n" \
"Variables:\n" \
"set $var = value\n" \
"    $var   - regular variables\n" \
"    ${var} - internal special variables\n" \
"    $(var) - environment variables\n\n"

#define	PARSER_EXAMPLE \
"Example:\n\n" \
"#!" FILEBENCHDIR "/bin/go_filebench -f\n" \
"\n" \
"define file name=bigfile,path=bigfile,size=1g,prealloc,reuse\n" \
"define process name=randomizer\n" \
"{\n" \
"  thread random-thread procname=randomizer\n"	\
"  {\n" \
"    flowop read name=random-read,filename=bigfile,iosize=16k,random\n" \
"  }\n" \
"}\n" \
"create files\n" \
"create processes\n" \
"stats clear\n" \
"sleep 30\n" \
"stats snap\n"

/*
 * usage() display brief or verbose help for the filebench(1) command.
 */
static void
usage(int help)
{
	if (help >= 1)
		(void) fprintf(stderr, USAGE1);
	if (help >= 2) {

		(void) fprintf(stderr,
		    "\n'f' language definition:\n\n");
		fileset_usage();
		procflow_usage();
		threadflow_usage();
		flowoplib_usage();
		eventgen_usage();
		(void) fprintf(stderr, PARSER_CMDS);
		(void) fprintf(stderr, PARSER_EXAMPLE);
	}
	exit(E_USAGE);
}

int
yywrap()
{
	if (parentscript) {
		yyin = parentscript;
		yy_switchfilescript(yyin);
		parentscript = NULL;
		return (0);
	} else
		return (1);
}
#line 4537 "parser_gram.c"

#if YYDEBUG
#include <stdio.h>		/* needed for printf */
#endif

#include <stdlib.h>	/* needed for malloc, etc */
#include <string.h>	/* needed for memset */

/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack(YYSTACKDATA *data)
{
    int i;
    unsigned newsize;
    short *newss;
    YYSTYPE *newvs;

    if ((newsize = data->stacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;

    i = data->s_mark - data->s_base;
    newss = (data->s_base != 0)
          ? (short *)realloc(data->s_base, newsize * sizeof(*newss))
          : (short *)malloc(newsize * sizeof(*newss));
    if (newss == 0)
        return -1;

    data->s_base = newss;
    data->s_mark = newss + i;

    newvs = (data->l_base != 0)
          ? (YYSTYPE *)realloc(data->l_base, newsize * sizeof(*newvs))
          : (YYSTYPE *)malloc(newsize * sizeof(*newvs));
    if (newvs == 0)
        return -1;

    data->l_base = newvs;
    data->l_mark = newvs + i;

    data->stacksize = newsize;
    data->s_last = data->s_base + newsize - 1;
    return 0;
}

#if YYPURE || defined(YY_NO_LEAKS)
static void yyfreestack(YYSTACKDATA *data)
{
    free(data->s_base);
    free(data->l_base);
    memset(data, 0, sizeof(*data));
}
#else
#define yyfreestack(data) /* nothing */
#endif

#define YYABORT  goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR  goto yyerrlab

int
YYPARSE_DECL()
{
    int yym, yyn, yystate;
#if YYDEBUG
    const char *yys;

    if ((yys = getenv("YYDEBUG")) != 0)
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = YYEMPTY;
    yystate = 0;

#if YYPURE
    memset(&yystack, 0, sizeof(yystack));
#endif

    if (yystack.s_base == NULL && yygrowstack(&yystack)) goto yyoverflow;
    yystack.s_mark = yystack.s_base;
    yystack.l_mark = yystack.l_base;
    yystate = 0;
    *yystack.s_mark = 0;

yyloop:
    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = YYLEX) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack))
        {
            goto yyoverflow;
        }
        yystate = yytable[yyn];
        *++yystack.s_mark = yytable[yyn];
        *++yystack.l_mark = yylval;
        yychar = YYEMPTY;
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;

    yyerror("syntax error");

    goto yyerrlab;

yyerrlab:
    ++yynerrs;

yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yystack.s_mark]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yystack.s_mark, yytable[yyn]);
#endif
                if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack))
                {
                    goto yyoverflow;
                }
                yystate = yytable[yyn];
                *++yystack.s_mark = yytable[yyn];
                *++yystack.l_mark = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yystack.s_mark);
#endif
                if (yystack.s_mark <= yystack.s_base) goto yyabort;
                --yystack.s_mark;
                --yystack.l_mark;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = YYEMPTY;
        goto yyloop;
    }

yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    if (yym)
        yyval = yystack.l_mark[1-yym];
    else
        memset(&yyval, 0, sizeof yyval);
    switch (yyn)
    {
case 1:
#line 268 "parser_gram.y"
	{
	if (yystack.l_mark[0].cmd->cmd != NULL)
		yystack.l_mark[0].cmd->cmd(yystack.l_mark[0].cmd);

	free(yystack.l_mark[0].cmd);
}
break;
case 2:
#line 275 "parser_gram.y"
	{
	if (dofile)
		YYABORT;
}
break;
case 4:
#line 282 "parser_gram.y"
	{
	filebench_log(LOG_DEBUG_IMPL, "inner_command %zx", yystack.l_mark[0].cmd);
	yyval.cmd = yystack.l_mark[0].cmd;
}
break;
case 5:
#line 287 "parser_gram.y"
	{
	cmd_t *list = NULL;
	cmd_t *list_end = NULL;

	/* Find end of list */
	for (list = yystack.l_mark[-1].cmd; list != NULL;
	    list = list->cmd_next)
		list_end = list;

	list_end->cmd_next = yystack.l_mark[0].cmd;

	filebench_log(LOG_DEBUG_IMPL,
	    "inner_commands adding cmd %zx to list %zx", yystack.l_mark[0].cmd, yystack.l_mark[-1].cmd);

	yyval.cmd = yystack.l_mark[-1].cmd;
}
break;
case 37:
#line 338 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	filebench_log(LOG_DEBUG_IMPL, "foreach_command %zx", yyval.cmd);
}
break;
case 38:
#line 344 "parser_gram.y"
	{
	cmd_t *inner_cmd;
	list_t *list;

	yyval.cmd = yystack.l_mark[-6].cmd;
	yyval.cmd->cmd_list = yystack.l_mark[-1].cmd;
	yyval.cmd->cmd_tgt1 = yystack.l_mark[-5].sval;
	yyval.cmd->cmd_param_list = yystack.l_mark[-3].list;
	yyval.cmd->cmd = parser_foreach_integer;

	for (list = yyval.cmd->cmd_param_list; list != NULL;
	    list = list->list_next) {
		for (inner_cmd = yyval.cmd->cmd_list;
		    inner_cmd != NULL;
		    inner_cmd = inner_cmd->cmd_next) {
			filebench_log(LOG_DEBUG_IMPL,
			    "packing foreach: %zx %s=%llu, cmd %zx",
			    yyval.cmd, yyval.cmd->cmd_tgt1,
			    (u_longlong_t)avd_get_int(list->list_integer),
			    inner_cmd);
		}
	}
}
break;
case 39:
#line 367 "parser_gram.y"
	{
	cmd_t *inner_cmd;
	list_t *list;

	yyval.cmd = yystack.l_mark[-6].cmd;
	yyval.cmd->cmd_list = yystack.l_mark[-1].cmd;
	yyval.cmd->cmd_tgt1 = yystack.l_mark[-5].sval;
	yyval.cmd->cmd_param_list = yystack.l_mark[-3].list;
	yyval.cmd->cmd = parser_foreach_string;

	for (list = yyval.cmd->cmd_param_list; list != NULL;
	    list = list->list_next) {
		for (inner_cmd = yyval.cmd->cmd_list;
		    inner_cmd != NULL;
		    inner_cmd = inner_cmd->cmd_next) {
			filebench_log(LOG_DEBUG_IMPL,
			    "packing foreach: %zx %s=%s, cmd %zx",
			    yyval.cmd,
			    yyval.cmd->cmd_tgt1,
			    *list->list_string, inner_cmd);
		}
	}
}
break;
case 40:
#line 392 "parser_gram.y"
	{
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_integer = avd_int_alloc(yystack.l_mark[0].ival);
}
break;
case 41:
#line 399 "parser_gram.y"
	{
	list_t *list = NULL;
	list_t *list_end = NULL;

	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_integer = avd_int_alloc(yystack.l_mark[0].ival);

	/* Find end of list */
	for (list = yystack.l_mark[-2].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yystack.l_mark[-2].list;
}
break;
case 42:
#line 417 "parser_gram.y"
	{
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[-1].sval);
}
break;
case 43:
#line 424 "parser_gram.y"
	{
	list_t *list = NULL;
	list_t *list_end = NULL;

	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[-1].sval);

	/* Find end of list */
	for (list = yystack.l_mark[-4].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yystack.l_mark[-4].list;
}
break;
case 44:
#line 442 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_eventgen;
}
break;
case 45:
#line 448 "parser_gram.y"
	{
	yystack.l_mark[-1].cmd->cmd_attr_list = yystack.l_mark[0].attr;
}
break;
case 46:
#line 453 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yystack.l_mark[0].list;
	yyval.cmd->cmd = parser_system;
}
break;
case 47:
#line 462 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yystack.l_mark[0].list;
	yyval.cmd->cmd = parser_echo;
}
break;
case 48:
#line 471 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_version;
}
break;
case 49:
#line 478 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_osprof_enable;
}
break;
case 50:
#line 485 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_osprof_disable;
}
break;
case 51:
#line 492 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yystack.l_mark[0].list;
	yyval.cmd->cmd = parser_usage;
}
break;
case 52:
#line 501 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd = parser_printvars;
}
break;
case 53:
#line 509 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd = parser_enable_mc;
}
break;
case 54:
#line 516 "parser_gram.y"
	{
	yystack.l_mark[-1].cmd->cmd_attr_list = yystack.l_mark[0].attr;
}
break;
case 55:
#line 521 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd = parser_domultisync;
	yyval.cmd->cmd_attr_list = yystack.l_mark[0].attr;
}
break;
case 56:
#line 530 "parser_gram.y"
	{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;
	yyval.list->list_string = avd_str_alloc(yystack.l_mark[0].sval);
}
break;
case 57:
#line 536 "parser_gram.y"
	{
	list_t *list = NULL;
	list_t *list_end = NULL;

	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[0].sval);

	/* Find end of list */
	for (list = yystack.l_mark[-2].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yystack.l_mark[-2].list;
}
break;
case 58:
#line 554 "parser_gram.y"
	{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[0].sval);
}
break;
case 59:
#line 561 "parser_gram.y"
	{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[0].sval);
}
break;
case 60:
#line 569 "parser_gram.y"
	{
	yyval.list = yystack.l_mark[0].list;
}
break;
case 61:
#line 572 "parser_gram.y"
	{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add string */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[0].sval);

	/* Find end of list */
	for (list = yystack.l_mark[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yystack.l_mark[-1].list;

}
break;
case 62:
#line 590 "parser_gram.y"
	{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[0].sval);

	/* Find end of list */
	for (list = yystack.l_mark[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yystack.l_mark[-1].list;
}
break;
case 63:
#line 607 "parser_gram.y"
	{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add string */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[0].sval);

	/* Find end of list */
	for (list = yystack.l_mark[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yystack.l_mark[-1].list;

}
break;
case 64:
#line 625 "parser_gram.y"
	{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[0].sval);

	/* Find end of list */
	for (list = yystack.l_mark[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yystack.l_mark[-1].list;
}
break;
case 65:
#line 644 "parser_gram.y"
	{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[0].sval);
}
break;
case 66:
#line 651 "parser_gram.y"
	{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[0].sval);
}
break;
case 67:
#line 659 "parser_gram.y"
	{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add string */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[0].sval);

	/* Find end of list */
	for (list = yystack.l_mark[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yystack.l_mark[-1].list;

}
break;
case 68:
#line 677 "parser_gram.y"
	{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[0].sval);

	/* Find end of list */
	for (list = yystack.l_mark[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yystack.l_mark[-1].list;
}
break;
case 69:
#line 694 "parser_gram.y"
	{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[-1].sval);
	yyval.list->list_integer = avd_int_alloc(yystack.l_mark[0].ival);

	/* Find end of list */
	for (list = yystack.l_mark[-2].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yystack.l_mark[-2].list;
}
break;
case 70:
#line 712 "parser_gram.y"
	{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add string */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[0].sval);

	/* Find end of list */
	for (list = yystack.l_mark[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yystack.l_mark[-1].list;

}
break;
case 71:
#line 730 "parser_gram.y"
	{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[0].sval);

	/* Find end of list */
	for (list = yystack.l_mark[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yystack.l_mark[-1].list;
}
break;
case 72:
#line 747 "parser_gram.y"
	{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yystack.l_mark[-1].sval);
	yyval.list->list_integer = avd_int_alloc(yystack.l_mark[0].ival);

	/* Find end of list */
	for (list = yystack.l_mark[-2].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yystack.l_mark[-2].list;
}
break;
case 73:
#line 765 "parser_gram.y"
	{
	yyval.list = yystack.l_mark[-1].list;
}
break;
case 74:
#line 768 "parser_gram.y"
	{
	yyval.list = yystack.l_mark[-1].list;
}
break;
case 75:
#line 773 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_list;
}
break;
case 76:
#line 779 "parser_gram.y"
	{
	yystack.l_mark[-1].cmd->cmd = &parser_flowop_list;
}
break;
case 77:
#line 784 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_fscheck;

	yyval.cmd->cmd_attr_list = yystack.l_mark[0].attr;
}
break;
case 78:
#line 792 "parser_gram.y"
	{
	yystack.l_mark[-1].cmd->cmd_attr_list->attr_next = yystack.l_mark[0].attr;
}
break;
case 79:
#line 797 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_fsflush;

	yyval.cmd->cmd_attr_list = yystack.l_mark[0].attr;
}
break;
case 80:
#line 806 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_log;
	yyval.cmd->cmd_param_list = yystack.l_mark[0].list;
}
break;
case 81:
#line 814 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
	filebench_shm->shm_debug_level = yystack.l_mark[0].ival;
	if (filebench_shm->shm_debug_level > 9)
		yydebug = 1;
}
break;
case 84:
#line 828 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd_tgt1 = yystack.l_mark[-2].sval;
	yyval.cmd->cmd_qty = yystack.l_mark[0].ival;
	if (parentscript) {
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = parser_set_integer;
}
break;
case 85:
#line 838 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	var_assign_var(yystack.l_mark[-2].sval, yystack.l_mark[0].sval);
	yyval.cmd->cmd_tgt1 = yystack.l_mark[-2].sval;
	yyval.cmd->cmd_tgt2 = yystack.l_mark[0].sval;
	if (parentscript) {
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = parser_set_var;
}
break;
case 86:
#line 850 "parser_gram.y"
	{
	if (yystack.l_mark[-2].cmd->cmd == parser_set_integer) {
		switch (yystack.l_mark[-1].ival) {
		case FSK_PLUS:
			var_assign_integer(yystack.l_mark[-2].cmd->cmd_tgt1, yystack.l_mark[-2].cmd->cmd_qty + yystack.l_mark[0].ival);
			break;
		case FSK_MINUS:
			var_assign_integer(yystack.l_mark[-2].cmd->cmd_tgt1, yystack.l_mark[-2].cmd->cmd_qty - yystack.l_mark[0].ival);
			break;
		case FSK_MULTIPLY:
			var_assign_integer(yystack.l_mark[-2].cmd->cmd_tgt1, yystack.l_mark[-2].cmd->cmd_qty * yystack.l_mark[0].ival);
			break;
		case FSK_DIVIDE:
			var_assign_integer(yystack.l_mark[-2].cmd->cmd_tgt1, yystack.l_mark[-2].cmd->cmd_qty / yystack.l_mark[0].ival);
			break;
		}
		yyval.cmd->cmd = NULL;
	} else {
		yystack.l_mark[-2].cmd->cmd_qty = yystack.l_mark[0].ival;
		yystack.l_mark[-2].cmd->cmd_subtype = yystack.l_mark[-1].ival;
		yystack.l_mark[-2].cmd->cmd = parser_set_var_op_int;
	}
}
break;
case 87:
#line 874 "parser_gram.y"
	{
	yystack.l_mark[-2].cmd->cmd_tgt3 = yystack.l_mark[0].sval;
	yystack.l_mark[-2].cmd->cmd_subtype = yystack.l_mark[-1].ival;
	if (yystack.l_mark[-2].cmd->cmd == parser_set_integer) {
		yyval.cmd->cmd = parser_set_int_op_var;
	} else {
		yystack.l_mark[-2].cmd->cmd = parser_set_var_op_var;
	}
}
break;
case 88:
#line 885 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	var_assign_boolean(yystack.l_mark[-2].sval, yystack.l_mark[0].bval);
	if (parentscript) {
		yyval.cmd->cmd_tgt1 = yystack.l_mark[-2].sval;
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = NULL;
}
break;
case 89:
#line 896 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	var_assign_string(yystack.l_mark[-4].sval, yystack.l_mark[-1].sval);
	if (parentscript) {
		yyval.cmd->cmd_tgt1 = yystack.l_mark[-4].sval;
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = NULL;
}
break;
case 90:
#line 906 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	var_assign_string(yystack.l_mark[-2].sval, yystack.l_mark[0].sval);
	if (parentscript) {
		yyval.cmd->cmd_tgt1 = yystack.l_mark[-2].sval;
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = NULL;
}
break;
case 91:
#line 916 "parser_gram.y"
	{
	filebench_shm->shm_rmode = FILEBENCH_MODE_TIMEOUT;
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
}
break;
case 92:
#line 922 "parser_gram.y"
	{
	filebench_shm->shm_rmode = FILEBENCH_MODE_QALLDONE;
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
}
break;
case 93:
#line 928 "parser_gram.y"
	{
	filebench_shm->shm_rmode = FILEBENCH_MODE_Q1STDONE;
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
}
break;
case 94:
#line 934 "parser_gram.y"
	{
	filebench_shm->shm_mmode |= FILEBENCH_MODE_NOUSAGE;
	filebench_log(LOG_INFO, "disabling CPU usage statistics");
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
}
break;
case 95:
#line 941 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_randvar_set;
	yyval.cmd->cmd_tgt1 = yystack.l_mark[-3].sval;
	yyval.cmd->cmd_qty = FSS_TYPE;
	yyval.cmd->cmd_attr_list = yystack.l_mark[0].attr;

}
break;
case 96:
#line 950 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_randvar_set;
	yyval.cmd->cmd_tgt1 = yystack.l_mark[-3].sval;
	yyval.cmd->cmd_qty = FSS_SRC;
	yyval.cmd->cmd_attr_list = yystack.l_mark[0].attr;

}
break;
case 97:
#line 959 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_randvar_set;
	yyval.cmd->cmd_tgt1 = yystack.l_mark[-3].sval;
	yyval.cmd->cmd_qty = yystack.l_mark[-2].ival;
	yyval.cmd->cmd_attr_list = yystack.l_mark[0].attr;
	
}
break;
case 98:
#line 970 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = (void (*)(struct cmd *))&parser_statssnap;
	break;

}
break;
case 99:
#line 978 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = (void (*)(struct cmd *))&stats_clear;

}
break;
case 100:
#line 985 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd_param_list = yystack.l_mark[0].list;
	yyval.cmd->cmd = (void (*)(struct cmd *))&parser_directory;

}
break;
case 101:
#line 993 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yystack.l_mark[0].list;
	yyval.cmd->cmd = parser_statscmd;

}
break;
case 102:
#line 1001 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yystack.l_mark[0].list;
	yyval.cmd->cmd = parser_statsdump;
}
break;
case 103:
#line 1008 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yystack.l_mark[0].list;
	yyval.cmd->cmd = parser_statsxmldump;
}
break;
case 104:
#line 1015 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yystack.l_mark[0].list;
	yyval.cmd->cmd = parser_statsmultidump;
}
break;
case 105:
#line 1024 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_filebench_shutdown;
}
break;
case 106:
#line 1031 "parser_gram.y"
	{
	yyval.cmd = yystack.l_mark[0].cmd;
}
break;
case 107:
#line 1034 "parser_gram.y"
	{
	cmd_t *list = NULL;
	cmd_t *list_end = NULL;

	/* Find end of list */
	for (list = yystack.l_mark[-1].cmd; list != NULL;
	    list = list->cmd_next)
		list_end = list;

	list_end->cmd_next = yystack.l_mark[0].cmd;

	filebench_log(LOG_DEBUG_IMPL,
	    "flowop_list adding cmd %zx to list %zx", yystack.l_mark[0].cmd, yystack.l_mark[-1].cmd);

	yyval.cmd = yystack.l_mark[-1].cmd;
}
break;
case 108:
#line 1052 "parser_gram.y"
	{
	/*
	 * Allocate a cmd node per thread, with a
	 * list of flowops attached to the cmd_list
	 */
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd_list = yystack.l_mark[-1].cmd;
	yyval.cmd->cmd_attr_list = yystack.l_mark[-3].attr;
}
break;
case 109:
#line 1064 "parser_gram.y"
	{
	yyval.cmd = yystack.l_mark[0].cmd;
}
break;
case 110:
#line 1067 "parser_gram.y"
	{
	cmd_t *list = NULL;
	cmd_t *list_end = NULL;

	/* Find end of list */
	for (list = yystack.l_mark[-1].cmd; list != NULL;
	    list = list->cmd_next)
		list_end = list;

	list_end->cmd_next = yystack.l_mark[0].cmd;

	filebench_log(LOG_DEBUG_IMPL,
	    "thread_list adding cmd %zx to list %zx", yystack.l_mark[0].cmd, yystack.l_mark[-1].cmd);

	yyval.cmd = yystack.l_mark[-1].cmd;
}
break;
case 111:
#line 1085 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_proc_define;
	yyval.cmd->cmd_list = yystack.l_mark[-1].cmd;
	yyval.cmd->cmd_attr_list = yystack.l_mark[-3].attr;

}
break;
case 112:
#line 1094 "parser_gram.y"
	{
	yystack.l_mark[-1].cmd->cmd_attr_list = yystack.l_mark[0].attr;
}
break;
case 113:
#line 1099 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_file_define;
}
break;
case 114:
#line 1104 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_fileset_define;
}
break;
case 115:
#line 1110 "parser_gram.y"
	{
	yystack.l_mark[-1].cmd->cmd_attr_list = yystack.l_mark[0].attr;
}
break;
case 116:
#line 1114 "parser_gram.y"
	{
 	 yystack.l_mark[-3].cmd->cmd_attr_list = yystack.l_mark[-2].attr;
     attr_t *attr = NULL;
     attr_t *list_end = NULL; 
     for (attr = yystack.l_mark[-2].attr; attr != NULL;
         attr = attr->attr_next)
	 {
		printf("%d->",attr->attr_name);
         list_end = attr; /* Find end of list */
	 }
     list_end->attr_next = yystack.l_mark[0].attr;
}
break;
case 117:
#line 1128 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_posset_define;
}
break;
case 118:
#line 1133 "parser_gram.y"
	{
	yystack.l_mark[-1].cmd->cmd_attr_list = yystack.l_mark[0].attr;
}
break;
case 119:
#line 1138 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_randvar_define;
	yyval.cmd->cmd_attr_list = yystack.l_mark[0].attr;
}
break;
case 120:
#line 1146 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_composite_flowop_define;
	yyval.cmd->cmd_list = yystack.l_mark[-1].cmd;
	yyval.cmd->cmd_attr_list = yystack.l_mark[-3].attr;
}
break;
case 121:
#line 1154 "parser_gram.y"
	{
	yystack.l_mark[-1].cmd->cmd_attr_list = yystack.l_mark[0].attr;
}
break;
case 122:
#line 1160 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	switch (yystack.l_mark[0].ival) {
	case FSE_PROC:
		yyval.cmd->cmd = &parser_proc_create;
		break;
	case FSE_FILESET:
	case FSE_FILE:
		yyval.cmd->cmd = &parser_fileset_create;
		break;
	default:
		filebench_log(LOG_ERROR, "unknown entity", yystack.l_mark[0].ival);
		YYERROR;
	}

}
break;
case 123:
#line 1179 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	switch (yystack.l_mark[0].ival) {
	case FSE_PROC:
		yyval.cmd->cmd = &parser_proc_shutdown;
		break;
	case FSE_FILE:
	case FSE_FILESET:
		yyval.cmd->cmd = &parser_fileset_shutdown;
		break;
	default:
		filebench_log(LOG_ERROR, "unknown entity", yystack.l_mark[0].ival);
		YYERROR;
	}

}
break;
case 124:
#line 1198 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_warmup;
	yyval.cmd->cmd_qty = yystack.l_mark[0].ival;
}
break;
case 125:
#line 1205 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_warmup_variable;
	yyval.cmd->cmd_tgt1 = fb_stralloc(yystack.l_mark[0].sval);
}
break;
case 126:
#line 1213 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_sleep;
	yyval.cmd->cmd_qty = yystack.l_mark[0].ival;
}
break;
case 127:
#line 1220 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_sleep_variable;
	yyval.cmd->cmd_tgt1 = fb_stralloc(yystack.l_mark[0].sval);
}
break;
case 128:
#line 1228 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_run;
	yyval.cmd->cmd_qty = yystack.l_mark[0].ival;
}
break;
case 129:
#line 1235 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_run_variable;
	yyval.cmd->cmd_tgt1 = fb_stralloc(yystack.l_mark[0].sval);
}
break;
case 130:
#line 1242 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_run;
	yyval.cmd->cmd_qty = 60UL;
}
break;
case 131:
#line 1250 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_help;
}
break;
case 132:
#line 1257 "parser_gram.y"
	{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd_name = fb_stralloc(yystack.l_mark[0].sval);
}
break;
case 133:
#line 1263 "parser_gram.y"
	{
	yystack.l_mark[-1].cmd->cmd_attr_list = yystack.l_mark[0].attr;
}
break;
case 134:
#line 1268 "parser_gram.y"
	{
	FILE *newfile;
	char loadfile[128];

	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	(void) strcpy(loadfile, yystack.l_mark[0].sval);
	(void) strcat(loadfile, ".f");

	if ((newfile = fopen(loadfile, "r")) == NULL) {
		(void) strcpy(loadfile, fbbasepath);
		(void) strcat(loadfile, "/workloads/");
		(void) strcat(loadfile, yystack.l_mark[0].sval);
		(void) strcat(loadfile, ".f");
		if ((newfile = fopen(loadfile, "r")) == NULL) {
			filebench_log(LOG_ERROR, "Cannot open %s", loadfile);
			YYERROR;
		}
	}

	parentscript = yyin;
	yyin = newfile;
	yy_switchfileparent(yyin);
}
break;
case 135:
#line 1295 "parser_gram.y"
	{yyval.ival = FSE_PROC;}
break;
case 136:
#line 1296 "parser_gram.y"
	{yyval.ival = FSE_THREAD;}
break;
case 137:
#line 1297 "parser_gram.y"
	{yyval.ival = FSE_FILESET;}
break;
case 138:
#line 1298 "parser_gram.y"
	{yyval.ival = FSE_FILE;}
break;
case 139:
#line 1300 "parser_gram.y"
	{ yyval.val.i = yystack.l_mark[0].ival;}
break;
case 140:
#line 1301 "parser_gram.y"
	{ yyval.val.s = yystack.l_mark[0].sval;}
break;
case 141:
#line 1302 "parser_gram.y"
	{ yyval.val.b = yystack.l_mark[0].bval;}
break;
case 143:
#line 1308 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
}
break;
case 144:
#line 1312 "parser_gram.y"
	{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yystack.l_mark[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yystack.l_mark[0].attr;

	yyval.attr = yystack.l_mark[-2].attr;
}
break;
case 145:
#line 1326 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
}
break;
case 146:
#line 1330 "parser_gram.y"
	{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yystack.l_mark[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yystack.l_mark[0].attr;

	yyval.attr = yystack.l_mark[-2].attr;
}
break;
case 147:
#line 1344 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
	yyval.attr->attr_name = yystack.l_mark[-2].ival;
}
break;
case 148:
#line 1349 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yystack.l_mark[0].ival;
}
break;
case 149:
#line 1356 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
	yyval.attr->attr_name = yystack.l_mark[-2].ival;
}
break;
case 150:
#line 1361 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yystack.l_mark[0].ival;
}
break;
case 151:
#line 1368 "parser_gram.y"
	{
	/*printf("no param dsrc:%d\n",$1);*/
	if((yyval.attr=alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_str_alloc(yystack.l_mark[0].sval);
	yyval.attr->attr_name=FSA_DSRC;
}
break;
case 152:
#line 1376 "parser_gram.y"
	{
	printf("datasource present chk params\n");
	if((yyval.attr=alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_str_alloc(yystack.l_mark[-2].sval);
	yyval.attr->attr_name=FSA_DSRC;
	yyval.attr->sub_attr_list = yystack.l_mark[0].attr;
}
break;
case 153:
#line 1386 "parser_gram.y"
	{
	printf("chk params now\n");
	yyval.attr = yystack.l_mark[0].attr;
}
break;
case 154:
#line 1391 "parser_gram.y"
	{
	printf("chk params now\n");
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yystack.l_mark[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yystack.l_mark[0].attr;

	yyval.attr = yystack.l_mark[-2].attr;
}
break;
case 155:
#line 1406 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
	yyval.attr->attr_name = yystack.l_mark[-2].ival;
}
break;
case 156:
#line 1413 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
}
break;
case 157:
#line 1417 "parser_gram.y"
	{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yystack.l_mark[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yystack.l_mark[0].attr;

	yyval.attr = yystack.l_mark[-2].attr;
}
break;
case 158:
#line 1430 "parser_gram.y"
	{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yystack.l_mark[-6].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	
	if ((attr = alloc_attr()) == NULL)
		YYERROR;

	attr->attr_name = FSA_RANDTABLE;
	attr->attr_obj = (void *)yystack.l_mark[-1].rndtb;
	list_end->attr_next = attr;
	yyval.attr = yystack.l_mark[-6].attr;
}
break;
case 159:
#line 1449 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
	yyval.attr->attr_name = yystack.l_mark[-2].ival;
}
break;
case 160:
#line 1454 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yystack.l_mark[0].ival;
}
break;
case 161:
#line 1460 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
	yyval.attr->attr_name = FSA_TYPE;
}
break;
case 162:
#line 1465 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
	yyval.attr->attr_name = FSA_RANDSRC;
}
break;
case 163:
#line 1471 "parser_gram.y"
	{
	if ((yyval.rndtb = alloc_probtabent()) == NULL)
		YYERROR;
	yyval.rndtb->pte_percent = yystack.l_mark[-5].avd;
	yyval.rndtb->pte_segmin  = yystack.l_mark[-3].avd;
	yyval.rndtb->pte_segmax  = yystack.l_mark[-1].avd;
}
break;
case 164:
#line 1481 "parser_gram.y"
	{
	yyval.rndtb = yystack.l_mark[0].rndtb;
}
break;
case 165:
#line 1485 "parser_gram.y"
	{
	probtabent_t *pte = NULL;
	probtabent_t *ptelist_end = NULL;

	for (pte = yystack.l_mark[-2].rndtb; pte != NULL;
	    pte = pte->pte_next)
		ptelist_end = pte; /* Find end of prob table entry list */

	ptelist_end->pte_next = yystack.l_mark[0].rndtb;

	yyval.rndtb = yystack.l_mark[-2].rndtb;
}
break;
case 166:
#line 1500 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
}
break;
case 167:
#line 1504 "parser_gram.y"
	{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yystack.l_mark[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yystack.l_mark[0].attr;

	yyval.attr = yystack.l_mark[-2].attr;
}
break;
case 168:
#line 1518 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
	yyval.attr->attr_name = yystack.l_mark[-2].ival;
}
break;
case 169:
#line 1523 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yystack.l_mark[0].ival;
}
break;
case 170:
#line 1531 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
}
break;
case 171:
#line 1535 "parser_gram.y"
	{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yystack.l_mark[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yystack.l_mark[0].attr;

	yyval.attr = yystack.l_mark[-2].attr;
}
break;
case 172:
#line 1548 "parser_gram.y"
	{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yystack.l_mark[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yystack.l_mark[0].attr;

	yyval.attr = yystack.l_mark[-2].attr;
}
break;
case 173:
#line 1562 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
	yyval.attr->attr_name = yystack.l_mark[-2].ival;
}
break;
case 174:
#line 1567 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yystack.l_mark[0].ival;
}
break;
case 175:
#line 1575 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
}
break;
case 176:
#line 1579 "parser_gram.y"
	{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yystack.l_mark[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yystack.l_mark[0].attr;

	yyval.attr = yystack.l_mark[-2].attr;
}
break;
case 177:
#line 1593 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
	yyval.attr->attr_name = yystack.l_mark[-2].ival;
}
break;
case 178:
#line 1598 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yystack.l_mark[0].ival;
}
break;
case 179:
#line 1606 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
}
break;
case 180:
#line 1610 "parser_gram.y"
	{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yystack.l_mark[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yystack.l_mark[0].attr;

	yyval.attr = yystack.l_mark[-2].attr;
}
break;
case 181:
#line 1624 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
	yyval.attr->attr_name = yystack.l_mark[-2].ival;
}
break;
case 182:
#line 1630 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
	yyval.attr->attr_name = FSA_VALUE;
}
break;
case 183:
#line 1636 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_str_alloc(yystack.l_mark[0].sval);
	yyval.attr->attr_name = yystack.l_mark[-2].ival;
}
break;
case 184:
#line 1644 "parser_gram.y"
	{yyval.ival = FSK_PLUS;}
break;
case 185:
#line 1645 "parser_gram.y"
	{yyval.ival = FSK_MINUS;}
break;
case 186:
#line 1646 "parser_gram.y"
	{yyval.ival = FSK_MULTIPLY;}
break;
case 187:
#line 1647 "parser_gram.y"
	{yyval.ival = FSK_DIVIDE;}
break;
case 195:
#line 1662 "parser_gram.y"
	{ yyval.ival = FSA_NICE;}
break;
case 196:
#line 1663 "parser_gram.y"
	{ yyval.ival = FSA_NAME;}
break;
case 197:
#line 1664 "parser_gram.y"
	{ yyval.ival = FSA_INSTANCES;}
break;
case 198:
#line 1667 "parser_gram.y"
	{ yyval.ival = FSA_SIZE;}
break;
case 199:
#line 1668 "parser_gram.y"
	{ yyval.ival = FSA_NAME;}
break;
case 200:
#line 1669 "parser_gram.y"
	{ yyval.ival = FSA_PATH;}
break;
case 201:
#line 1670 "parser_gram.y"
	{ yyval.ival = FSA_READONLY;}
break;
case 202:
#line 1671 "parser_gram.y"
	{ yyval.ival = FSA_TRUSTTREE;}
break;
case 203:
#line 1672 "parser_gram.y"
	{ yyval.ival = FSA_REUSE;}
break;
case 204:
#line 1673 "parser_gram.y"
	{ yyval.ival = FSA_PREALLOC;}
break;
case 205:
#line 1674 "parser_gram.y"
	{ yyval.ival = FSA_PARALLOC;}
break;
case 206:
#line 1677 "parser_gram.y"
	{ yyval.ival = FSA_SIZE;}
break;
case 207:
#line 1678 "parser_gram.y"
	{ yyval.ival = FSA_NAME;}
break;
case 208:
#line 1679 "parser_gram.y"
	{ yyval.ival = FSA_PATH;}
break;
case 209:
#line 1680 "parser_gram.y"
	{ yyval.ival = FSA_DIRWIDTH;}
break;
case 210:
#line 1681 "parser_gram.y"
	{ yyval.ival = FSA_DIRDEPTHRV;}
break;
case 211:
#line 1682 "parser_gram.y"
	{ yyval.ival = FSA_PREALLOC;}
break;
case 212:
#line 1683 "parser_gram.y"
	{ yyval.ival = FSA_PARALLOC;}
break;
case 213:
#line 1684 "parser_gram.y"
	{ yyval.ival = FSA_REUSE;}
break;
case 214:
#line 1685 "parser_gram.y"
	{ yyval.ival = FSA_READONLY;}
break;
case 215:
#line 1686 "parser_gram.y"
	{ yyval.ival = FSA_TRUSTTREE;}
break;
case 216:
#line 1687 "parser_gram.y"
	{ yyval.ival = FSA_FILESIZEGAMMA;}
break;
case 217:
#line 1688 "parser_gram.y"
	{ yyval.ival = FSA_DIRGAMMA;}
break;
case 218:
#line 1689 "parser_gram.y"
	{ yyval.ival = FSA_CACHED;}
break;
case 219:
#line 1690 "parser_gram.y"
	{ yyval.ival = FSA_ENTRIES;}
break;
case 220:
#line 1691 "parser_gram.y"
	{ yyval.ival = FSA_LEAFDIRS;}
break;
case 221:
#line 1692 "parser_gram.y"
	{ yyval.ival = FSA_DSRC;}
break;
case 222:
#line 1695 "parser_gram.y"
	{yyval.ival = FSA_ENTROPY;}
break;
case 223:
#line 1696 "parser_gram.y"
	{yyval.ival = FSA_DUMMY;}
break;
case 224:
#line 1699 "parser_gram.y"
	{ yyval.ival = FSA_NAME;}
break;
case 225:
#line 1700 "parser_gram.y"
	{ yyval.ival = FSA_TYPE;}
break;
case 226:
#line 1701 "parser_gram.y"
	{ yyval.ival = FSA_RANDSEED;}
break;
case 227:
#line 1702 "parser_gram.y"
	{ yyval.ival = FSA_ENTRIES;}
break;
case 228:
#line 1703 "parser_gram.y"
	{ yyval.ival = FSA_RANDMAX;}
break;
case 229:
#line 1706 "parser_gram.y"
	{ yyval.ival = FSA_NAME;}
break;
case 230:
#line 1707 "parser_gram.y"
	{ yyval.ival = FSA_RANDSEED;}
break;
case 231:
#line 1708 "parser_gram.y"
	{ yyval.ival = FSA_RANDGAMMA;}
break;
case 232:
#line 1709 "parser_gram.y"
	{ yyval.ival = FSA_RANDMEAN;}
break;
case 233:
#line 1710 "parser_gram.y"
	{ yyval.ival = FSA_RANDMIN;}
break;
case 234:
#line 1711 "parser_gram.y"
	{ yyval.ival = FSA_RANDROUND;}
break;
case 235:
#line 1714 "parser_gram.y"
	{ yyval.ival = FSS_TYPE;}
break;
case 236:
#line 1715 "parser_gram.y"
	{ yyval.ival = FSS_SRC;}
break;
case 237:
#line 1716 "parser_gram.y"
	{ yyval.ival = FSS_SEED;}
break;
case 238:
#line 1717 "parser_gram.y"
	{ yyval.ival = FSS_GAMMA;}
break;
case 239:
#line 1718 "parser_gram.y"
	{ yyval.ival = FSS_MEAN;}
break;
case 240:
#line 1719 "parser_gram.y"
	{ yyval.ival = FSS_MIN;}
break;
case 241:
#line 1720 "parser_gram.y"
	{ yyval.ival = FSS_ROUND;}
break;
case 242:
#line 1723 "parser_gram.y"
	{ yyval.ival = FSS_SEED;}
break;
case 243:
#line 1724 "parser_gram.y"
	{ yyval.ival = FSS_GAMMA;}
break;
case 244:
#line 1725 "parser_gram.y"
	{ yyval.ival = FSS_MEAN;}
break;
case 245:
#line 1726 "parser_gram.y"
	{ yyval.ival = FSS_MIN;}
break;
case 246:
#line 1727 "parser_gram.y"
	{ yyval.ival = FSS_ROUND;}
break;
case 247:
#line 1730 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_int_alloc(yystack.l_mark[0].ival);
}
break;
case 248:
#line 1737 "parser_gram.y"
	{ yyval.ival = FSV_RANDUNI;}
break;
case 249:
#line 1738 "parser_gram.y"
	{ yyval.ival = FSV_RANDTAB;}
break;
case 250:
#line 1739 "parser_gram.y"
	{ yyval.ival = FSA_RANDGAMMA;}
break;
case 251:
#line 1742 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_int_alloc(yystack.l_mark[0].ival);
}
break;
case 252:
#line 1749 "parser_gram.y"
	{ yyval.ival = FSV_URAND;}
break;
case 253:
#line 1750 "parser_gram.y"
	{ yyval.ival = FSV_RAND48;}
break;
case 254:
#line 1753 "parser_gram.y"
	{ yyval.ival = FSA_PROCESS;}
break;
case 255:
#line 1754 "parser_gram.y"
	{ yyval.ival = FSA_NAME;}
break;
case 256:
#line 1755 "parser_gram.y"
	{ yyval.ival = FSA_MEMSIZE;}
break;
case 257:
#line 1756 "parser_gram.y"
	{ yyval.ival = FSA_USEISM;}
break;
case 258:
#line 1757 "parser_gram.y"
	{ yyval.ival = FSA_INSTANCES;}
break;
case 259:
#line 1760 "parser_gram.y"
	{ yyval.ival = FSA_WSS;}
break;
case 260:
#line 1761 "parser_gram.y"
	{ yyval.ival = FSA_FILE;}
break;
case 261:
#line 1762 "parser_gram.y"
	{ yyval.ival = FSA_POSSET;}
break;
case 262:
#line 1763 "parser_gram.y"
	{ yyval.ival = FSA_NAME;}
break;
case 263:
#line 1764 "parser_gram.y"
	{ yyval.ival = FSA_RANDOM;}
break;
case 264:
#line 1765 "parser_gram.y"
	{ yyval.ival = FSA_FD;}
break;
case 265:
#line 1766 "parser_gram.y"
	{ yyval.ival = FSA_SRCFD;}
break;
case 266:
#line 1767 "parser_gram.y"
	{ yyval.ival = FSA_ROTATEFD;}
break;
case 267:
#line 1768 "parser_gram.y"
	{ yyval.ival = FSA_DSYNC;}
break;
case 268:
#line 1769 "parser_gram.y"
	{ yyval.ival = FSA_DIRECTIO;}
break;
case 269:
#line 1770 "parser_gram.y"
	{ yyval.ival = FSA_INDEXED;}
break;
case 270:
#line 1771 "parser_gram.y"
	{ yyval.ival = FSA_TARGET;}
break;
case 271:
#line 1772 "parser_gram.y"
	{ yyval.ival = FSA_ITERS;}
break;
case 272:
#line 1773 "parser_gram.y"
	{ yyval.ival = FSA_VALUE;}
break;
case 273:
#line 1774 "parser_gram.y"
	{ yyval.ival = FSA_BLOCKING;}
break;
case 274:
#line 1775 "parser_gram.y"
	{ yyval.ival = FSA_HIGHWATER;}
break;
case 275:
#line 1776 "parser_gram.y"
	{ yyval.ival = FSA_IOSIZE;}
break;
case 276:
#line 1777 "parser_gram.y"
	{ yyval.ival = FSA_NOREADAHEAD;}
break;
case 277:
#line 1780 "parser_gram.y"
	{ yyval.ival = FSA_RATE;}
break;
case 278:
#line 1783 "parser_gram.y"
	{ yyval.ival = FSA_MASTER;}
break;
case 279:
#line 1784 "parser_gram.y"
	{ yyval.ival = FSA_CLIENT;}
break;
case 280:
#line 1787 "parser_gram.y"
	{ yyval.ival = FSA_PATH;}
break;
case 281:
#line 1788 "parser_gram.y"
	{ yyval.ival = FSA_FSTYPE;}
break;
case 282:
#line 1791 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
}
break;
case 283:
#line 1795 "parser_gram.y"
	{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yystack.l_mark[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yystack.l_mark[0].attr;

	yyval.attr = yystack.l_mark[-2].attr;
}
break;
case 284:
#line 1808 "parser_gram.y"
	{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yystack.l_mark[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yystack.l_mark[0].attr;

	yyval.attr = yystack.l_mark[-2].attr;
}
break;
case 285:
#line 1822 "parser_gram.y"
	{
	yyval.attr = yystack.l_mark[0].attr;
	yyval.attr->attr_name = yystack.l_mark[-2].ival;
}
break;
case 286:
#line 1828 "parser_gram.y"
	{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_boolean(yystack.l_mark[-2].sval, yystack.l_mark[0].bval))) == NULL)
		YYERROR;
}
break;
case 287:
#line 1833 "parser_gram.y"
	{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_integer(yystack.l_mark[-2].sval, yystack.l_mark[0].ival))) == NULL)
		YYERROR;
}
break;
case 288:
#line 1838 "parser_gram.y"
	{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_string(yystack.l_mark[-4].sval, yystack.l_mark[-1].sval))) == NULL)
		YYERROR;
}
break;
case 289:
#line 1843 "parser_gram.y"
	{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_string(yystack.l_mark[-2].sval, yystack.l_mark[0].sval))) == NULL)
		YYERROR;
}
break;
case 290:
#line 1848 "parser_gram.y"
	{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_var(yystack.l_mark[-2].sval, yystack.l_mark[0].sval))) == NULL)
		YYERROR;
}
break;
case 291:
#line 1853 "parser_gram.y"
	{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_alloc_local(yystack.l_mark[0].sval))) == NULL)
		YYERROR;
}
break;
case 292:
#line 1860 "parser_gram.y"
	{ yyval.ival = FSA_NAME;}
break;
case 293:
#line 1861 "parser_gram.y"
	{ yyval.ival = FSA_ITERS;}
break;
case 294:
#line 1864 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_str_alloc(yystack.l_mark[0].sval);
}
break;
case 295:
#line 1868 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_int_alloc(yystack.l_mark[0].ival);
}
break;
case 296:
#line 1872 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_bool_alloc(yystack.l_mark[0].bval);
}
break;
case 297:
#line 1876 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = var_ref_attr(yystack.l_mark[0].sval);
}
break;
case 298:
#line 1880 "parser_gram.y"
	{
	if((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd=avd_dbl_alloc(yystack.l_mark[0].dbl);
}
break;
case 299:
#line 1886 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_param_list = yystack.l_mark[0].list;
}
break;
case 300:
#line 1890 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_str_alloc(yystack.l_mark[0].sval);
}
break;
case 301:
#line 1894 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_int_alloc(yystack.l_mark[0].ival);
}
break;
case 302:
#line 1898 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_bool_alloc(yystack.l_mark[0].bval);
}
break;
case 303:
#line 1902 "parser_gram.y"
	{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = var_ref_attr(yystack.l_mark[0].sval);
}
break;
case 304:
#line 1909 "parser_gram.y"
	{
	yyval.avd = avd_int_alloc(yystack.l_mark[0].ival);
}
break;
case 305:
#line 1912 "parser_gram.y"
	{
	yyval.avd = var_ref_attr(yystack.l_mark[0].sval);
}
break;
#line 6894 "parser_gram.c"
    }
    yystack.s_mark -= yym;
    yystate = *yystack.s_mark;
    yystack.l_mark -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yystack.s_mark = YYFINAL;
        *++yystack.l_mark = yyval;
        if (yychar < 0)
        {
            if ((yychar = YYLEX) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yystack.s_mark, yystate);
#endif
    if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack))
    {
        goto yyoverflow;
    }
    *++yystack.s_mark = (short) yystate;
    *++yystack.l_mark = yyval;
    goto yyloop;

yyoverflow:
    yyerror("yacc stack overflow");

yyabort:
    yyfreestack(&yystack);
    return (1);

yyaccept:
    yyfreestack(&yystack);
    return (0);
}
