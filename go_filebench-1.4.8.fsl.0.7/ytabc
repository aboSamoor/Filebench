#ifndef lint
static char const 
yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
#endif
#include <stdlib.h>
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYLEX yylex()
#define YYEMPTY -1
#define yyclearin (yychar=(YYEMPTY))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING() (yyerrflag!=0)
static int yygrowstack();
#define YYPREFIX "yy"
#line 29 "parser_gram.y"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <sys/types.h>
#include <locale.h>
#include <sys/utsname.h>
#include <sys/statvfs.h>
#ifdef HAVE_STDINT_H
#include <stdint.h>
#endif
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#ifdef HAVE_LIBTECLA
#include <libtecla.h>
#endif
#include "parsertypes.h"
#include "filebench.h"
#include "utils.h"
#include "stats.h"
#include "vars.h"
#include "eventgen.h"
#ifdef HAVE_LIBTECLA
#include "auto_comp.h"
#endif
#include "multi_client_sync.h"

extern int yylex(void);

int dofile = FS_FALSE;
static const char cmdname[] = "filebench";
static const char cmd_options[] = "pa:f:hi:s:m:";
static void usage(int);

#ifdef HAVE_LIBTECLA
static GetLine *gl;			/* GetLine resource object */
#endif

char *execname;
char *fbbasepath = FILEBENCHDIR;
char *fscriptname;
int noproc = 0;
var_t *var_list = NULL;
pidlist_t *pidlist = NULL;
char *cwd = NULL;
FILE *parentscript = NULL;

static int filecreate_done = 0;

/* OSprof enable flag. */
int osprof_enabled;

/* yacc externals */
extern FILE *yyin;
extern int yydebug;
extern void yyerror(char *s);

/* utilities */
static cmd_t *alloc_cmd(void);
static attr_t *alloc_attr(void);
static attr_t *alloc_lvar_attr(var_t *var);
static attr_t *get_attr(cmd_t *cmd, int64_t name);
static attr_t *get_attr_fileset(cmd_t *cmd, int64_t name);
static attr_t *get_attr_integer(cmd_t *cmd, int64_t name);
static attr_t *get_attr_bool(cmd_t *cmd, int64_t name);
static void get_attr_lvars(cmd_t *cmd, flowop_t *flowop);
static list_t *alloc_list();
static probtabent_t *alloc_probtabent(void);
static void add_lvar_to_list(var_t *newlvar, var_t **lvar_list);

/* Info Commands */
static void parser_list(cmd_t *);
static void parser_flowop_list(cmd_t *);

/* Define Commands */
static void parser_proc_define(cmd_t *);
static void parser_thread_define(cmd_t *, procflow_t *, int instances);
static void parser_flowop_define(cmd_t *, threadflow_t *, flowop_t **, int);
static void parser_file_define(cmd_t *);
static void parser_fileset_define(cmd_t *);
static void parser_posset_define(cmd_t *);
static void parser_randvar_define(cmd_t *);
static void parser_randvar_set(cmd_t *);
static void parser_composite_flowop_define(cmd_t *);

/* Create Commands */
static void parser_proc_create(cmd_t *);
static void parser_fileset_create(cmd_t *);

/* set commands */
static void parser_set_integer(cmd_t *cmd);
static void parser_set_var(cmd_t *cmd);
static void parser_set_var_op_int(cmd_t *cmd);
static void parser_set_int_op_var(cmd_t *cmd);
static void parser_set_var_op_var(cmd_t *cmd);

/* Shutdown Commands */
static void parser_proc_shutdown(cmd_t *);
static void parser_filebench_shutdown(cmd_t *cmd);
static void parser_fileset_shutdown(cmd_t *cmd);

/* Other Commands */
static void parser_echo(cmd_t *cmd);
static void parser_foreach_integer(cmd_t *cmd);
static void parser_foreach_string(cmd_t *cmd);
static void parser_fscheck(cmd_t *cmd);
static void parser_fsflush(cmd_t *cmd);
static void parser_log(cmd_t *cmd);
static void parser_statscmd(cmd_t *cmd);
static void parser_statsdump(cmd_t *cmd);
static void parser_statsxmldump(cmd_t *cmd);
static void parser_statsmultidump(cmd_t *cmd);
static void parser_usage(cmd_t *cmd);
static void parser_vars(cmd_t *cmd);
static void parser_printvars(cmd_t *cmd);
static void parser_system(cmd_t *cmd);
static void parser_statssnap(cmd_t *cmd);
static void parser_directory(cmd_t *cmd);
static void parser_eventgen(cmd_t *cmd);
static void parser_enable_mc(cmd_t *cmd);
static void parser_domultisync(cmd_t *cmd);
static void parser_run(cmd_t *cmd);
static void parser_run_variable(cmd_t *cmd);
static void parser_sleep(cmd_t *cmd);
static void parser_sleep_variable(cmd_t *cmd);
static void parser_warmup(cmd_t *cmd);
static void parser_warmup_variable(cmd_t *cmd);
static void parser_help(cmd_t *cmd);
static void arg_parse(const char *command);
static void parser_abort(int arg);
static void parser_version(cmd_t *cmd);
static void parser_osprof_enable(cmd_t *cmd);
static void parser_osprof_disable(cmd_t *cmd);

#line 168 "parser_gram.y"
typedef union {
	int64_t		 ival;
	unsigned char	 bval;
	char *		 sval;
	fs_u		 val;
	avd_t		 avd;
	cmd_t		*cmd;
	attr_t		*attr;
	list_t		*list;
	probtabent_t	*rndtb;
} YYSTYPE;
#line 167 "y.tab.c"
#define YYERRCODE 256
#define FSC_LIST 257
#define FSC_DEFINE 258
#define FSC_EXEC 259
#define FSC_QUIT 260
#define FSC_DEBUG 261
#define FSC_CREATE 262
#define FSC_SLEEP 263
#define FSC_STATS 264
#define FSC_FOREACH 265
#define FSC_SET 266
#define FSC_SHUTDOWN 267
#define FSC_LOG 268
#define FSC_SYSTEM 269
#define FSC_FLOWOP 270
#define FSC_EVENTGEN 271
#define FSC_ECHO 272
#define FSC_LOAD 273
#define FSC_RUN 274
#define FSC_WARMUP 275
#define FSC_NOUSESTATS 276
#define FSC_FSCHECK 277
#define FSC_FSFLUSH 278
#define FSC_USAGE 279
#define FSC_HELP 280
#define FSC_VARS 281
#define FSC_VERSION 282
#define FSC_ENABLE 283
#define FSC_DOMULTISYNC 284
#define FSV_STRING 285
#define FSV_VAL_INT 286
#define FSV_VAL_BOOLEAN 287
#define FSV_VARIABLE 288
#define FSV_WHITESTRING 289
#define FSV_RANDUNI 290
#define FSV_RANDTAB 291
#define FSV_RANDVAR 292
#define FSV_URAND 293
#define FSV_RAND48 294
#define FST_INT 295
#define FST_BOOLEAN 296
#define FSE_FILE 297
#define FSE_PROC 298
#define FSE_THREAD 299
#define FSE_CLEAR 300
#define FSE_ALL 301
#define FSE_SNAP 302
#define FSE_DUMP 303
#define FSE_DIRECTORY 304
#define FSE_COMMAND 305
#define FSE_FILESET 306
#define FSE_POSSET 307
#define FSE_XMLDUMP 308
#define FSE_RAND 309
#define FSE_MODE 310
#define FSE_MULTI 311
#define FSE_MULTIDUMP 312
#define FSK_SEPLST 313
#define FSK_OPENLST 314
#define FSK_CLOSELST 315
#define FSK_ASSIGN 316
#define FSK_IN 317
#define FSK_QUOTE 318
#define FSK_DIRSEPLST 319
#define FSK_PLUS 320
#define FSK_MINUS 321
#define FSK_MULTIPLY 322
#define FSK_DIVIDE 323
#define FSA_SIZE 324
#define FSA_PREALLOC 325
#define FSA_PARALLOC 326
#define FSA_PATH 327
#define FSA_REUSE 328
#define FSA_PROCESS 329
#define FSA_MEMSIZE 330
#define FSA_RATE 331
#define FSA_CACHED 332
#define FSA_READONLY 333
#define FSA_TRUSTTREE 334
#define FSA_IOSIZE 335
#define FSA_FILE 336
#define FSA_POSSET 337
#define FSA_WSS 338
#define FSA_NAME 339
#define FSA_RANDOM 340
#define FSA_INSTANCES 341
#define FSA_DSYNC 342
#define FSA_TARGET 343
#define FSA_ITERS 344
#define FSA_NICE 345
#define FSA_VALUE 346
#define FSA_BLOCKING 347
#define FSA_HIGHWATER 348
#define FSA_DIRECTIO 349
#define FSA_DIRWIDTH 350
#define FSA_FD 351
#define FSA_SRCFD 352
#define FSA_ROTATEFD 353
#define FSA_NAMELENGTH 354
#define FSA_FILESIZE 355
#define FSA_ENTRIES 356
#define FSA_FILESIZEGAMMA 357
#define FSA_DIRDEPTHRV 358
#define FSA_DIRGAMMA 359
#define FSA_USEISM 360
#define FSA_TYPE 361
#define FSA_RANDTABLE 362
#define FSA_RANDSRC 363
#define FSA_RANDROUND 364
#define FSA_LEAFDIRS 365
#define FSA_INDEXED 366
#define FSA_FSTYPE 367
#define FSA_RANDSEED 368
#define FSA_RANDGAMMA 369
#define FSA_RANDMEAN 370
#define FSA_RANDMIN 371
#define FSA_RANDMAX 372
#define FSA_MASTER 373
#define FSA_CLIENT 374
#define FSS_TYPE 375
#define FSS_SEED 376
#define FSS_GAMMA 377
#define FSS_MEAN 378
#define FSS_MIN 379
#define FSS_SRC 380
#define FSS_ROUND 381
#define FSV_SET_LOCAL_VAR 382
#define FSA_LVAR_ASSIGN 383
#define FSA_ALLDONE 384
#define FSA_FIRSTDONE 385
#define FSA_TIMEOUT 386
#define FSC_OSPROF_ENABLE 387
#define FSC_OSPROF_DISABLE 388
#define FSA_NOREADAHEAD 389
const short yylhs[] = {                                        -1,
    0,    0,    0,    5,    5,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,   20,   20,   20,   66,
   66,   67,   67,   24,   24,   22,   29,   33,   41,   42,
   30,   32,   34,   34,   35,   68,   68,   70,   70,   69,
   69,   69,   69,   69,   71,   71,   72,   72,   72,   72,
   72,   72,   72,   72,    8,    8,   37,   37,   38,   21,
   14,   18,   18,   39,   39,   39,   39,   40,   40,   40,
   40,   40,   40,   40,   40,   40,   40,   17,   17,   17,
   17,   17,   17,   17,   25,   26,   26,   28,   27,   27,
    9,    9,   10,   10,   10,   11,   11,   12,   13,   13,
   15,   19,   36,   36,   16,   16,    7,    7,    7,   31,
   23,   23,    6,    2,    2,    2,    2,    3,    3,    3,
    1,   44,   44,   45,   45,   46,   46,   43,   43,   54,
   54,   54,   53,   53,   53,   53,   95,   94,   94,   48,
   48,   47,   47,   50,   50,   50,   49,   49,   52,   52,
   51,   51,   62,   62,   63,   64,   65,   93,   93,   93,
   93,   81,   81,   82,   83,   83,   84,   85,   78,   78,
   78,   73,   73,   73,   73,   73,   73,   73,   73,   76,
   76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
   76,   76,   76,   76,   77,   77,   77,   77,   77,   86,
   86,   86,   86,   86,   86,   90,   90,   90,   90,   90,
   90,   90,   88,   88,   88,   88,   88,   55,   87,   87,
   87,   56,   89,   89,   74,   74,   74,   74,   74,   75,
   75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
   75,   75,   75,   75,   75,   75,   75,   79,   91,   91,
   92,   92,   61,   61,   61,   60,   59,   59,   59,   59,
   59,   59,   80,   80,   57,   57,   57,   57,   58,   58,
   58,   58,   58,   96,   96,
};
const short yylen[] = {                                         2,
    2,    2,    0,    1,    2,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    7,    7,    1,
    3,    3,    5,    1,    2,    2,    2,    1,    1,    1,
    2,    1,    2,    2,    2,    1,    3,    1,    1,    1,
    2,    2,    2,    2,    2,    2,    2,    2,    3,    2,
    2,    3,    2,    2,    1,    2,    2,    2,    2,    2,
    2,    1,    1,    4,    4,    3,    3,    4,    6,    4,
    4,    4,    4,    3,    5,    5,    5,    2,    2,    3,
    3,    3,    3,    3,    1,    1,    2,    5,    1,    2,
    6,    2,    2,    2,    2,    2,    2,    3,    6,    2,
    2,    2,    2,    2,    2,    2,    2,    2,    1,    1,
    2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    3,    1,    3,    3,    1,    3,    1,    1,
    3,    7,    3,    1,    3,    3,    7,    1,    3,    1,
    3,    3,    1,    1,    3,    3,    3,    1,    1,    3,
    3,    1,    1,    3,    3,    3,    3,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    3,    3,    3,    3,    3,    5,    3,
    3,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,
};
const short yydefred[] = {                                      3,
    0,    2,   75,    0,  105,    0,    0,    0,    0,   37,
    0,    0,    0,    0,   44,    0,    0,    0,    0,    0,
    0,    0,  130,   52,   48,    0,    0,   49,   50,    1,
   22,   24,    0,    0,    0,    0,    9,    0,   11,   13,
   27,   29,   25,   26,    0,   23,   30,    0,   36,   14,
   15,   20,   16,   31,    0,   35,   28,    0,   19,    0,
   83,   32,   33,    0,  113,    0,  114,  116,    0,   81,
  137,  134,  135,  136,  121,  125,  126,   99,   98,    0,
    0,    0,    0,    0,    0,    0,    0,  122,    0,    0,
    0,    0,    0,  133,  127,  128,  123,  124,  271,  272,
   77,    0,   79,    0,   53,    0,   55,   76,  245,  247,
  190,  191,  189,  248,  160,    0,  185,  186,    0,  192,
  198,  199,  194,  197,  212,  195,  196,  193,  203,  213,
  210,  204,  211,  214,  142,    0,  182,  183,    0,  215,
  218,  216,  217,  219,    0,  144,  184,    0,  283,  284,
  273,    0,    0,    0,  268,  169,    0,  188,    0,  269,
  270,    0,  173,    0,   78,  178,  179,  180,  181,    0,
    0,    0,  220,    0,    0,  225,  221,  222,  223,  224,
  150,    0,    0,    0,   59,   58,    0,    0,    0,    0,
    0,    0,    0,  233,  234,  235,  236,    0,  237,    0,
    0,   94,   65,   66,   68,   67,    0,   74,   71,   70,
    0,   73,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   86,   87,    0,
    0,    0,    0,    0,    0,   63,   64,   61,   62,   90,
   84,   88,   85,    0,    0,    0,    0,   92,   93,   91,
  226,  228,  229,  230,  231,  227,  232,   69,   72,  177,
  285,  286,  287,  288,  176,  161,  162,  143,   59,  291,
  292,   58,  148,    0,  145,  146,    0,  275,  274,  276,
   40,    0,    0,    0,  170,  171,  174,  175,    0,    0,
    0,    0,    0,  109,  239,  240,  241,  155,  238,  243,
  244,  156,  242,    0,  151,  153,    0,   95,   96,   97,
    0,    0,    0,    0,    0,    0,  141,  131,  266,  251,
  252,  250,  253,  254,  258,  261,  262,  263,  264,  265,
  259,  255,  256,  257,  260,  267,  164,    0,  187,    0,
  119,    0,    0,  111,  110,    0,   89,  280,  278,  277,
  281,    0,   42,   41,    4,    0,    0,    0,    0,    0,
    0,    0,    0,   38,    5,    0,   39,  165,  166,  167,
    0,    0,    0,  158,  279,   43,  108,  294,  295,    0,
    0,  152,    0,  159,    0,    0,    0,  157,
};
const short yydgoto[] = {                                       1,
  318,   75,    0,  355,  356,   31,   32,   33,   34,   35,
   36,   37,   38,   39,   40,   41,   42,   43,   44,   45,
   46,   47,  290,   48,   49,  291,  293,  294,   50,   51,
   52,   53,   54,   55,   56,   57,   58,   59,   60,   61,
   62,   63,  135,  136,  145,  146,  115,  116,  337,  338,
  156,  157,  181,  182,  298,  302,  265,  273,  278,  151,
  152,  162,  163,  107,  101,  283,  284,    0,  274,  188,
   90,   91,  137,  117,  339,  138,  147,  118,  158,  153,
  139,  148,  119,  340,  159,  183,  299,  200,  303,  258,
  164,  102,  170,  373,  374,  380,
};
const short yysindex[] = {                                      0,
 -236,    0,    0,  -86,    0, -165, -139, -271,  141,    0,
 -123, -139, -184, -184,    0, -184, -135, -132, -115, -218,
 -218, -184,    0,    0,    0, -129, -152,    0,    0,    0,
    0,    0,  -84,  169, -195, -215,    0, -334,    0,    0,
    0,    0,    0,    0,  -90,    0,    0, -128,    0,    0,
    0,    0,    0,    0, -160,    0,    0, -218,    0,  -96,
    0,    0,    0, -334,    0,  169,    0,    0,  118,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, -184,
 -281, -184, -184, -184, -106,  -68, -150,    0,   -2, -173,
 -111, -111, -111,    0,    0,    0,    0,    0,    0,    0,
    0,  -94,    0, -111,    0,  -85,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  -53,    0,    0,  -22,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  -15,    0,    0,  -13,    0,
    0,    0,    0,    0,    4,    0,    0,   35,    0,    0,
    0,   45,   67,   68,    0,    0,   74,    0,   78,    0,
    0,  107,    0,   89,    0,    0,    0,    0,    0, -103,
    8,   21,    0,  111,  115,    0,    0,    0,    0,    0,
    0,  123,  124, -111,    0,    0, -168, -145, -111, -111,
 -111,  -70,  126,    0,    0,    0,    0,  131,    0,  142,
   70,    0,    0,    0,    0,    0,  -48,    0,    0,    0,
  -48,    0,  166,   76,  169,   76, -195,   94, -215,   94,
 -226,   76, -278, -128,   76, -160,   76,    0,    0,  196,
  173, -272,   72,    7,   94,    0,    0,    0,    0,    0,
    0,    0,    0,  184, -272,   72,   76,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, -168,    0,    0,  160,    0,    0,    0,
    0,  188,   59,  151,    0,    0,    0,    0,  193,  -47,
 -264,  169, -187,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  164,    0,    0,  165,    0,    0,    0,
   38,  172,  198,  -28,  177,  -28,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  189,    0,  181,
    0,  -47,  157,    0,    0,  187,    0,    0,    0,    0,
    0,  215,    0,    0,    0, -208,  216, -179,   86,   76,
  196,  192,  191,    0,    0,  194,    0,    0,    0,    0,
 -247,   32,   71,    0,    0,    0,    0,    0,    0,  200,
  192,    0,   32,    0,  202,   32,  201,    0,
};
const short yyrindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0, 1281,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, 1310, 1355, 1443, 1503,    0, 1532,    0,    0,
    0,    0,    0,    0, 1595,    0,    0, 1665,    0,    0,
    0,    0,    0,    0, 1694,    0,    0, 1733,    0, 1762,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 1827, 1895, 1924,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, 1984,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  687,    0,    0,  586,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  547,    0,    0,  411,    0,
    0,    0,    0,    0,  840,    0,    0,  777,    0,    0,
    0,  975,    0,    0,    0,    0, 1140,    0, 1005,    0,
    0, 1066,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, 2058, 1216, 2118,    0,    0, 2147,  135, 2209, 2280,
 2309,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  277,    0,    0,    1,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, -193,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0, 2298,    0, -147,
    0, -190,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,
};
const short yygindex[] = {                                      0,
    0,  499,    0,   -1,  203,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, -280,    0,    0,  156,    0,  225,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  303,    0,    0,  302,  309,  -64,  167,    0,
  301,    0,  293,    0,  283,  284, -213,  -93,  204,  310,
  468,    0,  327,    0,   90,    0,    0,    0,  455,    0,
    0,   92,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  351,
    0,    0,    0,    0,  183, -370,
};
#define YYTABLESIZE 2697
const short yytable[] = {                                      30,
  282,  172,  267,  185,  149,  289,  186,  281,  280,  150,
  342,  286,  385,  288,   76,  387,   77,  295,  296,    2,
    3,    4,  289,    5,    6,    7,    8,    9,   10,   11,
   12,   13,   14,  310,   15,   16,   17,   18,   19,  282,
   20,   21,   22,   23,   24,   25,   26,   27,    3,    4,
  341,    5,    6,    7,    8,    9,   10,   11,   12,   13,
   14,  277,   15,   16,   17,   18,   19,  377,   20,   21,
   22,   23,   24,   25,   26,   27,  106,    3,    4,  107,
    5,    6,    7,    8,    9,   10,   11,   12,   13,   14,
  342,   15,   16,   17,   18,   19,  297,   20,   21,   22,
   23,   24,   25,   26,   27,   92,  364,   93,   99,  201,
  103,  292,  149,  104,  205,  206,  236,  150,  207,  237,
   70,  106,  168,  140,  107,  202,  276,  344,  120,  121,
  122,  123,  124,   89,   60,  367,  125,  126,  127,  238,
  141,  306,  239,  128,  208,  142,  370,  165,  100,   94,
   28,   29,  143,   95,  129,   96,  144,   71,   72,   73,
  130,  131,  132,  133,   85,  168,   74,  168,   86,  134,
   97,  184,   98,  189,  190,  191,  209,  210,   28,   29,
  211,  105,  228,   64,  229,  108,   87,  168,  168,  168,
  168,  168,  168,  106,  168,  168,  168,  154,  168,  168,
  168,  168,  155,  168,  168,  168,  212,   28,   29,  192,
   65,   66,  160,  161,  240,  241,  242,  243,  168,   67,
   68,  213,   69,  166,  167,  168,  169,  343,    3,    4,
  214,    5,    6,    7,    8,    9,   10,   11,   12,   13,
   14,  168,   15,   16,   17,   18,   19,  244,   20,   21,
   22,   23,   24,   25,   26,   27,  282,  282,  282,  215,
  282,  282,  282,  282,  282,  282,  282,  282,  282,  282,
  282,  282,  282,  282,  282,  282,  289,  282,  282,  282,
  282,  282,  282,  282,  282,  203,  204,  319,  320,  321,
  322,  323,  324,  216,  325,  326,  327,  217,  328,  329,
  330,  331,  218,  332,  333,  334,  193,  194,  195,  196,
  197,  198,  199,  282,  282,  282,  219,  378,  335,  379,
  221,  230,  348,  349,  350,  351,  251,  252,  253,  254,
  255,  256,  257,  215,  231,  282,  282,  282,  282,  282,
  282,  336,  282,  282,  282,  173,  282,  282,  282,  282,
  220,  282,  282,  282,  365,  352,  365,  221,   28,   29,
  261,  262,  263,  264,  300,  301,  282,  174,  304,  175,
  176,  313,  314,  277,  177,  178,  179,  180,  269,  270,
  271,  272,  222,  381,  223,  382,  224,  282,  282,  282,
   60,   60,   60,  225,   60,   60,   60,   60,   60,   60,
   60,   60,   60,   60,  227,   60,   60,   60,   60,   60,
  149,   60,   60,   60,   60,   60,   60,   60,   60,  226,
  319,  320,  321,  322,  323,  324,  232,  325,  326,  327,
  233,  328,  329,  330,  331,  234,  332,  333,  334,  235,
   78,  245,   79,   80,   81,   82,  246,   60,   83,   60,
  260,  335,   84,  248,  249,  250,  173,  247,   60,   60,
   60,   60,   60,  315,  316,  289,   60,   60,   60,  215,
  361,  292,  307,   60,  336,  311,  312,  317,  174,  346,
  175,  176,  347,  354,   60,  177,  178,  179,  180,  353,
   60,   60,   60,   60,  357,   60,  360,  109,  110,   60,
  362,  359,   60,  363,  366,  372,   60,  111,  375,  112,
   88,  376,  383,  113,  386,  388,  371,  345,  358,  268,
  275,   60,   60,  266,  285,  368,  305,  308,  114,  309,
  279,  171,  289,  289,  289,  187,  289,  289,  289,  289,
  289,  289,  289,  289,  289,  289,  115,  289,  289,  289,
  289,  289,  287,  289,  289,  289,  289,  289,  289,  289,
  289,  259,  369,  384,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  163,    0,    0,    0,  289,
    0,  289,    0,    0,    0,    0,    0,    0,    0,    0,
  289,  289,  289,  289,  289,    0,    0,    0,  289,  289,
  289,    0,    0,    0,    0,  289,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  289,    0,    0,    0,
    0,    0,  289,  289,  289,  289,    0,  289,    0,    0,
    0,  289,    0,    0,  289,    0,    0,    0,  289,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  289,  289,    0,  149,  149,  149,    0,
  149,  149,  149,  149,  149,  149,  149,  149,  149,  149,
    0,  149,  149,  149,  149,  149,  112,  149,  149,  149,
  149,  149,  149,  149,  149,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  149,    0,  149,    0,    0,    0,    0,
    0,    0,    0,    0,  149,  149,  149,  149,  149,    0,
    0,    0,  149,  149,  149,    0,    0,    0,    0,  149,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  149,    0,    0,    0,    0,    0,  149,  149,  149,  149,
    0,    0,    0,    0,    0,  149,  147,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  149,  149,    0,
    0,    0,  115,  115,  115,    0,  115,  115,  115,  115,
  115,  115,  115,  115,  115,  115,    0,  115,  115,  115,
  115,  115,    0,  115,  115,  115,  115,  115,  115,  115,
  115,    0,    0,    0,    0,    0,    0,    0,    0,  117,
    0,  163,  163,  163,    0,  163,  163,  163,  163,  163,
  163,  163,  163,  163,  163,    0,  163,  163,  163,  163,
  163,  115,  163,  163,  163,  163,  163,  163,  163,  163,
  115,  115,  115,  115,  115,    0,    0,    0,  115,  115,
  115,    0,    0,    0,    0,  115,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  115,    0,  163,  163,
  163,    0,  115,  115,  115,  115,    0,    0,    0,    0,
    0,  115,    0,    0,  163,  163,    0,    0,    0,    0,
    0,    0,    0,    0,  163,    0,  163,    0,    0,    0,
  163,    0,    0,  115,  115,    0,    0,    0,    0,    0,
    0,    0,  112,  112,  112,  163,  112,  112,  112,  112,
  112,  112,  112,  112,  112,  112,    0,  112,  112,  112,
  112,  112,    0,  112,  112,  112,  112,  112,  112,  112,
  112,    0,  163,  163,  120,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  112,    0,    0,  172,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  112,  112,    0,    0,    0,
    0,    0,    0,    0,    0,  112,    0,  112,    0,    0,
    0,  112,  147,  147,  147,    0,  147,  147,  147,  147,
  147,  147,  147,  147,  147,  147,  112,  147,  147,  147,
  147,  147,    0,  147,  147,  147,  147,  147,  147,  147,
  147,    0,    0,    0,    0,   54,    0,    0,    0,    0,
    0,    0,    0,  112,  112,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  147,
    0,  147,    0,    0,    0,  117,  117,  117,    0,  117,
  117,  117,  117,  117,  117,  117,  117,  117,  117,    0,
  117,  117,  117,  117,  117,  147,  117,  117,  117,  117,
  117,  117,  117,  117,    0,    0,    0,    0,    0,    0,
    0,    0,  147,    0,    0,    0,    0,  147,    0,   45,
    0,    0,    0,    0,  147,    0,    0,    0,  147,    0,
    0,    0,    0,    0,  117,    0,    0,    0,    0,    0,
    0,    0,    0,  147,  147,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  117,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  117,    0,    0,    0,    0,
  117,    0,    0,    0,    0,    0,    0,  117,    0,    0,
    0,  117,    0,    0,    0,  154,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  117,  117,    0,    0,
  120,  120,  120,    0,  120,  120,  120,  120,  120,  120,
  120,  120,  120,  120,    0,  120,  120,  120,  120,  120,
    0,  120,  120,  120,  120,  120,  120,  120,  120,    0,
  172,  172,  172,    0,  172,  172,  172,  172,  172,  172,
  172,  172,  172,  172,    0,  172,  172,  172,  172,  172,
  129,  172,  172,  172,  172,  172,  172,  172,  172,  120,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   21,
    0,    0,    0,  120,    0,    0,    0,  172,  120,  172,
    0,   54,   54,   54,    0,   54,   54,   54,   54,   54,
   54,   54,   54,   54,   54,  172,   54,   54,   54,   54,
   54,    0,   54,   54,   54,   54,   54,   54,   54,   54,
    0,    0,    0,    0,    6,    0,    0,    0,    0,    0,
    0,  120,  120,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   54,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  172,  172,    0,    0,   45,   45,   45,    0,   45,
   45,   45,   45,   45,   45,   45,   45,   45,   45,    0,
   45,   45,   45,   45,   45,    0,   45,   45,   45,   45,
   45,   45,   45,   45,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   54,   54,
    0,    0,    7,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   54,   54,   45,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   45,  154,  154,  154,    0,  154,  154,  154,  154,  154,
  154,  154,  154,  154,  154,    0,  154,  154,  154,  154,
  154,    0,  154,  154,  154,  154,  154,  154,  154,  154,
    0,    0,    8,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   45,   45,  154,    0,
  154,   10,    0,    0,    0,    0,  129,  129,  129,    0,
  129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
    0,  129,  129,  129,  129,  129,    0,  129,  129,  129,
  129,  129,  129,  129,  129,   21,   21,   21,    0,   21,
   21,   21,   21,   21,   21,   21,   21,   21,   21,    0,
   21,   21,   21,   21,   21,    0,   21,   21,   21,   21,
   21,   21,   21,   21,   17,  129,    0,    0,    0,    0,
    0,    0,  154,  154,    0,    0,    0,    0,    0,    0,
    6,    6,    6,    0,    6,    6,    6,    6,    6,    6,
    6,    6,    6,    6,   21,    6,    6,    6,    6,    6,
    0,    6,    6,    6,    6,    6,    6,    6,    6,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   12,    0,    0,  129,  129,    6,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   34,    0,    0,   21,   21,    7,    7,
    7,    0,    7,    7,    7,    7,    7,    7,    7,    7,
    7,    7,    0,    7,    7,    7,    7,    7,    0,    7,
    7,    7,    7,    7,    7,    7,    7,    0,    0,    0,
    0,    0,   18,    0,    0,    0,    0,    0,    0,    0,
    0,    6,    6,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    7,    8,    8,
    8,   82,    8,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    0,    8,    8,    8,    8,    8,    0,    8,
    8,    8,    8,    8,    8,    8,    8,   10,   10,   10,
    0,   10,   10,   10,   10,   10,   10,   10,   10,   10,
   10,    0,   10,   10,   10,   10,   10,    0,   10,   10,
   10,   10,   10,   10,   10,   10,    0,    8,    0,    0,
    0,    0,    0,    0,    0,    0,   80,    0,    0,    7,
    7,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   10,    0,    0,    0,
   17,   17,   17,    0,   17,   17,   17,   17,   17,   17,
   17,   17,   17,   17,    0,   17,   17,   17,   17,   17,
    0,   17,   17,   17,   17,   17,   17,   17,   17,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    8,
    8,    0,    0,    0,   46,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   17,
    0,    0,    0,    0,    0,    0,    0,    0,   10,   10,
   12,   12,   12,   47,   12,   12,   12,   12,   12,   12,
   12,   12,   12,   12,    0,   12,   12,   12,   12,   12,
    0,   12,   12,   12,   12,   12,   12,   12,   12,   34,
   34,   34,    0,   34,   34,   34,   34,   34,   34,   34,
   34,   34,   34,    0,   34,   34,   34,   34,   34,    0,
   34,   34,   34,   34,   34,   34,   34,   34,    0,   12,
    0,   17,   17,   51,    0,    0,    0,    0,   18,   18,
   18,    0,   18,   18,   18,   18,   18,   18,   18,   18,
   18,   18,    0,   18,   18,   18,   18,   18,   34,   18,
   18,   18,   18,   18,   18,   18,   18,   82,   82,   82,
    0,   82,   82,   82,   82,   82,   82,   82,   82,   82,
   82,    0,   82,   82,   82,   82,   82,    0,   82,   82,
   82,   82,   82,   82,   82,   82,    0,   18,    0,    0,
    0,   12,   12,    0,    0,    0,    0,  118,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   82,    0,    0,    0,
   34,   34,   80,   80,   80,    0,   80,   80,   80,   80,
   80,   80,   80,   80,   80,   80,    0,   80,   80,   80,
   80,   80,    0,   80,   80,   80,   80,   80,   80,   80,
   80,    0,    0,    0,    0,    0,    0,  102,    0,   18,
   18,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   80,    0,    0,    0,    0,  100,    0,   82,   82,
   46,   46,   46,    0,   46,   46,   46,   46,   46,   46,
   46,   46,   46,   46,    0,   46,   46,   46,   46,   46,
    0,   46,   46,   46,   46,   46,   46,   46,   46,   47,
   47,   47,    0,   47,   47,   47,   47,   47,   47,   47,
   47,   47,   47,    0,   47,   47,   47,   47,   47,    0,
   47,   47,   47,   47,   47,   47,   47,   47,  101,   46,
    0,    0,    0,   80,   80,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   47,   51,
   51,   51,    0,   51,   51,   51,   51,   51,   51,   51,
   51,   51,   51,    0,   51,   51,   51,   51,   51,    0,
   51,   51,   51,   51,   51,   51,   51,   51,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  103,
    0,   46,   46,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   51,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  104,    0,
   47,   47,    0,  118,  118,  118,    0,  118,  118,  118,
  118,  118,  118,  118,  118,  118,  118,    0,  118,  118,
  118,  118,  118,    0,  118,  118,  118,  118,  118,  118,
  118,  118,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   51,   51,  118,  102,  102,  102,    0,  102,  102,  102,
  102,  102,  102,  102,  102,  102,  102,    0,  102,  102,
  102,  102,  102,    0,  102,  102,  102,  102,  102,  102,
  102,  102,  100,  100,  100,    0,  100,  100,  100,  100,
  100,  100,  100,  100,  100,  100,    0,  100,  100,  100,
  100,  100,    0,  100,  100,  100,  100,  100,  100,  100,
  100,    0,  102,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  118,  118,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  100,    0,    0,  101,  101,  101,    0,  101,  101,
  101,  101,  101,  101,  101,  101,  101,  101,    0,  101,
  101,  101,  101,  101,    0,  101,  101,  101,  101,  101,
  101,  101,  101,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  102,  102,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  101,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  100,  100,  103,  103,  103,    0,  103,
  103,  103,  103,  103,  103,  103,  103,  103,  103,    0,
  103,  103,  103,  103,  103,    0,  103,  103,  103,  103,
  103,  103,  103,  103,  104,  104,  104,  132,  104,  104,
  104,  104,  104,  104,  104,  104,  104,  104,    0,  104,
  104,  104,  104,  104,    0,  104,  104,  104,  104,  104,
  104,  104,  104,    0,  103,  101,  101,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  132,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  104,    0,    0,    0,    0,    0,    0,
    0,    0,  132,  132,  132,  132,  132,  132,    0,  132,
  132,  132,    0,  132,  132,  132,  132,    0,  132,  132,
  132,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  132,    0,    0,  103,  103,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  132,    0,    0,    0,
    0,    0,    0,    0,    0,  104,  104,
};
const short yycheck[] = {                                       1,
    0,   66,  216,  285,  339,  270,  288,  286,  222,  344,
  291,  225,  383,  227,  286,  386,  288,  290,  291,  256,
  257,  258,  270,  260,  261,  262,  263,  264,  265,  266,
  267,  268,  269,  247,  271,  272,  273,  274,  275,  318,
  277,  278,  279,  280,  281,  282,  283,  284,  257,  258,
  315,  260,  261,  262,  263,  264,  265,  266,  267,  268,
  269,  288,  271,  272,  273,  274,  275,  315,  277,  278,
  279,  280,  281,  282,  283,  284,  270,  257,  258,  270,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
  371,  271,  272,  273,  274,  275,  369,  277,  278,  279,
  280,  281,  282,  283,  284,   14,  315,   16,  327,  260,
   21,  299,  339,   22,  288,  289,  285,  344,  292,  288,
  286,  315,  270,  339,  315,  276,  220,  315,  324,  325,
  326,  327,  328,  318,    0,  315,  332,  333,  334,  285,
  356,  235,  288,  339,  318,  361,  360,   58,  367,  285,
  387,  388,  368,  286,  350,  288,  372,  297,  298,  299,
  356,  357,  358,  359,  288,  313,  306,  315,  292,  365,
  286,   80,  288,   82,   83,   84,  288,  289,  387,  388,
  292,  311,  286,  270,  288,  270,  310,  335,  336,  337,
  338,  339,  340,  346,  342,  343,  344,  288,  346,  347,
  348,  349,  331,  351,  352,  353,  318,  387,  388,  316,
  297,  298,  373,  374,  285,  286,  287,  288,  366,  306,
  307,  316,  309,  320,  321,  322,  323,  292,  257,  258,
  316,  260,  261,  262,  263,  264,  265,  266,  267,  268,
  269,  389,  271,  272,  273,  274,  275,  318,  277,  278,
  279,  280,  281,  282,  283,  284,  256,  257,  258,  313,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
  270,  271,  272,  273,  274,  275,    0,  277,  278,  279,
  280,  281,  282,  283,  284,  288,  289,  335,  336,  337,
  338,  339,  340,  316,  342,  343,  344,  313,  346,  347,
  348,  349,  316,  351,  352,  353,  375,  376,  377,  378,
  379,  380,  381,  313,  314,  315,  313,  286,  366,  288,
  313,  314,  285,  286,  287,  288,  375,  376,  377,  378,
  379,  380,  381,  313,  314,  335,  336,  337,  338,  339,
  340,  389,  342,  343,  344,  339,  346,  347,  348,  349,
  316,  351,  352,  353,  356,  318,  358,  313,  387,  388,
  285,  286,  287,  288,  293,  294,  366,  361,  362,  363,
  364,  313,  314,  288,  368,  369,  370,  371,  285,  286,
  287,  288,  316,  313,  317,  315,  313,  387,  388,  389,
  256,  257,  258,  316,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,  316,  271,  272,  273,  274,  275,
    0,  277,  278,  279,  280,  281,  282,  283,  284,  313,
  335,  336,  337,  338,  339,  340,  316,  342,  343,  344,
  316,  346,  347,  348,  349,  313,  351,  352,  353,  316,
  300,  316,  302,  303,  304,  305,  316,  313,  308,  315,
  285,  366,  312,  384,  385,  386,  339,  316,  324,  325,
  326,  327,  328,  313,  314,  270,  332,  333,  334,  313,
  314,  299,  289,  339,  389,  316,  289,  285,  361,  316,
  363,  364,  318,  286,  350,  368,  369,  370,  371,  318,
  356,  357,  358,  359,  318,  361,  316,  329,  330,  365,
  314,  313,  368,  289,  289,  314,  372,  339,  318,  341,
   12,  318,  313,  345,  313,  315,  361,  293,  316,  217,
  219,  387,  388,  215,  224,  359,  234,  245,  360,  246,
  221,   64,  256,  257,  258,   81,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,    0,  271,  272,  273,
  274,  275,  226,  277,  278,  279,  280,  281,  282,  283,
  284,  211,  359,  381,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,  313,
   -1,  315,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  324,  325,  326,  327,  328,   -1,   -1,   -1,  332,  333,
  334,   -1,   -1,   -1,   -1,  339,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  350,   -1,   -1,   -1,
   -1,   -1,  356,  357,  358,  359,   -1,  361,   -1,   -1,
   -1,  365,   -1,   -1,  368,   -1,   -1,   -1,  372,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  387,  388,   -1,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,    0,  277,  278,  279,
  280,  281,  282,  283,  284,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  313,   -1,  315,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  324,  325,  326,  327,  328,   -1,
   -1,   -1,  332,  333,  334,   -1,   -1,   -1,   -1,  339,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  350,   -1,   -1,   -1,   -1,   -1,  356,  357,  358,  359,
   -1,   -1,   -1,   -1,   -1,  365,    0,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,
   -1,   -1,  256,  257,  258,   -1,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,   -1,  271,  272,  273,
  274,  275,   -1,  277,  278,  279,  280,  281,  282,  283,
  284,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,    0,
   -1,  256,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,   -1,  271,  272,  273,  274,
  275,  315,  277,  278,  279,  280,  281,  282,  283,  284,
  324,  325,  326,  327,  328,   -1,   -1,   -1,  332,  333,
  334,   -1,   -1,   -1,   -1,  339,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  350,   -1,  313,  314,
  315,   -1,  356,  357,  358,  359,   -1,   -1,   -1,   -1,
   -1,  365,   -1,   -1,  329,  330,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  339,   -1,  341,   -1,   -1,   -1,
  345,   -1,   -1,  387,  388,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  256,  257,  258,  360,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,   -1,  271,  272,  273,
  274,  275,   -1,  277,  278,  279,  280,  281,  282,  283,
  284,   -1,  387,  388,    0,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  315,   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  329,  330,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  339,   -1,  341,   -1,   -1,
   -1,  345,  256,  257,  258,   -1,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,  360,  271,  272,  273,
  274,  275,   -1,  277,  278,  279,  280,  281,  282,  283,
  284,   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  387,  388,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  313,
   -1,  315,   -1,   -1,   -1,  256,  257,  258,   -1,  260,
  261,  262,  263,  264,  265,  266,  267,  268,  269,   -1,
  271,  272,  273,  274,  275,  339,  277,  278,  279,  280,
  281,  282,  283,  284,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  356,   -1,   -1,   -1,   -1,  361,   -1,    0,
   -1,   -1,   -1,   -1,  368,   -1,   -1,   -1,  372,   -1,
   -1,   -1,   -1,   -1,  315,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  387,  388,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  339,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  356,   -1,   -1,   -1,   -1,
  361,   -1,   -1,   -1,   -1,   -1,   -1,  368,   -1,   -1,
   -1,  372,   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,   -1,   -1,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,   -1,  271,  272,  273,  274,  275,
   -1,  277,  278,  279,  280,  281,  282,  283,  284,   -1,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,   -1,  271,  272,  273,  274,  275,
    0,  277,  278,  279,  280,  281,  282,  283,  284,  315,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,    0,
   -1,   -1,   -1,  339,   -1,   -1,   -1,  313,  344,  315,
   -1,  256,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,  331,  271,  272,  273,  274,
  275,   -1,  277,  278,  279,  280,  281,  282,  283,  284,
   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,
   -1,  387,  388,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  315,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  387,  388,   -1,   -1,  256,  257,  258,   -1,  260,
  261,  262,  263,  264,  265,  266,  267,  268,  269,   -1,
  271,  272,  273,  274,  275,   -1,  277,  278,  279,  280,
  281,  282,  283,  284,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  373,  374,
   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  387,  388,  315,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  331,  256,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,  268,  269,   -1,  271,  272,  273,  274,
  275,   -1,  277,  278,  279,  280,  281,  282,  283,  284,
   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,  313,   -1,
  315,    0,   -1,   -1,   -1,   -1,  256,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
   -1,  271,  272,  273,  274,  275,   -1,  277,  278,  279,
  280,  281,  282,  283,  284,  256,  257,  258,   -1,  260,
  261,  262,  263,  264,  265,  266,  267,  268,  269,   -1,
  271,  272,  273,  274,  275,   -1,  277,  278,  279,  280,
  281,  282,  283,  284,    0,  315,   -1,   -1,   -1,   -1,
   -1,   -1,  387,  388,   -1,   -1,   -1,   -1,   -1,   -1,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,  315,  271,  272,  273,  274,  275,
   -1,  277,  278,  279,  280,  281,  282,  283,  284,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,    0,   -1,   -1,  387,  388,  315,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,    0,   -1,   -1,  387,  388,  256,  257,
  258,   -1,  260,  261,  262,  263,  264,  265,  266,  267,
  268,  269,   -1,  271,  272,  273,  274,  275,   -1,  277,
  278,  279,  280,  281,  282,  283,  284,   -1,   -1,   -1,
   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  387,  388,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  315,  256,  257,
  258,    0,  260,  261,  262,  263,  264,  265,  266,  267,
  268,  269,   -1,  271,  272,  273,  274,  275,   -1,  277,
  278,  279,  280,  281,  282,  283,  284,  256,  257,  258,
   -1,  260,  261,  262,  263,  264,  265,  266,  267,  268,
  269,   -1,  271,  272,  273,  274,  275,   -1,  277,  278,
  279,  280,  281,  282,  283,  284,   -1,  315,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,    0,   -1,   -1,  387,
  388,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  315,   -1,   -1,   -1,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,   -1,  271,  272,  273,  274,  275,
   -1,  277,  278,  279,  280,  281,  282,  283,  284,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,
  388,   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  315,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  387,  388,
  256,  257,  258,    0,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,   -1,  271,  272,  273,  274,  275,
   -1,  277,  278,  279,  280,  281,  282,  283,  284,  256,
  257,  258,   -1,  260,  261,  262,  263,  264,  265,  266,
  267,  268,  269,   -1,  271,  272,  273,  274,  275,   -1,
  277,  278,  279,  280,  281,  282,  283,  284,   -1,  315,
   -1,  387,  388,    0,   -1,   -1,   -1,   -1,  256,  257,
  258,   -1,  260,  261,  262,  263,  264,  265,  266,  267,
  268,  269,   -1,  271,  272,  273,  274,  275,  315,  277,
  278,  279,  280,  281,  282,  283,  284,  256,  257,  258,
   -1,  260,  261,  262,  263,  264,  265,  266,  267,  268,
  269,   -1,  271,  272,  273,  274,  275,   -1,  277,  278,
  279,  280,  281,  282,  283,  284,   -1,  315,   -1,   -1,
   -1,  387,  388,   -1,   -1,   -1,   -1,    0,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  315,   -1,   -1,   -1,
  387,  388,  256,  257,  258,   -1,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,   -1,  271,  272,  273,
  274,  275,   -1,  277,  278,  279,  280,  281,  282,  283,
  284,   -1,   -1,   -1,   -1,   -1,   -1,    0,   -1,  387,
  388,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  315,   -1,   -1,   -1,   -1,    0,   -1,  387,  388,
  256,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,   -1,  271,  272,  273,  274,  275,
   -1,  277,  278,  279,  280,  281,  282,  283,  284,  256,
  257,  258,   -1,  260,  261,  262,  263,  264,  265,  266,
  267,  268,  269,   -1,  271,  272,  273,  274,  275,   -1,
  277,  278,  279,  280,  281,  282,  283,  284,    0,  315,
   -1,   -1,   -1,  387,  388,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  315,  256,
  257,  258,   -1,  260,  261,  262,  263,  264,  265,  266,
  267,  268,  269,   -1,  271,  272,  273,  274,  275,   -1,
  277,  278,  279,  280,  281,  282,  283,  284,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,    0,
   -1,  387,  388,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  315,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,    0,   -1,
  387,  388,   -1,  256,  257,  258,   -1,  260,  261,  262,
  263,  264,  265,  266,  267,  268,  269,   -1,  271,  272,
  273,  274,  275,   -1,  277,  278,  279,  280,  281,  282,
  283,  284,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  387,  388,  315,  256,  257,  258,   -1,  260,  261,  262,
  263,  264,  265,  266,  267,  268,  269,   -1,  271,  272,
  273,  274,  275,   -1,  277,  278,  279,  280,  281,  282,
  283,  284,  256,  257,  258,   -1,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,   -1,  271,  272,  273,
  274,  275,   -1,  277,  278,  279,  280,  281,  282,  283,
  284,   -1,  315,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  387,  388,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  315,   -1,   -1,  256,  257,  258,   -1,  260,  261,
  262,  263,  264,  265,  266,  267,  268,  269,   -1,  271,
  272,  273,  274,  275,   -1,  277,  278,  279,  280,  281,
  282,  283,  284,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  387,  388,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  315,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  387,  388,  256,  257,  258,   -1,  260,
  261,  262,  263,  264,  265,  266,  267,  268,  269,   -1,
  271,  272,  273,  274,  275,   -1,  277,  278,  279,  280,
  281,  282,  283,  284,  256,  257,  258,  270,  260,  261,
  262,  263,  264,  265,  266,  267,  268,  269,   -1,  271,
  272,  273,  274,  275,   -1,  277,  278,  279,  280,  281,
  282,  283,  284,   -1,  315,  387,  388,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  315,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  315,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  335,  336,  337,  338,  339,  340,   -1,  342,
  343,  344,   -1,  346,  347,  348,  349,   -1,  351,  352,
  353,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  366,   -1,   -1,  387,  388,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  389,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  387,  388,
};
#define YYFINAL 1
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 389
#if YYDEBUG
const char * const yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"FSC_LIST","FSC_DEFINE",
"FSC_EXEC","FSC_QUIT","FSC_DEBUG","FSC_CREATE","FSC_SLEEP","FSC_STATS",
"FSC_FOREACH","FSC_SET","FSC_SHUTDOWN","FSC_LOG","FSC_SYSTEM","FSC_FLOWOP",
"FSC_EVENTGEN","FSC_ECHO","FSC_LOAD","FSC_RUN","FSC_WARMUP","FSC_NOUSESTATS",
"FSC_FSCHECK","FSC_FSFLUSH","FSC_USAGE","FSC_HELP","FSC_VARS","FSC_VERSION",
"FSC_ENABLE","FSC_DOMULTISYNC","FSV_STRING","FSV_VAL_INT","FSV_VAL_BOOLEAN",
"FSV_VARIABLE","FSV_WHITESTRING","FSV_RANDUNI","FSV_RANDTAB","FSV_RANDVAR",
"FSV_URAND","FSV_RAND48","FST_INT","FST_BOOLEAN","FSE_FILE","FSE_PROC",
"FSE_THREAD","FSE_CLEAR","FSE_ALL","FSE_SNAP","FSE_DUMP","FSE_DIRECTORY",
"FSE_COMMAND","FSE_FILESET","FSE_POSSET","FSE_XMLDUMP","FSE_RAND","FSE_MODE",
"FSE_MULTI","FSE_MULTIDUMP","FSK_SEPLST","FSK_OPENLST","FSK_CLOSELST",
"FSK_ASSIGN","FSK_IN","FSK_QUOTE","FSK_DIRSEPLST","FSK_PLUS","FSK_MINUS",
"FSK_MULTIPLY","FSK_DIVIDE","FSA_SIZE","FSA_PREALLOC","FSA_PARALLOC","FSA_PATH",
"FSA_REUSE","FSA_PROCESS","FSA_MEMSIZE","FSA_RATE","FSA_CACHED","FSA_READONLY",
"FSA_TRUSTTREE","FSA_IOSIZE","FSA_FILE","FSA_POSSET","FSA_WSS","FSA_NAME",
"FSA_RANDOM","FSA_INSTANCES","FSA_DSYNC","FSA_TARGET","FSA_ITERS","FSA_NICE",
"FSA_VALUE","FSA_BLOCKING","FSA_HIGHWATER","FSA_DIRECTIO","FSA_DIRWIDTH",
"FSA_FD","FSA_SRCFD","FSA_ROTATEFD","FSA_NAMELENGTH","FSA_FILESIZE",
"FSA_ENTRIES","FSA_FILESIZEGAMMA","FSA_DIRDEPTHRV","FSA_DIRGAMMA","FSA_USEISM",
"FSA_TYPE","FSA_RANDTABLE","FSA_RANDSRC","FSA_RANDROUND","FSA_LEAFDIRS",
"FSA_INDEXED","FSA_FSTYPE","FSA_RANDSEED","FSA_RANDGAMMA","FSA_RANDMEAN",
"FSA_RANDMIN","FSA_RANDMAX","FSA_MASTER","FSA_CLIENT","FSS_TYPE","FSS_SEED",
"FSS_GAMMA","FSS_MEAN","FSS_MIN","FSS_SRC","FSS_ROUND","FSV_SET_LOCAL_VAR",
"FSA_LVAR_ASSIGN","FSA_ALLDONE","FSA_FIRSTDONE","FSA_TIMEOUT",
"FSC_OSPROF_ENABLE","FSC_OSPROF_DISABLE","FSA_NOREADAHEAD",
};
const char * const yyrule[] = {
"$accept : commands",
"commands : commands command",
"commands : commands error",
"commands :",
"inner_commands : command",
"inner_commands : inner_commands command",
"command : proc_define_command",
"command : files_define_command",
"command : posset_define_command",
"command : randvar_define_command",
"command : fo_define_command",
"command : debug_command",
"command : eventgen_command",
"command : create_command",
"command : echo_command",
"command : usage_command",
"command : vars_command",
"command : foreach_command",
"command : fscheck_command",
"command : fsflush_command",
"command : help_command",
"command : list_command",
"command : load_command",
"command : log_command",
"command : run_command",
"command : set_command",
"command : shutdown_command",
"command : sleep_command",
"command : warmup_command",
"command : stats_command",
"command : system_command",
"command : version_command",
"command : osprof_enable_command",
"command : osprof_disable_command",
"command : enable_command",
"command : multisync_command",
"command : quit_command",
"foreach_command : FSC_FOREACH",
"foreach_command : foreach_command FSV_VARIABLE FSK_IN integer_seplist FSK_OPENLST inner_commands FSK_CLOSELST",
"foreach_command : foreach_command FSV_VARIABLE FSK_IN string_seplist FSK_OPENLST inner_commands FSK_CLOSELST",
"integer_seplist : FSV_VAL_INT",
"integer_seplist : integer_seplist FSK_SEPLST FSV_VAL_INT",
"string_seplist : FSK_QUOTE FSV_WHITESTRING FSK_QUOTE",
"string_seplist : string_seplist FSK_SEPLST FSK_QUOTE FSV_WHITESTRING FSK_QUOTE",
"eventgen_command : FSC_EVENTGEN",
"eventgen_command : eventgen_command ev_attr_ops",
"system_command : FSC_SYSTEM whitevar_string_list",
"echo_command : FSC_ECHO whitevar_string_list",
"version_command : FSC_VERSION",
"osprof_enable_command : FSC_OSPROF_ENABLE",
"osprof_disable_command : FSC_OSPROF_DISABLE",
"usage_command : FSC_USAGE whitevar_string_list",
"vars_command : FSC_VARS",
"enable_command : FSC_ENABLE FSE_MULTI",
"enable_command : enable_command enable_multi_ops",
"multisync_command : FSC_DOMULTISYNC multisync_op",
"string_list : FSV_VARIABLE",
"string_list : string_list FSK_SEPLST FSV_VARIABLE",
"var_string : FSV_VARIABLE",
"var_string : FSV_STRING",
"var_string_list : var_string",
"var_string_list : var_string FSV_STRING",
"var_string_list : var_string FSV_VARIABLE",
"var_string_list : var_string_list FSV_STRING",
"var_string_list : var_string_list FSV_VARIABLE",
"whitevar_string : FSK_QUOTE FSV_VARIABLE",
"whitevar_string : FSK_QUOTE FSV_WHITESTRING",
"whitevar_string_list : whitevar_string FSV_WHITESTRING",
"whitevar_string_list : whitevar_string FSV_VARIABLE",
"whitevar_string_list : whitevar_string FSV_RANDVAR randvar_attr_tsp",
"whitevar_string_list : whitevar_string_list FSV_WHITESTRING",
"whitevar_string_list : whitevar_string_list FSV_VARIABLE",
"whitevar_string_list : whitevar_string_list FSV_RANDVAR randvar_attr_tsp",
"whitevar_string_list : whitevar_string_list FSK_QUOTE",
"whitevar_string_list : whitevar_string FSK_QUOTE",
"list_command : FSC_LIST",
"list_command : list_command FSC_FLOWOP",
"fscheck_command : FSC_FSCHECK fscheck_attr_op",
"fscheck_command : fscheck_command fscheck_attr_op",
"fsflush_command : FSC_FSFLUSH fscheck_attr_op",
"log_command : FSC_LOG whitevar_string_list",
"debug_command : FSC_DEBUG FSV_VAL_INT",
"set_command : set_integer_command",
"set_command : set_other_command",
"set_integer_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSV_VAL_INT",
"set_integer_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSV_VARIABLE",
"set_integer_command : set_integer_command binary_op FSV_VAL_INT",
"set_integer_command : set_integer_command binary_op FSV_VARIABLE",
"set_other_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSV_VAL_BOOLEAN",
"set_other_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSK_QUOTE FSV_WHITESTRING FSK_QUOTE",
"set_other_command : FSC_SET FSV_VARIABLE FSK_ASSIGN FSV_STRING",
"set_other_command : FSC_SET FSE_MODE FSC_QUIT FSA_TIMEOUT",
"set_other_command : FSC_SET FSE_MODE FSC_QUIT FSA_ALLDONE",
"set_other_command : FSC_SET FSE_MODE FSC_QUIT FSA_FIRSTDONE",
"set_other_command : FSC_SET FSE_MODE FSC_NOUSESTATS",
"set_other_command : FSC_SET FSV_RANDVAR FSS_TYPE FSK_ASSIGN randvar_attr_typop",
"set_other_command : FSC_SET FSV_RANDVAR FSS_SRC FSK_ASSIGN randvar_attr_srcop",
"set_other_command : FSC_SET FSV_RANDVAR randvar_attr_param FSK_ASSIGN attr_value",
"stats_command : FSC_STATS FSE_SNAP",
"stats_command : FSC_STATS FSE_CLEAR",
"stats_command : FSC_STATS FSE_DIRECTORY var_string_list",
"stats_command : FSC_STATS FSE_COMMAND whitevar_string_list",
"stats_command : FSC_STATS FSE_DUMP whitevar_string_list",
"stats_command : FSC_STATS FSE_XMLDUMP whitevar_string_list",
"stats_command : FSC_STATS FSE_MULTIDUMP whitevar_string_list",
"quit_command : FSC_QUIT",
"flowop_list : flowop_command",
"flowop_list : flowop_list flowop_command",
"thread : FSE_THREAD pt_attr_ops FSK_OPENLST flowop_list FSK_CLOSELST",
"thread_list : thread",
"thread_list : thread_list thread",
"proc_define_command : FSC_DEFINE FSE_PROC pt_attr_ops FSK_OPENLST thread_list FSK_CLOSELST",
"proc_define_command : proc_define_command pt_attr_ops",
"files_define_command : FSC_DEFINE FSE_FILE",
"files_define_command : FSC_DEFINE FSE_FILESET",
"files_define_command : files_define_command files_attr_ops",
"posset_define_command : FSC_DEFINE FSE_POSSET",
"posset_define_command : posset_define_command posset_attr_ops",
"randvar_define_command : FSC_DEFINE FSE_RAND randvar_attr_ops",
"fo_define_command : FSC_DEFINE FSC_FLOWOP comp_attr_ops FSK_OPENLST flowop_list FSK_CLOSELST",
"fo_define_command : fo_define_command comp_attr_ops",
"create_command : FSC_CREATE entity",
"shutdown_command : FSC_SHUTDOWN entity",
"warmup_command : FSC_WARMUP FSV_VAL_INT",
"warmup_command : FSC_WARMUP FSV_VARIABLE",
"sleep_command : FSC_SLEEP FSV_VAL_INT",
"sleep_command : FSC_SLEEP FSV_VARIABLE",
"run_command : FSC_RUN FSV_VAL_INT",
"run_command : FSC_RUN FSV_VARIABLE",
"run_command : FSC_RUN",
"help_command : FSC_HELP",
"flowop_command : FSC_FLOWOP name",
"flowop_command : flowop_command fo_attr_ops",
"load_command : FSC_LOAD FSV_STRING",
"entity : FSE_PROC",
"entity : FSE_THREAD",
"entity : FSE_FILESET",
"entity : FSE_FILE",
"value : FSV_VAL_INT",
"value : FSV_STRING",
"value : FSV_VAL_BOOLEAN",
"name : FSV_STRING",
"files_attr_ops : files_attr_op",
"files_attr_ops : files_attr_ops FSK_SEPLST files_attr_op",
"posset_attr_ops : posset_attr_op",
"posset_attr_ops : posset_attr_ops FSK_SEPLST posset_attr_op",
"posset_attr_op : posset_attr_name FSK_ASSIGN attr_list_value",
"posset_attr_op : posset_attr_name",
"files_attr_op : files_attr_name FSK_ASSIGN attr_list_value",
"files_attr_op : files_attr_name",
"randvar_attr_ops : randvar_attr_op",
"randvar_attr_ops : randvar_attr_ops FSK_SEPLST randvar_attr_op",
"randvar_attr_ops : randvar_attr_ops FSK_SEPLST FSA_RANDTABLE FSK_ASSIGN FSK_OPENLST probtabentry_list FSK_CLOSELST",
"randvar_attr_op : randvar_attr_name FSK_ASSIGN attr_list_value",
"randvar_attr_op : randvar_attr_name",
"randvar_attr_op : FSA_TYPE FSK_ASSIGN randvar_attr_typop",
"randvar_attr_op : FSA_RANDSRC FSK_ASSIGN randvar_attr_srcop",
"probtabentry : FSK_OPENLST var_int_val FSK_SEPLST var_int_val FSK_SEPLST var_int_val FSK_CLOSELST",
"probtabentry_list : probtabentry",
"probtabentry_list : probtabentry_list FSK_SEPLST probtabentry",
"pt_attr_ops : pt_attr_op",
"pt_attr_ops : pt_attr_ops FSK_SEPLST pt_attr_op",
"pt_attr_op : pt_attr_name FSK_ASSIGN attr_value",
"pt_attr_op : pt_attr_name",
"fo_attr_ops : fo_attr_op",
"fo_attr_ops : fo_attr_ops FSK_SEPLST fo_attr_op",
"fo_attr_ops : fo_attr_ops FSK_SEPLST comp_lvar_def",
"fo_attr_op : fo_attr_name FSK_ASSIGN attr_value",
"fo_attr_op : fo_attr_name",
"ev_attr_ops : ev_attr_op",
"ev_attr_ops : ev_attr_ops FSK_SEPLST ev_attr_op",
"ev_attr_op : ev_attr_name FSK_ASSIGN attr_value",
"ev_attr_op : ev_attr_name",
"enable_multi_ops : enable_multi_op",
"enable_multi_ops : enable_multi_ops FSK_SEPLST enable_multi_op",
"enable_multi_op : em_attr_name FSK_ASSIGN attr_value",
"multisync_op : FSA_VALUE FSK_ASSIGN attr_value",
"fscheck_attr_op : fscheck_attr_name FSK_ASSIGN FSV_STRING",
"binary_op : FSK_PLUS",
"binary_op : FSK_MINUS",
"binary_op : FSK_MULTIPLY",
"binary_op : FSK_DIVIDE",
"files_attr_name : attrs_define_file",
"files_attr_name : attrs_define_fileset",
"posset_attr_name : attrs_define_posset",
"pt_attr_name : attrs_define_thread",
"pt_attr_name : attrs_define_proc",
"fo_attr_name : attrs_flowop",
"ev_attr_name : attrs_eventgen",
"attrs_define_proc : FSA_NICE",
"attrs_define_proc : FSA_NAME",
"attrs_define_proc : FSA_INSTANCES",
"attrs_define_file : FSA_SIZE",
"attrs_define_file : FSA_NAME",
"attrs_define_file : FSA_PATH",
"attrs_define_file : FSA_READONLY",
"attrs_define_file : FSA_TRUSTTREE",
"attrs_define_file : FSA_REUSE",
"attrs_define_file : FSA_PREALLOC",
"attrs_define_file : FSA_PARALLOC",
"attrs_define_fileset : FSA_SIZE",
"attrs_define_fileset : FSA_NAME",
"attrs_define_fileset : FSA_PATH",
"attrs_define_fileset : FSA_DIRWIDTH",
"attrs_define_fileset : FSA_DIRDEPTHRV",
"attrs_define_fileset : FSA_PREALLOC",
"attrs_define_fileset : FSA_PARALLOC",
"attrs_define_fileset : FSA_REUSE",
"attrs_define_fileset : FSA_READONLY",
"attrs_define_fileset : FSA_TRUSTTREE",
"attrs_define_fileset : FSA_FILESIZEGAMMA",
"attrs_define_fileset : FSA_DIRGAMMA",
"attrs_define_fileset : FSA_CACHED",
"attrs_define_fileset : FSA_ENTRIES",
"attrs_define_fileset : FSA_LEAFDIRS",
"attrs_define_posset : FSA_NAME",
"attrs_define_posset : FSA_TYPE",
"attrs_define_posset : FSA_RANDSEED",
"attrs_define_posset : FSA_ENTRIES",
"attrs_define_posset : FSA_RANDMAX",
"randvar_attr_name : FSA_NAME",
"randvar_attr_name : FSA_RANDSEED",
"randvar_attr_name : FSA_RANDGAMMA",
"randvar_attr_name : FSA_RANDMEAN",
"randvar_attr_name : FSA_RANDMIN",
"randvar_attr_name : FSA_RANDROUND",
"randvar_attr_tsp : FSS_TYPE",
"randvar_attr_tsp : FSS_SRC",
"randvar_attr_tsp : FSS_SEED",
"randvar_attr_tsp : FSS_GAMMA",
"randvar_attr_tsp : FSS_MEAN",
"randvar_attr_tsp : FSS_MIN",
"randvar_attr_tsp : FSS_ROUND",
"randvar_attr_param : FSS_SEED",
"randvar_attr_param : FSS_GAMMA",
"randvar_attr_param : FSS_MEAN",
"randvar_attr_param : FSS_MIN",
"randvar_attr_param : FSS_ROUND",
"randvar_attr_typop : randtype_name",
"randtype_name : FSV_RANDUNI",
"randtype_name : FSV_RANDTAB",
"randtype_name : FSA_RANDGAMMA",
"randvar_attr_srcop : randsrc_name",
"randsrc_name : FSV_URAND",
"randsrc_name : FSV_RAND48",
"attrs_define_thread : FSA_PROCESS",
"attrs_define_thread : FSA_NAME",
"attrs_define_thread : FSA_MEMSIZE",
"attrs_define_thread : FSA_USEISM",
"attrs_define_thread : FSA_INSTANCES",
"attrs_flowop : FSA_WSS",
"attrs_flowop : FSA_FILE",
"attrs_flowop : FSA_POSSET",
"attrs_flowop : FSA_NAME",
"attrs_flowop : FSA_RANDOM",
"attrs_flowop : FSA_FD",
"attrs_flowop : FSA_SRCFD",
"attrs_flowop : FSA_ROTATEFD",
"attrs_flowop : FSA_DSYNC",
"attrs_flowop : FSA_DIRECTIO",
"attrs_flowop : FSA_INDEXED",
"attrs_flowop : FSA_TARGET",
"attrs_flowop : FSA_ITERS",
"attrs_flowop : FSA_VALUE",
"attrs_flowop : FSA_BLOCKING",
"attrs_flowop : FSA_HIGHWATER",
"attrs_flowop : FSA_IOSIZE",
"attrs_flowop : FSA_NOREADAHEAD",
"attrs_eventgen : FSA_RATE",
"em_attr_name : FSA_MASTER",
"em_attr_name : FSA_CLIENT",
"fscheck_attr_name : FSA_PATH",
"fscheck_attr_name : FSA_FSTYPE",
"comp_attr_ops : comp_attr_op",
"comp_attr_ops : comp_attr_ops FSK_SEPLST comp_attr_op",
"comp_attr_ops : comp_attr_ops FSK_SEPLST comp_lvar_def",
"comp_attr_op : attrs_define_comp FSK_ASSIGN attr_value",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSV_VAL_BOOLEAN",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSV_VAL_INT",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSK_QUOTE FSV_WHITESTRING FSK_QUOTE",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSV_STRING",
"comp_lvar_def : FSV_VARIABLE FSK_ASSIGN FSV_VARIABLE",
"comp_lvar_def : FSV_VARIABLE",
"attrs_define_comp : FSA_NAME",
"attrs_define_comp : FSA_ITERS",
"attr_value : FSV_STRING",
"attr_value : FSV_VAL_INT",
"attr_value : FSV_VAL_BOOLEAN",
"attr_value : FSV_VARIABLE",
"attr_list_value : var_string_list",
"attr_list_value : FSV_STRING",
"attr_list_value : FSV_VAL_INT",
"attr_list_value : FSV_VAL_BOOLEAN",
"attr_list_value : FSV_VARIABLE",
"var_int_val : FSV_VAL_INT",
"var_int_val : FSV_VARIABLE",
};
#endif
#if YYDEBUG
#include <stdio.h>
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 10000
#define YYMAXDEPTH 10000
#endif
#endif
#define YYINITSTACKSIZE 200
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short *yyss;
short *yysslim;
YYSTYPE *yyvs;
int yystacksize;
#line 1844 "parser_gram.y"

/*
 *  The following 'c' routines implement the various commands defined in the
 * above yacc parser code. The yacc portion checks the syntax of the commands
 * found in a workload file, or typed on interactive command lines, parsing
 * the commands' parameters into lists. The lists are then passed in a cmd_t
 * struct for each command to its related routine in the following section
 * for actual execution. This section also includes a few utility routines
 * and the main entry point for the program.
 */

/*
 * Entry point for filebench. Processes command line arguements. The -f
 * option will read in a workload file (the full name and extension must
 * must be given). The -a, -s, -m and -i options are used by worker process
 * to receive their name, the base address of shared memory, its path, and
 * the process' instance number, respectively. This information is supplied
 * by the master process when it execs worker processes under the process
 * model of execution. If the worker process arguments are passed then main
 * will call the procflow_exec routine which creates worker threadflows and
 * flowops and executes the procflow's portion of the workload model until
 * completion. If worker process arguments are not passed to the process,
 * then it becomes the master process for a filebench run. It initializes
 * the various filebench components and either executes the supplied workload
 * file, or enters interactive mode.
 */

int
main(int argc, char *argv[])
{
	int opt;
	int instance;
	char procname[128];
#if defined(_LP64) || (__WORDSIZE == 64)
	unsigned long long shmaddr;
#else
	unsigned int shmaddr;
#endif
	char dir[MAXPATHLEN];
#ifdef HAVE_SETRLIMIT
	struct rlimit rlp;
#endif
#ifdef HAVE_LIBTECLA
	char *line;
#else
	char line[1024];
#endif
	char shmpathtmp[1024];

#ifdef HAVE_PROC_SYS_KERNEL_SHMMAX
	/* Increase the maximum shared memory segment size till
	 * some large value. We save old value to restore it later.
	 * XXX: however we do not restore it now: to many places
	 * where we need to restore it on error paths.
	 */

	FILE *f;
	int ret;
	unsigned long long oldshmmax;

	f = fopen("/proc/sys/kernel/shmmax", "r+");
	if (!f) {
		filebench_log(LOG_ERROR, "Coud not open "
				"/proc/sys/kernel/shmmax file!");
		exit(1);
	}

	/* saving the old value */
	ret = fscanf(f, "%llu", &oldshmmax);

	/* writing new value */
#define SOME_LARGE_SHMAX "268435456" /* 256 MB */
	ret = fwrite(SOME_LARGE_SHMAX, sizeof(SOME_LARGE_SHMAX), 1, f);
	if (ret != 1) {
		filebench_log(LOG_ERROR, "Coud not write to "
				"/proc/sys/kernel/shmmax file!");
		exit(1);
	}
#undef SOME_LARGE_SHMAX
#endif

#ifdef HAVE_SETRLIMIT
	/* Increase the limit of opened files.
	 *
	 * We first set the limit to the hardlimit reported by the kernel; this
	 * call will always succeed.  Then we try to set the limit to some
	 * large number of files (unfortunately we can't set this ulimit to
	 * infinity), this will only succeed if the process is ran by root.
	 * Therefore, we set the maximum possible value for the limit for this
	 * given process (well, only if hardlimit is greater then the large
	 * number of files defined by us, it is not true).
	 *
	 * Increasing this limit is especially important when we use thread
	 * model, because opened files are accounted per-process, not
	 * per-thread.
	 */
	(void) getrlimit(RLIMIT_NOFILE, &rlp);
	rlp.rlim_cur = rlp.rlim_max;
	(void) setrlimit(RLIMIT_NOFILE, &rlp);
#define SOME_LARGE_NUMBER_OF_FILES 50000
	rlp.rlim_cur = rlp.rlim_max = SOME_LARGE_NUMBER_OF_FILES;
#undef SOME_LARGE_NUMBER_OF_FILES
	(void) setrlimit(RLIMIT_NOFILE, &rlp);
#endif

	yydebug = 0;
	execname = argv[0];
	*procname = 0;
	cwd = getcwd(dir, MAXPATHLEN);

	while ((opt = getopt(argc, argv, cmd_options)) != (int)EOF) {

		switch (opt) {
		case 'h':
			usage(2);
			break;

		case 'p':
			noproc = 1;
			break;

		case 'f':
			if (optarg == NULL)
				usage(1);
			if ((yyin = fopen(optarg, "r")) == NULL) {
				(void) fprintf(stderr,
				    "Cannot open file %s", optarg);
				exit(1);
			}
			dofile = FS_TRUE;
			fscriptname = optarg;

			break;

		case 'a':
			if (optarg == NULL)
				usage(1);
			sscanf(optarg, "%s", &procname[0]);
			break;

		case 's':
			if (optarg == NULL)
				usage(1);
#if defined(_LP64) || (__WORDSIZE == 64)
			sscanf(optarg, "%llx", &shmaddr);
#else
			sscanf(optarg, "%x", &shmaddr);
#endif
			break;

		case 'm':
			if (optarg == NULL)
				usage(1);
			sscanf(optarg, "%s", shmpathtmp);
			shmpath = shmpathtmp;
			break;

		case 'i':
			if (optarg == NULL)
				usage(1);
			sscanf(optarg, "%d", &instance);
			break;

		case '?':
		default:
			usage(1);
			break;
		}
	}

#ifdef USE_PROCESS_MODEL
	if (!(*procname))
#endif
	printf("FileBench Version %s\n", FILEBENCH_VERSION);
	filebench_init();

	/* get process pid for use with message logging */
	my_pid = getpid();

#ifdef USE_PROCESS_MODEL
	if (*procname) {
		/* A child FileBench instance */
		if (ipc_attach((char *)shmaddr) < 0) {
			filebench_log(LOG_ERROR, "Cannot attach shm for %s",
			    procname);
			exit(1);
		}

		/* get correct function pointer for each child process */
		filebench_plugin_funcvecinit();

		if (procflow_exec(procname, instance) < 0) {
			filebench_log(LOG_ERROR, "Cannot startup process %s",
			    procname);
			exit(1);
		}

		exit(0);
	}
#endif

	/* master (or only) process */
	ipc_init();

	if (fscriptname)
		(void) strcpy(filebench_shm->shm_fscriptname, fscriptname);

	filebench_plugin_funcvecinit();
	flowop_init();
	stats_init();
	eventgen_init();

	signal(SIGINT, parser_abort);

	if (dofile)
		yyparse();
	else {
#ifdef HAVE_LIBTECLA
		if ((gl = new_GetLine(MAX_LINE_LEN, MAX_CMD_HIST)) == NULL) {
			filebench_log(LOG_ERROR,
			    "Failed to create GetLine object");
			filebench_shutdown(1);
		}

		if (gl_customize_completion(gl, NULL, command_complete)) {
			filebench_log(LOG_ERROR,
			    "Failed to register auto-completion function");
			filebench_shutdown(1);
		}

		while ((line = gl_get_line(gl, FILEBENCH_PROMPT, NULL, -1))) {
			arg_parse(line);
			yyparse();
		}

		del_GetLine(gl);
#else
		while (!feof(stdin)) {
			printf(FILEBENCH_PROMPT);
			fflush(stdout);
			if (fgets(line, sizeof (line), stdin) == NULL) {
				if (errno == EINTR)
					continue;
				else
					break;
			}
			arg_parse(line);
			yyparse();
		}
		printf("\n");
#endif	/* HAVE_LIBTECLA */
	}

	parser_filebench_shutdown((cmd_t *)0);

	return (0);
}

/*
 * arg_parse() puts the parser into command parsing mode. Create a tmpfile
 * and instruct the parser to read instructions from this location by setting
 * yyin to the value returned by tmpfile. Write the command into the file.
 * Then seek back to to the start of the file so that the parser can read
 * the instructions.
 */
static void
arg_parse(const char *command)
{
	if ((yyin = tmpfile()) == NULL) {
		filebench_log(LOG_FATAL,
		    "Exiting: Cannot create tmpfile: %s", strerror(errno));
		exit(1);
	}

	if (fwrite(command, strlen(command), 1, yyin) != 1)
		filebench_log(LOG_FATAL,
		    "Cannot write tmpfile: %s", strerror(errno));

	if (fseek(yyin, 0, SEEK_SET) != 0)
		filebench_log(LOG_FATAL,
		    "Cannot seek tmpfile: %s", strerror(errno));
}

/*
 * Converts a list of var_strings or ordinary strings to a single ordinary
 * string. It returns a pointer to the string (in malloc'd memory) if found,
 * or NULL otherwise.
 */
char *
parser_list2string(list_t *list)
{
	list_t *l;
	char *string;
	char *tmp;
	if ((string = malloc(MAXPATHLEN)) == NULL) {
		filebench_log(LOG_ERROR, "Failed to allocate memory");
		return (NULL);
	}

	*string = 0;

	/*	printf("parser_list2string: called\n"); */
	/* Format args */
	for (l = list; l != NULL; l = l->list_next) {
		char *lstr = avd_get_str(l->list_string);

		filebench_log(LOG_DEBUG_SCRIPT,
		    "converting string '%s'", lstr);

		/* see if it is a random variable */
		if (l->list_integer) {
			fbint_t param_name;

			tmp = NULL;
			param_name = avd_get_int(l->list_integer);
			switch (param_name) {
			case FSS_TYPE:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_TYPE);
				break;

			case FSS_SRC:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_SRC);
				break;

			case FSS_SEED:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_SEED);
				break;

			case FSS_MIN:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_MIN);
				break;

			case FSS_MEAN:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_MEAN);
				break;

			case FSS_GAMMA:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_GAMMA);
				break;

			case FSS_ROUND:
				tmp = var_randvar_to_string(lstr,
				    RAND_PARAM_ROUND);
				break;
			}

			if (tmp) {
				(void) strcat(string, tmp);
				free(tmp);
			} else {
				(void) strcat(string, lstr);
			}
		} else {
			/* perhaps a normal variable? */
			if ((tmp = var_to_string(lstr)) != NULL) {
				(void) strcat(string, tmp);
				free(tmp);
			} else {
				(void) strcat(string, lstr);
			}
		}
	}
	return (string);
}

/*
 * If the list just contains a single string starting with '$', then find
 * or create the named var and return the var's var_string component.
 * Otherwise, convert the list to a string, and allocate a var_string
 * containing a copy of that string. On failure either returns NULL
 * or shuts down the run.
 */
avd_t
parser_list2varstring(list_t *list)
{
	char *lstr = avd_get_str(list->list_string);

	/*	printf("parser_list2varstring: Called\n"); */
	/* Special case - variable name */
	if ((list->list_next == NULL) && (*lstr == '$'))
		return (var_ref_attr(lstr));

	return (avd_str_alloc(parser_list2string(list)));
}

/*
 * Looks for the var named in list_string of the first element of the
 * supplied list. If found, returns the var_val portion of the var in
 * an attribute value descriptor. If the var is not found, cannot be
 * allocated, the supplied list is NULL, or the list_string filed is
 * empty, returns NULL.
 */
avd_t
parser_list2avd(list_t *list)
{
	avd_t avd;
	char *lstr;

	if (list && ((lstr = avd_get_str(list->list_string)) != NULL)) {
		avd = var_ref_attr(lstr);
		return (avd);
	}

	return (NULL);
}

/*
 * Sets the event generator rate from the attribute supplied with the
 * command. If the attribute doesn't exist the routine does nothing.
 */
static void
parser_eventgen(cmd_t *cmd)
{
	attr_t *attr;

	/* Get the rate from attribute */
	if ((attr = get_attr_integer(cmd, FSA_RATE))) {
		if (attr->attr_avd) {
			eventgen_setrate(attr->attr_avd);
		}
	}
}

/*
 * Assigns the designated integer variable successive values from the
 * supplied comma seperated integer list. After each successive integer
 * assignment, it executes the bracket enclosed list of commands. For
 * example, repeated runs of a workload with increasing io sizes can
 * be done using the following command line:
 * 	foreach $iosize in 2k, 4k, 8k {run 60}
 */
static void
parser_foreach_integer(cmd_t *cmd)
{
	list_t *list = cmd->cmd_param_list;
	cmd_t *inner_cmd;

	for (; list != NULL; list = list->list_next) {
		fbint_t list_int = avd_get_int(list->list_integer);

		var_assign_integer(cmd->cmd_tgt1, list_int);
		filebench_log(LOG_VERBOSE, "Iterating %s=%llu",
		    cmd->cmd_tgt1, (u_longlong_t)list_int);
		for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
		    inner_cmd = inner_cmd->cmd_next) {
			inner_cmd->cmd(inner_cmd);
		}
	}
}

/*
 * Similar to parser_foreach_integer(), except takes a list of strings after
 * the "in" token. For example, to run twice using a different directory,
 * perhaps using a different filesystem, the following command line
 * could be used:
 * 	foreach $dir in "/ufs_top/fbt", "/zfs_top/fbt" {run 60)
 */
static void
parser_foreach_string(cmd_t *cmd)
{
	list_t *list = cmd->cmd_param_list;

	for (; list != NULL; list = list->list_next) {
		cmd_t *inner_cmd;
		char *lstr = avd_get_str(list->list_string);
		var_assign_string(cmd->cmd_tgt1, lstr);
		filebench_log(LOG_VERBOSE, "Iterating %s=%s",
		    cmd->cmd_tgt1, lstr);
		for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
		    inner_cmd = inner_cmd->cmd_next) {
			inner_cmd->cmd(inner_cmd);
		}
	}
}

/*
 * Lists the fileset name, path name and average size for all defined
 * filesets.
 */
static void
parser_list(cmd_t *cmd)
{
	(void) fileset_iter(fileset_print);
}

/*
 * Lists the flowop name and instance number for all flowops.
 */
static void
parser_flowop_list(cmd_t *cmd)
{
	flowop_printall();
}

/*
 * Calls procflow_define() to allocate "instances" number of  procflow(s)
 * (processes) with the supplied name. The default number of instances is
 * one. An optional priority level attribute can be supplied and is stored in
 * pf_nice. Finally the routine loops through the list of inner commands, if
 * any, which are defines for threadflows, and passes them one at a time to
 * parser_thread_define() to allocate threadflow entities for the process(es).
 */
static void
parser_proc_define(cmd_t *cmd)
{
	procflow_t *procflow;
	char *name = NULL;
	attr_t *attr;
	avd_t var_instances;
	fbint_t instances;
	cmd_t *inner_cmd;

	/* Get the name of the process */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define proc: proc specifies no name");
		filebench_shutdown(1);
	}

	/* Get the memory size from attribute */
	if ((attr = get_attr_integer(cmd, FSA_INSTANCES))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "proc_define: Instances attr cannot be random");
			filebench_shutdown(1);
		}
		var_instances = attr->attr_avd;
		instances = avd_get_int(var_instances);
		filebench_log(LOG_DEBUG_IMPL,
		    "Setting instances = %llu", (u_longlong_t)instances);
	} else {
		filebench_log(LOG_DEBUG_IMPL,
		    "Defaulting to instances = 1");
		var_instances = avd_int_alloc(1);
		instances = 1;
	}

	if ((procflow = procflow_define(name, NULL, var_instances)) == NULL) {
		filebench_log(LOG_ERROR,
		    "Failed to instantiate %d %s process(es)\n",
		    instances, name);
		filebench_shutdown(1);
	}

	/* Get the pri from attribute */
	if ((attr = get_attr_integer(cmd, FSA_NICE))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "proc_define: priority cannot be random");
			filebench_shutdown(1);
		}
		filebench_log(LOG_DEBUG_IMPL, "Setting pri = %llu",
		    (u_longlong_t)avd_get_int(attr->attr_avd));
		procflow->pf_nice = attr->attr_avd;
	} else
		procflow->pf_nice = avd_int_alloc(0);


	/* Create the list of threads for this process  */
	for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
	    inner_cmd = inner_cmd->cmd_next) {
		parser_thread_define(inner_cmd, procflow, instances);
	}
}

/*
 * Calls threadflow_define() to allocate "instances" number of  threadflow(s)
 * (threads) with the supplied name. The default number of instances is
 * one. Two other optional attributes may be supplied, one to set the memory
 * size, stored in tf_memsize, and to select the use of Interprocess Shared
 * Memory, which sets the THREADFLOW_USEISM flag in tf_attrs. Finally
 * the routine loops through the list of inner commands, if any, which are
 * defines for flowops, and passes them one at a time to
 * parser_flowop_define() to allocate flowop entities for the threadflows.
 */
static void
parser_thread_define(cmd_t *cmd, procflow_t *procflow, int procinstances)
{
	threadflow_t *threadflow, template;
	attr_t *attr;
	avd_t instances;
	cmd_t *inner_cmd;
	char *name = NULL;

	memset(&template, 0, sizeof (threadflow_t));

	/* Get the name of the thread */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define thread: thread in process %s specifies no name",
		    procflow->pf_name);
		filebench_shutdown(1);
	}

	/* Get the number of instances from attribute */
	if ((attr = get_attr_integer(cmd, FSA_INSTANCES))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "define thread: Instances attr cannot be random");
			filebench_shutdown(1);
		}
		filebench_log(LOG_DEBUG_IMPL,
		    "define thread: Setting instances = %llu",
		    (u_longlong_t)avd_get_int(attr->attr_avd));
		instances = attr->attr_avd;
	} else
		instances = avd_int_alloc(1);

	/* Get the memory size from attribute */
	if ((attr = get_attr_integer(cmd, FSA_MEMSIZE))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "define thread: Memory size cannot be random");
			filebench_shutdown(1);
		}
		filebench_log(LOG_DEBUG_IMPL,
		    "define thread: Setting memsize = %llu",
		    (u_longlong_t)avd_get_int(attr->attr_avd));
		template.tf_memsize = attr->attr_avd;
	} else
		template.tf_memsize = avd_int_alloc(0);

	if ((threadflow = threadflow_define(procflow, name,
	    &template, instances)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define thread: Failed to instantiate thread\n");
		filebench_shutdown(1);
	}

	/* Use ISM Memory? */
	if ((attr = get_attr(cmd, FSA_USEISM))) {
		threadflow->tf_attrs |= THREADFLOW_USEISM;
	}

	/* Create the list of flowops */
	for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
	    inner_cmd = inner_cmd->cmd_next) {
		parser_flowop_define(inner_cmd, threadflow,
		    &threadflow->tf_thrd_fops, FLOW_MASTER);
	}
}

/*
 * Fills in the attributes for a newly allocated flowop
 */
static void
parser_flowop_get_attrs(cmd_t *cmd, flowop_t *flowop)
{
	attr_t *attr;

	/* Get the filename from attribute */
	if ((attr = get_attr(cmd, FSA_FILE))) {
		flowop->fo_filename = attr->attr_avd;
		if (flowop->fo_filename == NULL) {
			filebench_log(LOG_ERROR,
			    "define flowop: no filename specfied");
			filebench_shutdown(1);
		}
	} else {
		/* no filename attribute specified */
		flowop->fo_filename = NULL;
	}

	/* Get the possetname from attribute */
	if ((attr = get_attr(cmd, FSA_POSSET))) {
		flowop->fo_possetname = attr->attr_avd;
		if (flowop->fo_possetname == NULL) {
			filebench_log(LOG_ERROR,
			    "parser_flowop_get_attrs: no "
				"posset name specfied");
			filebench_shutdown(1);
		}
	} else {
		/* no possetname attribute specified */
		flowop->fo_possetname = NULL;
	}

	/* Get the iosize of the op */
	if ((attr = get_attr_integer(cmd, FSA_IOSIZE)))
		flowop->fo_iosize = attr->attr_avd;
	else
		flowop->fo_iosize = avd_int_alloc(0);

	/* Get the working set size of the op */
	if ((attr = get_attr_integer(cmd, FSA_WSS)))
		flowop->fo_wss = attr->attr_avd;
	else
		flowop->fo_wss = avd_int_alloc(0);

	/* Random I/O? */
	if ((attr = get_attr_bool(cmd, FSA_RANDOM)))
		flowop->fo_random = attr->attr_avd;
	else
		flowop->fo_random = avd_bool_alloc(FALSE);

	/* Sync I/O? */
	if ((attr = get_attr_bool(cmd, FSA_DSYNC)))
		flowop->fo_dsync = attr->attr_avd;
	else
		flowop->fo_dsync = avd_bool_alloc(FALSE);

	/* Target, for wakeup etc */
	if ((attr = get_attr(cmd, FSA_TARGET)))
		(void) strcpy(flowop->fo_targetname,
		    avd_get_str(attr->attr_avd));

	/* Value */
	if ((attr = get_attr_integer(cmd, FSA_VALUE)))
		flowop->fo_value = attr->attr_avd;
	else
		flowop->fo_value = avd_int_alloc(0);

	/* FD */
	if ((attr = get_attr_integer(cmd, FSA_FD))) {
		flowop->fo_fdnumber = avd_get_int(attr->attr_avd);
		if (flowop->fo_filename != NULL)
			filebench_log(LOG_DEBUG_SCRIPT, "It is not "
			    "advisable to supply both an fd number "
			    "and a fileset name in most cases");
	}

	/* Rotatefd? */
	if ((attr = get_attr_bool(cmd, FSA_ROTATEFD)))
		flowop->fo_rotatefd = attr->attr_avd;
	else
		flowop->fo_rotatefd = avd_bool_alloc(FALSE);

	/* SRC FD, for copies etc... */
	if ((attr = get_attr_integer(cmd, FSA_SRCFD)))
		flowop->fo_srcfdnumber = avd_get_int(attr->attr_avd);

	/* Blocking operation? */
	if ((attr = get_attr_bool(cmd, FSA_BLOCKING)))
		flowop->fo_blocking = attr->attr_avd;
	else
		flowop->fo_blocking = avd_bool_alloc(FALSE);

	/* Direct I/O Operation */
	if ((attr = get_attr_bool(cmd, FSA_DIRECTIO)))
		flowop->fo_directio = attr->attr_avd;
	else
		flowop->fo_directio = avd_bool_alloc(FALSE);

	/* Highwater mark */
	if ((attr = get_attr_integer(cmd, FSA_HIGHWATER))) {
		flowop->fo_highwater = attr->attr_avd;
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "define flowop: Highwater attr cannot be random");
			filebench_shutdown(1);
		}
	} else {
		flowop->fo_highwater = avd_int_alloc(1);
	}

	/* find file or leaf directory by index number */
	if ((attr = get_attr_integer(cmd, FSA_INDEXED)))
		flowop->fo_fileindex = attr->attr_avd;
	else
		flowop->fo_fileindex = NULL;

	/* Read Ahead Diable */
	if ((attr = get_attr_bool(cmd, FSA_NOREADAHEAD)))
		flowop->fo_noreadahead = attr->attr_avd;
	else
		flowop->fo_noreadahead = avd_bool_alloc(FALSE);


}

/*
 * defines the FLOW_MASTER flowops within a FLOW_MASTER instance of
 * a composit flowop. Default attributes from the FLOW_INNER_DEF instances
 * of the composit flowop's inner flowops are used if set. Otherwise
 * default attributes from the FLOW_MASTER instance of the composit flowop
 * are used, which may include defaults from the original FLOW_DEFINITION
 * of the composit flowop.
 */
static void
parser_inner_flowop_define(threadflow_t *thread, flowop_t *comp0_flow,
			   flowop_t *comp_mstr_flow)
{
	flowop_t *inner_flowtype, *inner_flowop;

	/* follow flowop list, creating composit names */
	inner_flowtype = comp0_flow->fo_comp_fops;
	comp_mstr_flow->fo_comp_fops = NULL;

	while (inner_flowtype) {
		char fullname[MAXPATHLEN];

		/* create composite_name.name for new flowop */
		snprintf(fullname, MAXPATHLEN, "%s.%s",
		    comp_mstr_flow->fo_name, inner_flowtype->fo_name);

		if ((inner_flowop = flowop_define(thread, fullname,
		    inner_flowtype, &comp_mstr_flow->fo_comp_fops,
		    FLOW_MASTER, 0)) == NULL) {
			filebench_log(LOG_ERROR,
			    "define flowop: Failed to instantiate flowop %s\n",
			    fullname);
			filebench_shutdown(1);
		}

		/* if applicable, update filename attribute */
		if (inner_flowop->fo_filename) {
			char *name;

			/* fix up avd_t */
			avd_update(&inner_flowop->fo_filename,
			    comp_mstr_flow->fo_lvar_list);

			/* see if ready to get the file or fileset */
			name = avd_get_str(inner_flowop->fo_filename);
			if (name) {

				inner_flowop->fo_fileset = fileset_find(name);

				if (inner_flowop->fo_fileset == NULL) {
					filebench_log(LOG_ERROR,
					    "inr flowop %s: file %s not found",
					    inner_flowop->fo_name, name);
					filebench_shutdown(1);
				}
			}
		}

		/* update attributes from local variables */
		avd_update(&inner_flowop->fo_iters,
		    comp_mstr_flow->fo_lvar_list);

		/* if the inner flowop is a composit flowop, recurse */
		if (inner_flowtype->fo_type == FLOW_TYPE_COMPOSITE) {
			var_t *newlvar, *proto_lvars, *lvar_ptr;

			proto_lvars = inner_flowop->fo_lvar_list;
			inner_flowop->fo_lvar_list = 0;

			for (lvar_ptr = inner_flowtype->fo_lvar_list; lvar_ptr;
			    lvar_ptr = lvar_ptr->var_next) {

				if ((newlvar = var_lvar_alloc_local(
				    lvar_ptr->var_name)) != NULL) {

					add_lvar_to_list(newlvar,
					    &inner_flowop->fo_lvar_list);

					var_update_comp_lvars(newlvar,
					    proto_lvars,
					    comp_mstr_flow->fo_lvar_list);
				}
			}
		  
			parser_inner_flowop_define(thread,
			    inner_flowtype,
			    inner_flowop);

			inner_flowtype = inner_flowtype->fo_exec_next;
			continue;
		}

		avd_update(&inner_flowop->fo_iosize,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_wss,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_iters,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_value,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_random,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_dsync,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_rotatefd,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_blocking,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_directio,
		    comp_mstr_flow->fo_lvar_list);
		avd_update(&inner_flowop->fo_highwater,
		    comp_mstr_flow->fo_lvar_list);

		inner_flowtype = inner_flowtype->fo_exec_next;
	}
}

/*
 * Calls flowop_define() to allocate a flowop with the supplied name.
 * The allocated flowop inherits attributes from a base flowop of the
 * same type.  If the new flowop has a file or fileset attribute specified,
 * it must specify a defined fileobj or fileset or an error will be logged.
 * The new flowop may  also have the following attributes set by
 * the program:
 *  - file size (fo_iosize)
 *  - working set size (fo_wss)
 *  - do random io (fo_random)
 *  - do synchronous io (fo_dsync)
 *  - perform each operation multiple times before advancing (fo_iter)
 *  - target name (fo_targetname)
 *  - An integer value (fo_value)
 *  - a file descriptor (fo_fd)
 *  - specify to rotate file descriptors (fo_rotatefd)
 *  - a source fd (fo_srcfdnumber)
 *  - specify a blocking operation (fo_blocking)
 *  - specify a highwater mark (fo_highwater)
 *
 * After all the supplied attributes are stored in their respective locations
 * in the flowop object, the flowop's init function is called. No errors are
 * returned, but the filebench run will be terminated if the flowtype is not
 * specified, a name for the new flowop is not supplied, the flowop_define
 * call fails, or a file or fileset name is supplied but the corresponding
 * fileobj or fileset cannot be located.
 */
static void
parser_flowop_define(cmd_t *cmd, threadflow_t *thread,
    flowop_t **flowoplist_hdp, int category)
{
	flowop_t *flowop, *flowop_type;
	char *type = (char *)cmd->cmd_name;
	char *name = NULL;
	attr_t *attr;

	/* Get the inherited flowop */
	flowop_type = flowop_find(type);
	if (flowop_type == NULL) {
		filebench_log(LOG_ERROR,
		    "define flowop: flowop type %s not found",
		    type);
		filebench_shutdown(1);
	}

	/* Get the name of the flowop */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define flowop: flowop %s specifies no name",
		    flowop_type->fo_name);
		filebench_shutdown(1);
	}

	if ((flowop = flowop_define(thread, name,
	    flowop_type, flowoplist_hdp, category, 0)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define flowop: Failed to instantiate flowop %s\n",
		    cmd->cmd_name);
		filebench_shutdown(1);
	}

	/* Iterations */
	if ((attr = get_attr_integer(cmd, FSA_ITERS)))
		flowop->fo_iters = attr->attr_avd;
	else
		flowop->fo_iters = avd_int_alloc(1);


	/* if this is a use of a composit flowop, create inner FLOW MASTERS */
	if (flowop_type->fo_type == FLOW_TYPE_COMPOSITE) {
		get_attr_lvars(cmd, flowop);
		if (category == FLOW_MASTER)
			parser_inner_flowop_define(thread,
			    flowop_type, flowop);
	}
	else {
		parser_flowop_get_attrs(cmd, flowop);
	}
}

static void
parser_composite_flowop_define(cmd_t *cmd)
{
	flowop_t *flowop;
	cmd_t *inner_cmd;
	char *name = NULL;
	attr_t *attr;

	/* Get the name of the flowop */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define flowop: Composit flowop specifies no name");

		filebench_shutdown(1);
	}

	if ((flowop = flowop_new_composite_define(name)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define flowop: Failed to instantiate flowop %s\n",
		    cmd->cmd_name);
		filebench_shutdown(1);
	}

	/* place any local var_t variables on the flowop's local list */
	get_attr_lvars(cmd, flowop);

	/* Iterations */
	if ((attr = get_attr_integer(cmd, FSA_ITERS)))
		flowop->fo_iters = attr->attr_avd;
	else
		flowop->fo_iters = avd_int_alloc(1);

	/* define inner flowops */
	for (inner_cmd = cmd->cmd_list; inner_cmd != NULL;
	    inner_cmd = inner_cmd->cmd_next) {
		parser_flowop_define(inner_cmd, NULL,
		    &flowop->fo_comp_fops, FLOW_INNER_DEF);
	}
}


/*
 * Calls fileset_define() to allocate a fileset with the supplied name and
 * initializes the fileset's pathname attribute, and optionally the
 * fileset_cached, fileset_reuse, fileset_prealloc and fileset_size attributes.
 *
 */
static fileset_t *
parser_fileset_define_common(cmd_t *cmd)
{
	fileset_t *fileset;
	avd_t name;
	attr_t *attr;
	avd_t pathname;

	/*
	 * Make sure all plugin flowops are initialized.
	 * Defaults to local fs for now
	 */
	flowop_plugin_flowinit();

	/* Get the name of the file */
	if ((attr = get_attr_fileset(cmd, FSA_NAME))) {
		name = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR,
		    "define fileset: file or fileset specifies no name");
		return (NULL);
	}

	if ((fileset = fileset_define(name)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define file: failed to instantiate file %s\n",
		    avd_get_str(name));
		return (NULL);
	}

	/* Get the pathname from attribute */
	if ((attr = get_attr(cmd, FSA_PATH)) == NULL) {
		filebench_log(LOG_ERROR, "define file: no pathname specified");
		return (NULL);
	}

	/* Expand variables in pathname */
	if ((pathname = parser_list2varstring(attr->attr_param_list))
	    == NULL) {
		filebench_log(LOG_ERROR, "Cannot interpret path");
		return (NULL);
	}

	fileset->fs_path = pathname;

	/* How much should we preallocate? */
	if ((attr = get_attr_integer(cmd, FSA_PREALLOC)) &&
	    attr->attr_avd) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "define fileset: Prealloc attr cannot be random");
			filebench_shutdown(1);
		}
		fileset->fs_preallocpercent = attr->attr_avd;
	} else if (attr && !attr->attr_avd) {
		fileset->fs_preallocpercent = avd_int_alloc(100);
	} else {
		fileset->fs_preallocpercent = avd_int_alloc(0);
	}

	/* Should we preallocate? */
	if ((attr = get_attr_bool(cmd, FSA_PREALLOC)))
		fileset->fs_prealloc = attr->attr_avd;
	else
		fileset->fs_prealloc = avd_bool_alloc(FALSE);

	/* Should we prealloc in parallel? */
	if ((attr = get_attr_bool(cmd, FSA_PARALLOC)))
		fileset->fs_paralloc = attr->attr_avd;
	else
		fileset->fs_paralloc = avd_bool_alloc(FALSE);

	/* Should we allow writes to the file? */
	if ((attr = get_attr_bool(cmd, FSA_READONLY)))
		fileset->fs_readonly = attr->attr_avd;
	else
		fileset->fs_readonly = avd_bool_alloc(FALSE);

	/* Should we reuse the existing file? */
	if ((attr = get_attr_bool(cmd, FSA_REUSE)))
		fileset->fs_reuse = attr->attr_avd;
	else
		fileset->fs_reuse = avd_bool_alloc(FALSE);

	/* Should we check for files actual existance? */
	if ((attr = get_attr_bool(cmd, FSA_TRUSTTREE)))
		fileset->fs_trust_tree = attr->attr_avd;
	else
		fileset->fs_trust_tree = avd_bool_alloc(FALSE);

	/* Should we leave in cache? */
	if ((attr = get_attr_bool(cmd, FSA_CACHED)))
		fileset->fs_cached = attr->attr_avd;
	else
		fileset->fs_cached = avd_bool_alloc(FALSE);

	/* Get the mean or absolute size of the file */
	if ((attr = get_attr_integer(cmd, FSA_SIZE)))
		fileset->fs_size = attr->attr_avd;
	else
		fileset->fs_size = avd_int_alloc(0);

	return (fileset);
}

/*
 * Calls parser_fileset_define_common() to allocate a fileset with
 * one entry and optionally the fileset_prealloc. sets the fileset_entries,
 * fileset_dirwidth, fileset_dirgamma, and fileset_sizegamma attributes
 * to appropriate values for emulating the old "fileobj" entity
 */
static void
parser_file_define(cmd_t *cmd)
{
	fileset_t *fileset;

	if ((fileset = parser_fileset_define_common(cmd)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define file: failed to instantiate file");
		filebench_shutdown(1);
		return;
	}

	/* fileset is emulating a single file */
	fileset->fs_attrs = FILESET_IS_FILE;

	/* Set the size of the fileset to 1 */
	fileset->fs_entries = avd_int_alloc(1);

	/* Set the mean dir width to more than 1 */
	fileset->fs_dirwidth = avd_int_alloc(10);

	/* Set the dir and size gammas to 0 */
	fileset->fs_dirgamma = avd_int_alloc(0);
	fileset->fs_sizegamma = avd_int_alloc(0);
}

/*
 * Calls parser_fileset_define_common() to allocate a fileset with the
 * supplied name and initializes the fileset's fileset_preallocpercent,
 * fileset_prealloc, fileset_entries, fileset_dirwidth, fileset_dirgamma,
 * and fileset_sizegamma attributes.
 */
static void
parser_fileset_define(cmd_t *cmd)
{
	fileset_t *fileset;
	attr_t *attr;

	if ((fileset = parser_fileset_define_common(cmd)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define fileset: failed to instantiate fileset");
		filebench_shutdown(1);
		return;
	}
	/* Get the number of files in the fileset */
	if ((attr = get_attr_integer(cmd, FSA_ENTRIES))) {
		fileset->fs_entries = attr->attr_avd;
	} else {
		fileset->fs_entries = avd_int_alloc(0);
	}

	/* Get the number of leafdirs in the fileset */
	if ((attr = get_attr_integer(cmd, FSA_LEAFDIRS))) {
		fileset->fs_leafdirs = attr->attr_avd;
	} else {
		fileset->fs_leafdirs = avd_int_alloc(0);
	}

	if ((avd_get_int(fileset->fs_entries) == 0) &&
	    (avd_get_int(fileset->fs_leafdirs) == 0)) {
		filebench_log(LOG_ERROR, "Fileset has no files or leafdirs");
	}

	/* Get the mean dir width of the fileset */
	if ((attr = get_attr_integer(cmd, FSA_DIRWIDTH))) {
		fileset->fs_dirwidth = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR, "Fileset has zero directory width");
		fileset->fs_dirwidth = avd_int_alloc(0);
	}

	/* Get the random variable for dir depth, if supplied */
	if ((attr = get_attr_integer(cmd, FSA_DIRDEPTHRV))) {
		if (!AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "Define fileset: dirdepthrv must be random var");
			filebench_shutdown(1);
		}
		fileset->fs_dirdepthrv = attr->attr_avd;
	} else {
		fileset->fs_dirdepthrv = NULL;
	}

	/* Get the gamma value for dir depth distributions */
	if ((attr = get_attr_integer(cmd, FSA_DIRGAMMA))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "Define fileset: dirgamma attr cannot be random");
			filebench_shutdown(1);
		}
		fileset->fs_dirgamma = attr->attr_avd;
	} else
		fileset->fs_dirgamma = avd_int_alloc(1500);

	/* Get the gamma value for dir width distributions */
	if ((attr = get_attr_integer(cmd, FSA_FILESIZEGAMMA))) {
		if (AVD_IS_RANDOM(attr->attr_avd)) {
			filebench_log(LOG_ERROR,
			    "Define fileset: filesizegamma cannot be random");
			filebench_shutdown(1);
		}
		fileset->fs_sizegamma = attr->attr_avd;
	} else
		fileset->fs_sizegamma = avd_int_alloc(1500);
}

static void
parser_posset_define(cmd_t *cmd)
{
	attr_t *attr;
	avd_t name;
	avd_t type;
	avd_t seed;
	avd_t max;
	avd_t entries;
	int i;

	struct posset *ps;
	
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR,
		   "parser_posset_define: no name specified for the posset");
		filebench_shutdown(1);
		return;
	}

	if ((attr = get_attr(cmd, FSA_TYPE))) {
		type = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR,
		   "parser_posset_define: no type specified for the posset");
		filebench_shutdown(1);
		return;
	}

	if ((attr = get_attr_integer(cmd, FSA_ENTRIES))) {
		entries = attr->attr_avd;
	} else {
		filebench_log(LOG_ERROR,
		   "parser_posset_define: no entries number "
					"specified for the posset");
		filebench_shutdown(1);
		return;
	}

	/*
	 * two attributes below are mandatory only for specific types
	 * of possets, so postpone their validation for posset type
	 * specific functions.
	 */
	if ((attr = get_attr_integer(cmd, FSA_RANDSEED)))
		seed = attr->attr_avd;
	else
		seed = avd_int_alloc(0);

	if ((attr = get_attr_integer(cmd, FSA_RANDMAX)))
		max = attr->attr_avd;
	else
		max = avd_int_alloc(0);

	filebench_log(LOG_INFO,"Defining position set: %s type: %s",
				 avd_get_str(name), avd_get_str(type));

	ps = posset_alloc(name, type, seed, max, entries);
	if (!ps) {
		filebench_log(LOG_ERROR, "Cannot define fileset");
		filebench_shutdown(1);
		/* NOT REACHABLE */
		return;
	}

	/* printing all positions */
	for (i = 0; i < avd_get_int(ps->ps_entries); i++)
		filebench_log(LOG_INFO,"pos %d: %llu", i, ps->ps_positions[i]);

}

/*
 * Creates and starts all defined procflow processes. The call to
 * procflow_init() results in creation of the requested number of
 * process instances for each previously defined procflow. The
 * child processes exec() a new instance of filebench, passing it
 * the instance number and address of the shared memory region.
 * The child processes will then create their threads and flowops.
 * The routine then unlocks the run_lock to allow all the processes'
 * threads to start and  waits for all of them to begin execution.
 * Finally, it records the start time and resets the event generation
 * system.
 */
static void
parser_proc_create(cmd_t *cmd)
{
	filebench_shm->shm_1st_err = 0;
	filebench_shm->shm_f_abort = FILEBENCH_OK;

	if (procflow_init() != 0) {
		filebench_log(LOG_ERROR, "Failed to create processes\n");
		filebench_shutdown(1);
	}

	/* Release the read lock, allowing threads to start */
	(void) pthread_rwlock_unlock(&filebench_shm->shm_run_lock);

	/* Wait for all threads to start */
	if (procflow_allstarted() != 0) {
		filebench_log(LOG_ERROR, "Could not start run");
		return;
	}


	if (filebench_shm->shm_required &&
	    (ipc_ismcreate(filebench_shm->shm_required) < 0)) {
		filebench_log(LOG_ERROR, "Could not allocate shared memory");
		return;
	}

	filebench_shm->shm_starttime = gethrtime();
	eventgen_reset();
}

/*
 * Calls fileset_createset() to populate all files and filesets and
 * create all associated, initially existant,  files and subdirectories.
 * If errors are encountered, calls filebench_shutdown()
 * to exit filebench.
 */
static void
parser_fileset_create(cmd_t *cmd)
{
	if (!filecreate_done) {
		filecreate_done = 1;

		/* initialize the random number system first */
		randdist_init();

		/* create all the filesets */
		if (fileset_createset(NULL) != 0) {
			filebench_log(LOG_ERROR, "Failed to create filesets");
			filebench_shutdown(1);
		}
	} else {
		filebench_log(LOG_INFO,
		    "Attempting to create fileset more than once, ignoring");
	}

}

/*
 * Deletes the files and directories that represent files and filesets on the
 * storage medium.
 */
static void
parser_fileset_shutdown(cmd_t *cmd)
{
	filebench_log(LOG_INFO, "Shutting down filesets");
	fileset_delete_all_filesets();
}

/*
 * Shuts down all processes and their associated threads. When finished
 * it deletes interprocess shared memory and resets the event generator.
 * It does not exit the filebench program though.
 */
static void
parser_proc_shutdown(cmd_t *cmd)
{
	filebench_log(LOG_INFO, "Shutting down processes");
	filecreate_done = 0;
	procflow_shutdown();
	if (filebench_shm->shm_required)
		ipc_ismdelete();
	eventgen_reset();
}

/*
 * Ends filebench run after first destoring any interprocess
 * shared memory. The call to filebench_shutdown()
 * also causes filebench to exit.
 */
static void
parser_filebench_shutdown(cmd_t *cmd)
{
	int f_abort = filebench_shm->shm_f_abort;

	ipc_fini();

	if (f_abort == FILEBENCH_ABORT_ERROR)
		filebench_shutdown(1);
	else
		filebench_shutdown(0);
}

/*
 * This is Used for timing runs.Pauses the master thread in one second
 * intervals until the supplied ptime runs out or the f_abort flag
 * is raised. If given a time of zero or less, or the mode is stop on
 * lack of resources, it will pause until f_abort is raised.
 */
static int
parser_pause(int ptime)
{
	int timeslept = 0;

	if ((filebench_shm->shm_rmode == FILEBENCH_MODE_TIMEOUT) &&
	    (ptime > 0)) {
		while (timeslept < ptime) {
			(void) sleep(1);
			timeslept++;
			if (filebench_shm->shm_f_abort)
				break;
		}
	} else {
		/* initial runtime of 0 means run till abort */
		/* CONSTCOND */
		while (1) {
			(void) sleep(1);
			timeslept++;
			if (filebench_shm->shm_f_abort)
				break;
		}
	}
	return (timeslept);
}

/*
 * Do a file bench run. Calls routines to create file sets, files, and
 * processes. It resets the statistics counters, then sleeps for the runtime
 * passed as an argument to it on the command line in 1 second increments.
 * When it is finished sleeping, it collects a snapshot of the statistics
 * and ends the run.
 */
static void
parser_run(cmd_t *cmd)
{
	int runtime;
	int timeslept;

	runtime = cmd->cmd_qty;

	parser_fileset_create(cmd);
	parser_proc_create(cmd);

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	filebench_log(LOG_INFO, "Running...");
	stats_clear();

	timeslept = parser_pause(runtime);

	filebench_log(LOG_INFO, "Run took %d seconds...", timeslept);
	parser_statssnap(cmd);
	parser_proc_shutdown(cmd);
}

/*
 * Similar to parser_run, but gets the sleep time from a variable
 * whose name is supplied as an argument to the command.
 */
static void
parser_run_variable(cmd_t *cmd)
{
	avd_t integer = var_ref_attr(cmd->cmd_tgt1);
	int runtime;
	int timeslept;

	if (integer == NULL) {
		filebench_log(LOG_ERROR, "Unknown variable %s",
		cmd->cmd_tgt1);
		return;
	}

	runtime = avd_get_int(integer);

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	filebench_log(LOG_INFO, "Running...");
	stats_clear();

	timeslept = parser_pause(runtime);

	filebench_log(LOG_INFO, "Run took %d seconds...", timeslept);
	parser_statssnap(cmd);
	parser_proc_shutdown(cmd);
}

char *usagestr = NULL;

/*
 * Prints usage string if defined, else just a message requesting load of a
 * personality.
 */
static void
parser_help(cmd_t *cmd)
{
	if (usagestr) {
		filebench_log(LOG_INFO, "%s", usagestr);
	} else {
		filebench_log(LOG_INFO,
		    "load <personality> (ls "
		    "%s/workloads for list)", fbbasepath);
	}
}

char *varstr = NULL;

/*
 * Prints the string of all var definitions, if there is one.
 */
static void
parser_printvars(cmd_t *cmd)
{
	char *str, *c;

	if (varstr) {
		str = strdup(varstr);
		for (c = str; *c != '\0'; c++) {
			if ((char)*c == '$')
				*c = ' ';
		}
		filebench_log(LOG_INFO, "%s", str);
		free(str);
	}
}

/*
 * Establishes multi-client synchronization socket with synch server.
 */
static void
parser_enable_mc(cmd_t *cmd)
{
	attr_t *attr;
	char *master;
	char *client;

	if ((attr= get_attr(cmd, FSA_MASTER))) {
		master = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "enable multi: no master specified");
		return;
	}

	if ((attr= get_attr(cmd, FSA_CLIENT))) {
		client = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "enable multi: no client specified");
		return;
	}

	mc_sync_open_sock(master, 8001, client);
}

/*
 * Exchanges multi-client synchronization message with synch server.
 */
static void
parser_domultisync(cmd_t *cmd)
{
	attr_t *attr;
	fbint_t value;

	if ((attr = get_attr(cmd, FSA_VALUE)))
		value = avd_get_int(attr->attr_avd);
	else
		value = 1;

	mc_sync_synchronize((int)value);
}

/*
 * Used by the SET command to add a var and default value string to the
 * varstr string. It allocates a new, larger varstr string, copies the
 * old contents of varstr into it, then adds the new var string on the end.
 */
static void
parser_vars(cmd_t *cmd)
{
	char *string = cmd->cmd_tgt1;
	char *newvars;

	if (string == NULL)
		return;

	if (dofile)
		return;

	if (varstr == NULL) {
		newvars = malloc(strlen(string) + 2);
		*newvars = 0;
	} else {
		newvars = malloc(strlen(varstr) + strlen(string) + 2);
		(void) strcpy(newvars, varstr);
	}
	(void) strcat(newvars, string);
	(void) strcat(newvars, " ");

	if (varstr)
		free(varstr);

	varstr = newvars;
}

/*
 * used by the set command to set the integer part of a regular
 * variable, or the appropriate field of a random variable
 */
static void
parser_set_integer(cmd_t *cmd)
{
	var_assign_integer(cmd->cmd_tgt1, cmd->cmd_qty);
}

/*
 * used by the set command to set the integer part of a regular
 * variable from another variable, or the appropriate field of a
 * random variable from another variable
 */
static void
parser_set_var(cmd_t *cmd)
{
	var_assign_var(cmd->cmd_tgt1, cmd->cmd_tgt2);
}

/*
 * Used by the set command to set up for a binary operation of a
 * variable from a var, with an integer
 */
static void
parser_set_var_op_int(cmd_t *cmd)
{
	printf("parser_set_var_op_int: Called\n");
	switch (cmd->cmd_subtype) {
	case FSK_PLUS:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_SUM_IV,
		    cmd->cmd_tgt2, cmd->cmd_qty);
		break;

	case FSK_MINUS:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_IV_DIF_INT,
		    cmd->cmd_tgt2, cmd->cmd_qty);
		break;

	case FSK_MULTIPLY:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_MUL_IV,
		    cmd->cmd_tgt2, cmd->cmd_qty);
		break;

	case FSK_DIVIDE:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_IV_DIV_INT,
		    cmd->cmd_tgt2, cmd->cmd_qty);
		break;
	}
}

/*
 * Used by the set command to set up for a binary operation of an
 * integer with a variable from a var
 */
static void
parser_set_int_op_var(cmd_t *cmd)
{
	switch (cmd->cmd_subtype) {
	case FSK_PLUS:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_SUM_IV,
		    cmd->cmd_tgt3, cmd->cmd_qty);
		break;

	case FSK_MINUS:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_DIF_IV,
		    cmd->cmd_tgt3, cmd->cmd_qty);
		break;

	case FSK_MULTIPLY:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_MUL_IV,
		    cmd->cmd_tgt3, cmd->cmd_qty);
		break;

	case FSK_DIVIDE:
		var_assign_op_var_int(cmd->cmd_tgt1, VAR_IND_INT_DIV_IV,
		    cmd->cmd_tgt3, cmd->cmd_qty);
		break;
	}
}

/*
 * Used by the set command to set up for a binary operation of two
 * variables from other vars.
 */
static void
parser_set_var_op_var(cmd_t *cmd)
{
	switch (cmd->cmd_subtype) {
	case FSK_PLUS:
		var_assign_op_var_var(cmd->cmd_tgt1, VAR_IND_IV_SUM_IV,
		    cmd->cmd_tgt2, cmd->cmd_tgt3);
		break;

	case FSK_MINUS:
		var_assign_op_var_var(cmd->cmd_tgt1, VAR_IND_IV_DIF_IV,
		    cmd->cmd_tgt2, cmd->cmd_tgt3);
		break;

	case FSK_MULTIPLY:
		var_assign_op_var_var(cmd->cmd_tgt1, VAR_IND_IV_MUL_IV,
		    cmd->cmd_tgt2, cmd->cmd_tgt3);
		break;

	case FSK_DIVIDE:
		var_assign_op_var_var(cmd->cmd_tgt1, VAR_IND_IV_DIV_IV,
		    cmd->cmd_tgt2, cmd->cmd_tgt3);
		break;
	}
}


/*
 * Sleeps for cmd->cmd_qty seconds, one second at a time.
 */
static void
parser_warmup(cmd_t *cmd)
{
	int sleeptime;

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	sleeptime = cmd->cmd_qty;
	filebench_log(LOG_INFO, "Warming up...");

	(void) parser_pause(sleeptime);
}

/*
 * Same as parser_sleep, except the sleep time is obtained from a variable
 * whose name is passed to it as an argument on the command line.
 */
static void
parser_warmup_variable(cmd_t *cmd)
{
	avd_t integer = var_ref_attr(cmd->cmd_tgt1);
	int sleeptime;

	if (integer == NULL) {
		filebench_log(LOG_ERROR, "Unknown variable %s",
		cmd->cmd_tgt1);
		return;
	}

	sleeptime = avd_get_int(integer);

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	filebench_log(LOG_INFO, "Warming up...");

	(void) parser_pause(sleeptime);
}

/*
 * Sleeps for cmd->cmd_qty seconds, one second at a time.
 */
static void
parser_sleep(cmd_t *cmd)
{
	int sleeptime;
	int timeslept;

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	sleeptime = cmd->cmd_qty;
	filebench_log(LOG_INFO, "Running...");

	timeslept = parser_pause(sleeptime);

	filebench_log(LOG_INFO, "Run took %d seconds...", timeslept);
}

/*
 * Same as parser_sleep, except the sleep time is obtained from a variable
 * whose name is passed to it as an argument on the command line.
 */
static void
parser_sleep_variable(cmd_t *cmd)
{
	avd_t integer = var_ref_attr(cmd->cmd_tgt1);
	int sleeptime;
	int timeslept;

	if (integer == NULL) {
		filebench_log(LOG_ERROR, "Unknown variable %s",
		cmd->cmd_tgt1);
		return;
	}

	sleeptime = avd_get_int(integer);

	/* check for startup errors */
	if (filebench_shm->shm_f_abort)
		return;

	filebench_log(LOG_INFO, "Running...");

	timeslept = parser_pause(sleeptime);

	filebench_log(LOG_INFO, "Run took %d seconds...", timeslept);
}

/*
 * Parser log prints the values of a list of variables to the log file.
 * The list of variables is placed on the command line, separated
 * by comas and the entire list is enclosed in quotes.
 * For example, if $dir contains "/export/home/tmp" and $filesize = 1048576,
 * then typing: log "$dir, $filesize" prints: log /export/home/tmp, 1048576
 */
static void
parser_log(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE, "log %s", string);
	filebench_log(LOG_LOG, "%s", string);
}

/*
 * Implements the stats directory command. changes the directory for
 * dumping statistics to supplied directory path. For example:
 * 	stats directory /tmp
 * changes the stats directory to "/tmp".
 */
static void
parser_directory(cmd_t *cmd)
{
	char newdir[MAXPATHLEN];
	char *dir;
	int ret;

	if ((dir = parser_list2string(cmd->cmd_param_list)) == NULL) {
		filebench_log(LOG_ERROR, "Cannot interpret directory");
		return;
	}

	*newdir = 0;
	/* Change dir relative to cwd if path not fully qualified */
	if (*dir != '/') {
		(void) strcat(newdir, cwd);
		(void) strcat(newdir, "/");
	}
	(void) strcat(newdir, dir);
	(void) mkdir(newdir, 0755);
	filebench_log(LOG_VERBOSE, "Change dir to %s", newdir);
	ret = chdir(newdir);
	free(dir);
}

#define	PIPE_PARENT 1
#define	PIPE_CHILD  0

/*
 * Runs the quoted unix command as a background process. Intended for
 * running statistics gathering utilities such as mpstat while the filebench
 * workload is running. Also records the pid's of the background processes
 * so that parser_statssnap() can terminate them when the run completes.
 */
static void
parser_statscmd(cmd_t *cmd)
{
	char *string;
	pid_t pid;
	pidlist_t *pidlistent;
	int pipe_fd[2];
	int newstdout;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	if ((pipe(pipe_fd)) < 0) {
		filebench_log(LOG_ERROR, "statscmd pipe failed");
		return;
	}

#ifdef HAVE_FORK1
	if ((pid = fork1()) < 0) {
		filebench_log(LOG_ERROR, "statscmd fork failed");
		return;
	}
#elif HAVE_FORK
	if ((pid = fork()) < 0) {
		filebench_log(LOG_ERROR, "statscmd fork failed");
		return;
	}
#else
	Crash! - Need code to deal with no fork1!
#endif /* HAVE_FORK1 */

	if (pid == 0) {

		setsid();

		filebench_log(LOG_VERBOSE,
		    "Backgrounding %s", string);
		/*
		 * Child
		 * - close stdout
		 * - dup to create new stdout
		 * - close pipe fds
		 */
		(void) close(1);

		if ((newstdout = dup(pipe_fd[PIPE_CHILD])) < 0) {
			filebench_log(LOG_ERROR,
			    "statscmd dup failed: %s",
			    strerror(errno));
		}

		(void) close(pipe_fd[PIPE_PARENT]);
		(void) close(pipe_fd[PIPE_CHILD]);

		if (system(string) < 0) {
			filebench_log(LOG_ERROR,
			    "statscmd exec failed: %s",
			    strerror(errno));
		}
		/* Failed! */
		exit(1);

	} else {

		/* Record pid in pidlist for subsequent reaping by stats snap */
		if ((pidlistent = (pidlist_t *)malloc(sizeof (pidlist_t)))
		    == NULL) {
			filebench_log(LOG_ERROR, "pidlistent malloc failed");
			return;
		}

		pidlistent->pl_pid = pid;
		pidlistent->pl_fd = pipe_fd[PIPE_PARENT];
		(void) close(pipe_fd[PIPE_CHILD]);

		/* Add fileobj to global list */
		if (pidlist == NULL) {
			pidlist = pidlistent;
			pidlistent->pl_next = NULL;
		} else {
			pidlistent->pl_next = pidlist;
			pidlist = pidlistent;
		}
	}
}

/*
 * Launches a shell to run the unix command supplied in the argument.
 * The command should be enclosed in quotes, as in:
 * 	system "rm xyz"
 * which would run the "rm" utility to delete the file "xyz".
 */
static void
parser_system(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE,
	    "Running '%s'", string);

	if (system(string) < 0) {
		filebench_log(LOG_ERROR,
		    "system exec failed: %s",
		    strerror(errno));
		filebench_shutdown(1);
	}
	free(string);
}

/*
 * Echos string supplied with command to the log.
 */
static void
parser_echo(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_INFO, "%s", string);
}

static void parser_fscheck(cmd_t *cmd) {
	return;
}

#if 0
/* XXX: do not support this command for now */
/*
 * Checks to see if the specified data directory exists and it's mounted file
 * system is the correct type.
 */
static void
parser_fscheck(cmd_t *cmd)
{
	int fstype_idx;
	char *pathname = NULL;
	char *filesys = "tmpfs";
	char string[MAXPATHLEN];
	struct statvfs64 statbuf;
	attr_t *attr;

	if (cmd->cmd_attr_list == NULL)
		return;

	for (attr = cmd->cmd_attr_list; attr; attr = attr->attr_next) {

		switch(attr->attr_name) {
		case FSA_PATH:
			pathname = avd_get_str(attr->attr_avd);
			break;
		case FSA_FSTYPE:
			filesys = avd_get_str(attr->attr_avd);
			break;
		}
	}

	if (pathname == NULL)
		return;

	if (statvfs64(pathname, &statbuf) < 0) {
		filebench_log(LOG_ERROR,
		    "%s error with supplied data path name: %s; exiting",
		    strerror(errno), pathname);
		filebench_shutdown(1);
		return;
	}

	if (strncmp(filesys, statbuf.f_basetype, FSTYPSZ) != 0) {
		filebench_log(LOG_ERROR,
		    "File System is of type %s, NOT %s as indicated",
		    statbuf.f_basetype, filesys);
		filebench_shutdown(1);
		return;
	}
}
#endif

/*
 * Checks to see if any filesets need to have their caches flushed, and
 * if so invokes the fs_flush script.
 */
static void
parser_fsflush(cmd_t *cmd)
{
	fileset_t *fileset;
	char **fspathlist;
	char *pathname = NULL;
	char *filesys = NULL;
	char string[MAXPATHLEN];
	attr_t *attr;
	int fsidx;

	if ((attr = cmd->cmd_attr_list) == NULL)
		return;

	/* Get supplied file system type */
	if (attr->attr_name == FSA_FSTYPE)
		filesys = avd_get_str(attr->attr_avd);

	if (filesys == NULL) {
		filebench_log(LOG_ERROR,
		    "FSFLUSH command lacks file system type");
		return;
	}

	/* Check all filesets for any that remain cached and count them*/
	fsidx = 0;
	for (fileset = filebench_shm->shm_filesetlist; fileset != NULL;
	     fileset = fileset->fs_next) {

		if (avd_get_bool(fileset->fs_cached))
			return;

		fsidx++;
	}

	/* allocated space for fileset path pointers */
	fspathlist = (char **)malloc(fsidx * sizeof(char *));

	/* If flushing still required, flush all filesets */
	fsidx = 0;
	for (fileset = filebench_shm->shm_filesetlist; fileset != NULL;
	     fileset = fileset->fs_next) {
		int idx;

		if ((pathname = avd_get_str(fileset->fs_path)) == NULL)
			return;

		for (idx = 0; idx < fsidx; idx++) {
			if (strcmp(pathname, fspathlist[idx]) == 0)
				break;
		}

		if (fsidx == idx) {

			/* found a new path */
			fspathlist[fsidx++] = pathname;

			/* now flush it */
			snprintf(string, MAXPATHLEN,
			    "%s/scripts/fs_flush %s %s", fbbasepath,
			    filesys, pathname);

			if (system(string) < 0) {
				filebench_log(LOG_ERROR,
				    "exec of fs_flush script failed: %s",
				    strerror(errno));
				filebench_shutdown(1);
			}
		}
	}
}

/*
 * Prints out the version of FileBench.
 */
static void
parser_version(cmd_t *cmd)
{
	filebench_log(LOG_INFO, "FileBench Version: %s", FILEBENCH_VERSION);
}

/*
 * Sets osprof_enabled option
 */
static void
parser_osprof_enable(cmd_t *cmd)
{
	osprof_enabled = 1;
	filebench_log(LOG_INFO, "OSprof enabled");
}

/*
 * Resets osprof_enabled option
 */
static void
parser_osprof_disable(cmd_t *cmd)
{
	osprof_enabled = 0;
	filebench_log(LOG_INFO, "OSprof disabled");
}

/*
 * Adds the string supplied as the argument to the usage command
 * to the end of the string printed by the help command.
 */
static void
parser_usage(cmd_t *cmd)
{
	char *string;
	char *newusage;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	if (dofile)
		return;

	if (usagestr == NULL) {
		newusage = malloc(strlen(string) + 2);
		*newusage = 0;
	} else {
		newusage = malloc(strlen(usagestr) + strlen(string) + 2);
		(void) strcpy(newusage, usagestr);
	}
	(void) strcat(newusage, "\n");
	(void) strcat(newusage, string);

	if (usagestr)
		free(usagestr);

	usagestr = newusage;

	filebench_log(LOG_INFO, "%s", string);
}

/*
 * Updates the global dump filename with the filename supplied
 * as the command's argument. Then dumps the statistics of each
 * worker flowop into the dump file, followed by a summary of
 * overall totals.
 */
static void
parser_statsdump(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE,
	    "Stats dump to file '%s'", string);

	stats_dump(string);

	free(string);
}

/*
 * Same as statsdump, but outputs in a computer friendly format.
 */
static void
parser_statsmultidump(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE,
	    "Stats dump to file '%s'", string);

	stats_multidump(string);

	free(string);
}

/*
 * Same as parser_statsdump, but in xml format.
 */
static void
parser_statsxmldump(cmd_t *cmd)
{
	char *string;

	if (cmd->cmd_param_list == NULL)
		return;

	string = parser_list2string(cmd->cmd_param_list);

	if (string == NULL)
		return;

	filebench_log(LOG_VERBOSE,
	    "Stats dump to file '%s'", string);

	stats_xmldump(string);

	free(string);
}

/*
 * Kills off background statistics collection processes, then takes a snapshot
 * of the filebench run's collected statistics using stats_snap() from
 * stats.c.
 */
static void
parser_statssnap(cmd_t *cmd)
{
	pidlist_t *pidlistent;
	int stat;
	pid_t pid;

	for (pidlistent = pidlist; pidlistent != NULL;
	    pidlistent = pidlistent->pl_next) {
		filebench_log(LOG_VERBOSE, "Killing session %d for pid %d",
		    getsid(pidlistent->pl_pid),
		    pidlistent->pl_pid);
		if (pidlistent->pl_fd)
			(void) close(pidlistent->pl_fd);
#ifdef HAVE_SIGSEND
		sigsend(P_SID, getsid(pidlistent->pl_pid), SIGTERM);
#else
		(void) kill(-1, SIGTERM);
#endif

		/* Close pipe */
		if (pidlistent->pl_fd)
			(void) close(pidlistent->pl_fd);

		/* Wait for cmd and all its children */
		while ((pid = waitpid(pidlistent->pl_pid * -1, &stat, 0)) > 0)
			filebench_log(LOG_DEBUG_IMPL,
			"Waited for pid %d", (int)pid);
	}

	for (pidlistent = pidlist; pidlistent != NULL;
	    pidlistent = pidlistent->pl_next) {
		free(pidlistent);
	}

	pidlist = NULL;
	stats_snap();
}

/*
 * Shutdown filebench.
 */
static void
parser_abort(int arg)
{
	(void) sigignore(SIGINT);
	filebench_log(LOG_INFO, "Aborting...");
	filebench_shutdown(1);
}

/*
 * define a random variable and initialize the distribution parameters
 */
static void
parser_randvar_define(cmd_t *cmd)
{
	var_t		*var;
	randdist_t	*rndp;
	attr_t		*attr;
	char		*name;

	/* Get the name for the random variable */
	if ((attr = get_attr(cmd, FSA_NAME))) {
		name = avd_get_str(attr->attr_avd);
	} else {
		filebench_log(LOG_ERROR,
		    "define randvar: no name specified");
		return;
	}

	if ((var = var_define_randvar(name)) == NULL) {
		filebench_log(LOG_ERROR,
		    "define randvar: failed for random variable %s",
		    name);
		return;
	}

	rndp = var->var_val.randptr;
	rndp->rnd_type = 0;

	/* Get the source of the random numbers */
	if ((attr = get_attr_integer(cmd, FSA_RANDSRC))) {
		int randsrc = (int)avd_get_int(attr->attr_avd);

		switch (randsrc) {
		case FSV_URAND:
			rndp->rnd_type |= RAND_SRC_URANDOM;
			break;
		case FSV_RAND48:
			rndp->rnd_type |= RAND_SRC_GENERATOR;
			break;
		}
	} else {
		/* default to rand48 random number generator */
		rndp->rnd_type |= RAND_SRC_GENERATOR;
	}

	/* Get the min value of the random distribution */
	if ((attr = get_attr_integer(cmd, FSA_RANDMIN)))
		rndp->rnd_min = attr->attr_avd;
	else
		rndp->rnd_min = avd_int_alloc(0);

	/* Get the roundoff value for the random distribution */
	if ((attr = get_attr_integer(cmd, FSA_RANDROUND)))
		rndp->rnd_round = attr->attr_avd;
	else
		rndp->rnd_round = avd_int_alloc(0);

	/* Get a tablular probablility distribution if there is one */
	if ((attr = get_attr(cmd, FSA_RANDTABLE))) {
		rndp->rnd_probtabs = (probtabent_t *)(attr->attr_obj);
		rndp->rnd_type |= RAND_TYPE_TABLE;

		/* no need for the rest of the attributes */
		return;
	} else {
		rndp->rnd_probtabs = NULL;
	}

	/* Get the type for the random variable */
	if ((attr = get_attr(cmd, FSA_TYPE))) {
		int disttype = (int)avd_get_int(attr->attr_avd);

		switch (disttype) {
		case FSV_RANDUNI:
			rndp->rnd_type |= RAND_TYPE_UNIFORM;
			break;
		case FSA_RANDGAMMA:
			rndp->rnd_type |= RAND_TYPE_GAMMA;
			break;
		case FSV_RANDTAB:
			filebench_log(LOG_ERROR,
			    "Table distribution type without prob table");
			break;
		}
	} else {
		/* default to gamma distribution type */
		rndp->rnd_type |= RAND_TYPE_GAMMA;
	}

	/* Get the seed for the random variable */
	if ((attr = get_attr_integer(cmd, FSA_RANDSEED)))
		rndp->rnd_seed = attr->attr_avd;
	else
		rndp->rnd_seed = avd_int_alloc(0);

	/* Get the gamma value of the random distribution */
	if ((attr = get_attr_integer(cmd, FSA_RANDGAMMA)))
		rndp->rnd_gamma = attr->attr_avd;
	else
		rndp->rnd_gamma = avd_int_alloc(1500);

	/* Get the mean value of the random distribution */
	if ((attr = get_attr_integer(cmd, FSA_RANDMEAN))) {
		rndp->rnd_mean = attr->attr_avd;
	} else if ((rndp->rnd_type & RAND_TYPE_MASK) == RAND_TYPE_GAMMA) {
		rndp->rnd_mean = NULL;
	} else {
		rndp->rnd_mean = avd_int_alloc(0);
	}
}

/*
 * Set a specified random distribution parameter in a random variable.
 */
static void
parser_randvar_set(cmd_t *cmd)
{
	var_t		*randvar;
	randdist_t	*rndp;
	avd_t	value;

	if ((randvar = var_find_randvar(cmd->cmd_tgt1)) == NULL) {
		filebench_log(LOG_ERROR,
		    "set randvar: failed",
		    cmd->cmd_tgt1);
		return;
	}

	rndp = randvar->var_val.randptr;
	value = cmd->cmd_attr_list->attr_avd;

	switch (cmd->cmd_qty) {
	case FSS_TYPE:
		{
			int disttype = (int)avd_get_int(value);

			rndp->rnd_type &= (~RAND_TYPE_MASK);

			switch (disttype) {
			case FSV_RANDUNI:
				rndp->rnd_type |= RAND_TYPE_UNIFORM;
				break;
			case FSA_RANDGAMMA:
				rndp->rnd_type |= RAND_TYPE_GAMMA;
				break;
			case FSV_RANDTAB:
				rndp->rnd_type |= RAND_TYPE_TABLE;
				break;
			}
			break;
		}

	case FSS_SRC:
		{
			int randsrc = (int)avd_get_int(value);

			rndp->rnd_type &=
			    (~(RAND_SRC_URANDOM | RAND_SRC_GENERATOR));

			switch (randsrc) {
			case FSV_URAND:
				rndp->rnd_type |= RAND_SRC_URANDOM;
				break;
			case FSV_RAND48:
				rndp->rnd_type |= RAND_SRC_GENERATOR;
				break;
			}
			break;
		}

	case FSS_SEED:
		rndp->rnd_seed = value;
		break;

	case FSS_GAMMA:
		rndp->rnd_gamma = value;
		break;

	case FSS_MEAN:
		rndp->rnd_mean = value;
		break;

	case FSS_MIN:
		rndp->rnd_min = value;
		break;

	case FSS_ROUND:
		rndp->rnd_round = value;
		break;

	default:
		filebench_log(LOG_ERROR, "setrandvar: undefined attribute");
	}
}

/*
 * alloc_cmd() allocates the required resources for a cmd_t. On failure, a
 * filebench_log is issued and NULL is returned.
 */
static cmd_t *
alloc_cmd(void)
{
	cmd_t *cmd;

	if ((cmd = malloc(sizeof (cmd_t))) == NULL) {
		filebench_log(LOG_ERROR, "Alloc cmd failed");
		return (NULL);
	}

	(void) memset(cmd, 0, sizeof (cmd_t));

	return (cmd);
}

/*
 * Allocates an attr_t structure and zeros it. Returns NULL on failure, or
 * a pointer to the attr_t.
 */
static attr_t *
alloc_attr(void)
{
	attr_t *attr;

	if ((attr = malloc(sizeof (attr_t))) == NULL) {
		return (NULL);
	}

	(void) memset(attr, 0, sizeof (attr_t));
	return (attr);
}

/*
 * Allocates a probtabent_t structure and zeros it. Returns NULL on failure, or
 * a pointer to the probtabent_t.
 */
static probtabent_t *
alloc_probtabent(void)
{
	probtabent_t *rte;

	if ((rte = malloc(sizeof (probtabent_t))) == NULL) {
		return (NULL);
	}

	(void) memset(rte, 0, sizeof (probtabent_t));
	return (rte);
}

/*
 * Allocates an attr_t structure and puts the supplied var_t into
 * its attr_avd location, and sets its name to FSA_LVAR_ASSIGN
 */
static attr_t *
alloc_lvar_attr(var_t *var)
{
	attr_t *attr;

	if ((attr = alloc_attr()) == NULL)
		return (NULL);

	attr->attr_name = FSA_LVAR_ASSIGN;
	attr->attr_avd = (avd_t)var;

	return (attr);
}


/*
 * Searches the attribute list for the command for the named attribute type.
 * The attribute list is created by the parser from the list of attributes
 * supplied with certain commands, such as the define and flowop commands.
 * Returns a pointer to the attribute structure if the named attribute is
 * found, otherwise returns NULL. If the attribute includes a parameter list,
 * the list is converted to a string and stored in the attr_avd field of
 * the returned attr_t struct.
 */
static attr_t *
get_attr_fileset(cmd_t *cmd, int64_t name)
{
	attr_t *attr;
	attr_t *rtn = NULL;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {
		filebench_log(LOG_DEBUG_IMPL,
		    "attr %d = %d %llx?",
		    attr->attr_name,
		    name,
		    attr->attr_avd);

		if (attr->attr_name == name)
			rtn = attr;
	}

	if (rtn == NULL)
		return (NULL);

	if (rtn->attr_param_list) {
		filebench_log(LOG_DEBUG_SCRIPT, "attr is param list");
		rtn->attr_avd = parser_list2varstring(rtn->attr_param_list);
	}

	return (rtn);
}


/*
 * Searches the attribute list for the command for the named attribute type.
 * The attribute list is created by the parser from the list of attributes
 * supplied with certain commands, such as the define and flowop commands.
 * Returns a pointer to the attribute structure if the named attribute is
 * found, otherwise returns NULL. If the attribute includes a parameter list,
 * the list is converted to a string and stored in the attr_avd field of
 * the returned attr_t struct.
 */
static attr_t *
get_attr(cmd_t *cmd, int64_t name)
{
	attr_t *attr;
	attr_t *rtn = NULL;
	char *string;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {
		filebench_log(LOG_DEBUG_IMPL,
		    "attr %d = %d %llx?",
		    attr->attr_name,
		    name,
		    attr->attr_avd);

		if (attr->attr_name == name)
			rtn = attr;
	}

	if (rtn == NULL)
		return (NULL);

	if (rtn->attr_param_list) {
		filebench_log(LOG_DEBUG_SCRIPT, "attr is param list");
		string = parser_list2string(rtn->attr_param_list);
		if (string != NULL) {
			rtn->attr_avd = avd_str_alloc(string);
			filebench_log(LOG_DEBUG_SCRIPT,
			    "attr string %s", string);
		}
	}

	return (rtn);
}

/*
 * Similar to get_attr, but converts the parameter string supplied with the
 * named attribute to an integer and stores the integer in the attr_avd
 * portion of the returned attr_t struct.
 */
static attr_t *
get_attr_integer(cmd_t *cmd, int64_t name)
{
	attr_t *attr;
	attr_t *rtn = NULL;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {
		if (attr->attr_name == name)
			rtn = attr;
	}

	if (rtn == NULL)
		return (NULL);

	if (rtn->attr_param_list)
		rtn->attr_avd = parser_list2avd(rtn->attr_param_list);

	return (rtn);
}

/*
 * Similar to get_attr, but converts the parameter string supplied with the
 * named attribute to an integer and stores the integer in the attr_avd
 * portion of the returned attr_t struct. If no parameter string is supplied
 * then it defaults to TRUE (1).
 */
static attr_t *
get_attr_bool(cmd_t *cmd, int64_t name)
{
	attr_t *attr;
	attr_t *rtn = NULL;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {
		if (attr->attr_name == name)
			rtn = attr;
	}

	if (rtn == NULL)
		return (NULL);

	if (rtn->attr_param_list) {
		rtn->attr_avd = parser_list2avd(rtn->attr_param_list);

	} else if (rtn->attr_avd == NULL) {
		rtn->attr_avd = avd_bool_alloc(TRUE);
	}

	/* boolean attributes cannot point to random variables */
	if (AVD_IS_RANDOM(rtn->attr_avd)) {
		filebench_log(LOG_ERROR,
		    "define flowop: Boolean attr %s cannot be random", name);
		filebench_shutdown(1);
		return (NULL);
	}

	return (rtn);
}

/*
 * removes the newly allocated local var from the shared local var
 * list, then puts it at the head of the private local var list
 * supplied as the second argument.
 */
static void
add_lvar_to_list(var_t *newlvar, var_t **lvar_list)
{
	var_t *prev;

	/* remove from shared local list, if there */
	if (newlvar == filebench_shm->shm_var_loc_list) {
		/* on top of list, just grap */
		filebench_shm->shm_var_loc_list = newlvar->var_next;
	} else {
		/* find newvar on list and remove */
		for (prev = filebench_shm->shm_var_loc_list; prev;
		    prev = prev->var_next) {
			if (prev->var_next == newlvar)
				prev->var_next = newlvar->var_next;
		}
	}
	newlvar->var_next = NULL;

	/* add to flowop private local list at head */
	newlvar->var_next = *lvar_list;
	*lvar_list = newlvar;
}

/*
 * Searches the attribute list for the command for any allocated local
 * variables. The attribute list is created by the parser from the list of
 * attributes supplied with certain commands, such as the define and flowop
 * commands. Places all found local vars onto the flowop's local variable
 * list. 
 */
static void
get_attr_lvars(cmd_t *cmd, flowop_t *flowop)
{
	attr_t *attr;
	var_t *orig_lvar_list;

	/* save the local var list */
	orig_lvar_list = flowop->fo_lvar_list;

	for (attr = cmd->cmd_attr_list; attr != NULL;
	    attr = attr->attr_next) {

		if (attr->attr_name == FSA_LVAR_ASSIGN) {
			var_t *newvar;

			if ((newvar = (var_t *)attr->attr_avd) == NULL)
				continue;

			add_lvar_to_list(newvar, &flowop->fo_lvar_list);
			var_update_comp_lvars(newvar, orig_lvar_list, NULL);
		}
	}
}

/*
 * Allocates memory for a list_t structure, initializes it to zero, and
 * returns a pointer to it. On failure, returns NULL.
 */
static list_t *
alloc_list()
{
	list_t *list;

	if ((list = malloc(sizeof (list_t))) == NULL) {
		return (NULL);
	}

	(void) memset(list, 0, sizeof (list_t));
	return (list);
}


#define	USAGE1	\
"Usage:\n" \
"go_filebench: interpret f script and generate file workload\n" \
"Options:\n" \
"   [-h] Display verbose help\n" \
"   [-p] Disable opening /proc to set uacct to enable truss\n"

#define	PARSER_CMDS \
"create [files|filesets|processes]\n" \
"stats [clear|snap]\n" \
"stats command \"shell command $var1,$var2...\"\n" \
"stats directory <directory>\n" \
"sleep <sleep-value>\n" \
"quit\n\n" \
"Variables:\n" \
"set $var = value\n" \
"    $var   - regular variables\n" \
"    ${var} - internal special variables\n" \
"    $(var) - environment variables\n\n"

#define	PARSER_EXAMPLE \
"Example:\n\n" \
"#!" FILEBENCHDIR "/bin/go_filebench -f\n" \
"\n" \
"define file name=bigfile,path=bigfile,size=1g,prealloc,reuse\n" \
"define process name=randomizer\n" \
"{\n" \
"  thread random-thread procname=randomizer\n"	\
"  {\n" \
"    flowop read name=random-read,filename=bigfile,iosize=16k,random\n" \
"  }\n" \
"}\n" \
"create files\n" \
"create processes\n" \
"stats clear\n" \
"sleep 30\n" \
"stats snap\n"

/*
 * usage() display brief or verbose help for the filebench(1) command.
 */
static void
usage(int help)
{
	if (help >= 1)
		(void) fprintf(stderr, USAGE1);
	if (help >= 2) {

		(void) fprintf(stderr,
		    "\n'f' language definition:\n\n");
		fileset_usage();
		procflow_usage();
		threadflow_usage();
		flowoplib_usage();
		eventgen_usage();
		(void) fprintf(stderr, PARSER_CMDS);
		(void) fprintf(stderr, PARSER_EXAMPLE);
	}
	exit(E_USAGE);
}

int
yywrap()
{
	if (parentscript) {
		yyin = parentscript;
		yy_switchfilescript(yyin);
		parentscript = NULL;
		return (0);
	} else
		return (1);
}
#line 4382 "y.tab.c"
/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack()
{
    int newsize, i;
    short *newss;
    YYSTYPE *newvs;

    if ((newsize = yystacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;
    i = yyssp - yyss;
    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
      (short *)malloc(newsize * sizeof *newss);
    if (newss == NULL)
        return -1;
    yyss = newss;
    yyssp = newss + i;
    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
      (YYSTYPE *)malloc(newsize * sizeof *newvs);
    if (newvs == NULL)
        return -1;
    yyvs = newvs;
    yyvsp = newvs + i;
    yystacksize = newsize;
    yysslim = yyss + newsize - 1;
    return 0;
}

#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab

#ifndef YYPARSE_PARAM
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG void
#define YYPARSE_PARAM_DECL
#else	/* ! ANSI-C/C++ */
#define YYPARSE_PARAM_ARG
#define YYPARSE_PARAM_DECL
#endif	/* ANSI-C/C++ */
#else	/* YYPARSE_PARAM */
#ifndef YYPARSE_PARAM_TYPE
#define YYPARSE_PARAM_TYPE void *
#endif
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#else	/* ! ANSI-C/C++ */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
#endif	/* ANSI-C/C++ */
#endif	/* ! YYPARSE_PARAM */

int
yyparse (YYPARSE_PARAM_ARG)
    YYPARSE_PARAM_DECL
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register const char *yys;

    if ((yys = getenv("YYDEBUG")))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    if (yyss == NULL && yygrowstack()) goto yyoverflow;
    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if ((yyn = yydefred[yystate])) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yysslim && yygrowstack())
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#if defined(lint) || defined(__GNUC__)
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#if defined(lint) || defined(__GNUC__)
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yysslim && yygrowstack())
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
#line 262 "parser_gram.y"
{
	if (yyvsp[0].cmd->cmd != NULL)
		yyvsp[0].cmd->cmd(yyvsp[0].cmd);

	free(yyvsp[0].cmd);
}
break;
case 2:
#line 269 "parser_gram.y"
{
	if (dofile)
		YYABORT;
}
break;
case 4:
#line 276 "parser_gram.y"
{
	filebench_log(LOG_DEBUG_IMPL, "inner_command %zx", yyvsp[0].cmd);
	yyval.cmd = yyvsp[0].cmd;
}
break;
case 5:
#line 281 "parser_gram.y"
{
	cmd_t *list = NULL;
	cmd_t *list_end = NULL;

	/* Find end of list */
	for (list = yyvsp[-1].cmd; list != NULL;
	    list = list->cmd_next)
		list_end = list;

	list_end->cmd_next = yyvsp[0].cmd;

	filebench_log(LOG_DEBUG_IMPL,
	    "inner_commands adding cmd %zx to list %zx", yyvsp[0].cmd, yyvsp[-1].cmd);

	yyval.cmd = yyvsp[-1].cmd;
}
break;
case 37:
#line 332 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	filebench_log(LOG_DEBUG_IMPL, "foreach_command %zx", yyval.cmd);
}
break;
case 38:
#line 338 "parser_gram.y"
{
	cmd_t *inner_cmd;
	list_t *list;

	yyval.cmd = yyvsp[-6].cmd;
	yyval.cmd->cmd_list = yyvsp[-1].cmd;
	yyval.cmd->cmd_tgt1 = yyvsp[-5].sval;
	yyval.cmd->cmd_param_list = yyvsp[-3].list;
	yyval.cmd->cmd = parser_foreach_integer;

	for (list = yyval.cmd->cmd_param_list; list != NULL;
	    list = list->list_next) {
		for (inner_cmd = yyval.cmd->cmd_list;
		    inner_cmd != NULL;
		    inner_cmd = inner_cmd->cmd_next) {
			filebench_log(LOG_DEBUG_IMPL,
			    "packing foreach: %zx %s=%llu, cmd %zx",
			    yyval.cmd, yyval.cmd->cmd_tgt1,
			    (u_longlong_t)avd_get_int(list->list_integer),
			    inner_cmd);
		}
	}
}
break;
case 39:
#line 361 "parser_gram.y"
{
	cmd_t *inner_cmd;
	list_t *list;

	yyval.cmd = yyvsp[-6].cmd;
	yyval.cmd->cmd_list = yyvsp[-1].cmd;
	yyval.cmd->cmd_tgt1 = yyvsp[-5].sval;
	yyval.cmd->cmd_param_list = yyvsp[-3].list;
	yyval.cmd->cmd = parser_foreach_string;

	for (list = yyval.cmd->cmd_param_list; list != NULL;
	    list = list->list_next) {
		for (inner_cmd = yyval.cmd->cmd_list;
		    inner_cmd != NULL;
		    inner_cmd = inner_cmd->cmd_next) {
			filebench_log(LOG_DEBUG_IMPL,
			    "packing foreach: %zx %s=%s, cmd %zx",
			    yyval.cmd,
			    yyval.cmd->cmd_tgt1,
			    *list->list_string, inner_cmd);
		}
	}
}
break;
case 40:
#line 386 "parser_gram.y"
{
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_integer = avd_int_alloc(yyvsp[0].ival);
}
break;
case 41:
#line 393 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_integer = avd_int_alloc(yyvsp[0].ival);

	/* Find end of list */
	for (list = yyvsp[-2].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-2].list;
}
break;
case 42:
#line 411 "parser_gram.y"
{
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[-1].sval);
}
break;
case 43:
#line 418 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[-1].sval);

	/* Find end of list */
	for (list = yyvsp[-4].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-4].list;
}
break;
case 44:
#line 436 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_eventgen;
}
break;
case 45:
#line 442 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 46:
#line 447 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = parser_system;
}
break;
case 47:
#line 456 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = parser_echo;
}
break;
case 48:
#line 465 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_version;
}
break;
case 49:
#line 472 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_osprof_enable;
}
break;
case 50:
#line 479 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_osprof_disable;
}
break;
case 51:
#line 486 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = parser_usage;
}
break;
case 52:
#line 495 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd = parser_printvars;
}
break;
case 53:
#line 503 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd = parser_enable_mc;
}
break;
case 54:
#line 510 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 55:
#line 515 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd = parser_domultisync;
	yyval.cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 56:
#line 524 "parser_gram.y"
{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;
	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);
}
break;
case 57:
#line 530 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-2].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-2].list;
}
break;
case 58:
#line 548 "parser_gram.y"
{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);
}
break;
case 59:
#line 555 "parser_gram.y"
{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);
}
break;
case 60:
#line 563 "parser_gram.y"
{
	yyval.list = yyvsp[0].list;
}
break;
case 61:
#line 566 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add string */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;

}
break;
case 62:
#line 584 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;
}
break;
case 63:
#line 601 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add string */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;

}
break;
case 64:
#line 619 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;
}
break;
case 65:
#line 638 "parser_gram.y"
{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);
}
break;
case 66:
#line 645 "parser_gram.y"
{
	if ((yyval.list = alloc_list()) == NULL)
			YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);
}
break;
case 67:
#line 653 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add string */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;

}
break;
case 68:
#line 671 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;
}
break;
case 69:
#line 688 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[-1].sval);
	yyval.list->list_integer = avd_int_alloc(yyvsp[0].ival);

	/* Find end of list */
	for (list = yyvsp[-2].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-2].list;
}
break;
case 70:
#line 706 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add string */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;

}
break;
case 71:
#line 724 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[0].sval);

	/* Find end of list */
	for (list = yyvsp[-1].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-1].list;
}
break;
case 72:
#line 741 "parser_gram.y"
{
	list_t *list = NULL;
	list_t *list_end = NULL;

	/* Add variable */
	if ((yyval.list = alloc_list()) == NULL)
		YYERROR;

	yyval.list->list_string = avd_str_alloc(yyvsp[-1].sval);
	yyval.list->list_integer = avd_int_alloc(yyvsp[0].ival);

	/* Find end of list */
	for (list = yyvsp[-2].list; list != NULL;
	    list = list->list_next)
		list_end = list;
	list_end->list_next = yyval.list;
	yyval.list = yyvsp[-2].list;
}
break;
case 73:
#line 759 "parser_gram.y"
{
	yyval.list = yyvsp[-1].list;
}
break;
case 74:
#line 762 "parser_gram.y"
{
	yyval.list = yyvsp[-1].list;
}
break;
case 75:
#line 767 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_list;
}
break;
case 76:
#line 773 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd = &parser_flowop_list;
}
break;
case 77:
#line 778 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_fscheck;

	yyval.cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 78:
#line 786 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list->attr_next = yyvsp[0].attr;
}
break;
case 79:
#line 791 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_fsflush;

	yyval.cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 80:
#line 800 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_log;
	yyval.cmd->cmd_param_list = yyvsp[0].list;
}
break;
case 81:
#line 808 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
	filebench_shm->shm_debug_level = yyvsp[0].ival;
	if (filebench_shm->shm_debug_level > 9)
		yydebug = 1;
}
break;
case 84:
#line 822 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd_tgt1 = yyvsp[-2].sval;
	yyval.cmd->cmd_qty = yyvsp[0].ival;
	if (parentscript) {
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = parser_set_integer;
}
break;
case 85:
#line 832 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	var_assign_var(yyvsp[-2].sval, yyvsp[0].sval);
	yyval.cmd->cmd_tgt1 = yyvsp[-2].sval;
	yyval.cmd->cmd_tgt2 = yyvsp[0].sval;
	if (parentscript) {
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = parser_set_var;
}
break;
case 86:
#line 844 "parser_gram.y"
{
	if (yyvsp[-2].cmd->cmd == parser_set_integer) {
		switch (yyvsp[-1].ival) {
		case FSK_PLUS:
			var_assign_integer(yyvsp[-2].cmd->cmd_tgt1, yyvsp[-2].cmd->cmd_qty + yyvsp[0].ival);
			break;
		case FSK_MINUS:
			var_assign_integer(yyvsp[-2].cmd->cmd_tgt1, yyvsp[-2].cmd->cmd_qty - yyvsp[0].ival);
			break;
		case FSK_MULTIPLY:
			var_assign_integer(yyvsp[-2].cmd->cmd_tgt1, yyvsp[-2].cmd->cmd_qty * yyvsp[0].ival);
			break;
		case FSK_DIVIDE:
			var_assign_integer(yyvsp[-2].cmd->cmd_tgt1, yyvsp[-2].cmd->cmd_qty / yyvsp[0].ival);
			break;
		}
		yyval.cmd->cmd = NULL;
	} else {
		yyvsp[-2].cmd->cmd_qty = yyvsp[0].ival;
		yyvsp[-2].cmd->cmd_subtype = yyvsp[-1].ival;
		yyvsp[-2].cmd->cmd = parser_set_var_op_int;
	}
}
break;
case 87:
#line 868 "parser_gram.y"
{
	yyvsp[-2].cmd->cmd_tgt3 = yyvsp[0].sval;
	yyvsp[-2].cmd->cmd_subtype = yyvsp[-1].ival;
	if (yyvsp[-2].cmd->cmd == parser_set_integer) {
		yyval.cmd->cmd = parser_set_int_op_var;
	} else {
		yyvsp[-2].cmd->cmd = parser_set_var_op_var;
	}
}
break;
case 88:
#line 879 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	var_assign_boolean(yyvsp[-2].sval, yyvsp[0].bval);
	if (parentscript) {
		yyval.cmd->cmd_tgt1 = yyvsp[-2].sval;
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = NULL;
}
break;
case 89:
#line 890 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	var_assign_string(yyvsp[-4].sval, yyvsp[-1].sval);
	if (parentscript) {
		yyval.cmd->cmd_tgt1 = yyvsp[-4].sval;
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = NULL;
}
break;
case 90:
#line 900 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	var_assign_string(yyvsp[-2].sval, yyvsp[0].sval);
	if (parentscript) {
		yyval.cmd->cmd_tgt1 = yyvsp[-2].sval;
		parser_vars(yyval.cmd);
	}
	yyval.cmd->cmd = NULL;
}
break;
case 91:
#line 910 "parser_gram.y"
{
	filebench_shm->shm_rmode = FILEBENCH_MODE_TIMEOUT;
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
}
break;
case 92:
#line 916 "parser_gram.y"
{
	filebench_shm->shm_rmode = FILEBENCH_MODE_QALLDONE;
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
}
break;
case 93:
#line 922 "parser_gram.y"
{
	filebench_shm->shm_rmode = FILEBENCH_MODE_Q1STDONE;
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
}
break;
case 94:
#line 928 "parser_gram.y"
{
	filebench_shm->shm_mmode |= FILEBENCH_MODE_NOUSAGE;
	filebench_log(LOG_INFO, "disabling CPU usage statistics");
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = NULL;
}
break;
case 95:
#line 935 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_randvar_set;
	yyval.cmd->cmd_tgt1 = yyvsp[-3].sval;
	yyval.cmd->cmd_qty = FSS_TYPE;
	yyval.cmd->cmd_attr_list = yyvsp[0].attr;

}
break;
case 96:
#line 944 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_randvar_set;
	yyval.cmd->cmd_tgt1 = yyvsp[-3].sval;
	yyval.cmd->cmd_qty = FSS_SRC;
	yyval.cmd->cmd_attr_list = yyvsp[0].attr;

}
break;
case 97:
#line 953 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_randvar_set;
	yyval.cmd->cmd_tgt1 = yyvsp[-3].sval;
	yyval.cmd->cmd_qty = yyvsp[-2].ival;
	yyval.cmd->cmd_attr_list = yyvsp[0].attr;
	
}
break;
case 98:
#line 964 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = (void (*)(struct cmd *))&parser_statssnap;
	break;

}
break;
case 99:
#line 972 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = (void (*)(struct cmd *))&stats_clear;

}
break;
case 100:
#line 979 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = (void (*)(struct cmd *))&parser_directory;

}
break;
case 101:
#line 987 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = parser_statscmd;

}
break;
case 102:
#line 995 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = parser_statsdump;
}
break;
case 103:
#line 1002 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = parser_statsxmldump;
}
break;
case 104:
#line 1009 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	yyval.cmd->cmd_param_list = yyvsp[0].list;
	yyval.cmd->cmd = parser_statsmultidump;
}
break;
case 105:
#line 1018 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_filebench_shutdown;
}
break;
case 106:
#line 1025 "parser_gram.y"
{
	yyval.cmd = yyvsp[0].cmd;
}
break;
case 107:
#line 1028 "parser_gram.y"
{
	cmd_t *list = NULL;
	cmd_t *list_end = NULL;

	/* Find end of list */
	for (list = yyvsp[-1].cmd; list != NULL;
	    list = list->cmd_next)
		list_end = list;

	list_end->cmd_next = yyvsp[0].cmd;

	filebench_log(LOG_DEBUG_IMPL,
	    "flowop_list adding cmd %zx to list %zx", yyvsp[0].cmd, yyvsp[-1].cmd);

	yyval.cmd = yyvsp[-1].cmd;
}
break;
case 108:
#line 1046 "parser_gram.y"
{
	/*
	 * Allocate a cmd node per thread, with a
	 * list of flowops attached to the cmd_list
	 */
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd_list = yyvsp[-1].cmd;
	yyval.cmd->cmd_attr_list = yyvsp[-3].attr;
}
break;
case 109:
#line 1058 "parser_gram.y"
{
	yyval.cmd = yyvsp[0].cmd;
}
break;
case 110:
#line 1061 "parser_gram.y"
{
	cmd_t *list = NULL;
	cmd_t *list_end = NULL;

	/* Find end of list */
	for (list = yyvsp[-1].cmd; list != NULL;
	    list = list->cmd_next)
		list_end = list;

	list_end->cmd_next = yyvsp[0].cmd;

	filebench_log(LOG_DEBUG_IMPL,
	    "thread_list adding cmd %zx to list %zx", yyvsp[0].cmd, yyvsp[-1].cmd);

	yyval.cmd = yyvsp[-1].cmd;
}
break;
case 111:
#line 1079 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_proc_define;
	yyval.cmd->cmd_list = yyvsp[-1].cmd;
	yyval.cmd->cmd_attr_list = yyvsp[-3].attr;

}
break;
case 112:
#line 1088 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 113:
#line 1093 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_file_define;
}
break;
case 114:
#line 1098 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_fileset_define;
}
break;
case 115:
#line 1104 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 116:
#line 1109 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_posset_define;
}
break;
case 117:
#line 1114 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 118:
#line 1119 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_randvar_define;
	yyval.cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 119:
#line 1127 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = &parser_composite_flowop_define;
	yyval.cmd->cmd_list = yyvsp[-1].cmd;
	yyval.cmd->cmd_attr_list = yyvsp[-3].attr;
}
break;
case 120:
#line 1135 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 121:
#line 1140 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	switch (yyvsp[0].ival) {
	case FSE_PROC:
		yyval.cmd->cmd = &parser_proc_create;
		break;
	case FSE_FILESET:
	case FSE_FILE:
		yyval.cmd->cmd = &parser_fileset_create;
		break;
	default:
		filebench_log(LOG_ERROR, "unknown entity", yyvsp[0].ival);
		YYERROR;
	}

}
break;
case 122:
#line 1159 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	switch (yyvsp[0].ival) {
	case FSE_PROC:
		yyval.cmd->cmd = &parser_proc_shutdown;
		break;
	case FSE_FILE:
	case FSE_FILESET:
		yyval.cmd->cmd = &parser_fileset_shutdown;
		break;
	default:
		filebench_log(LOG_ERROR, "unknown entity", yyvsp[0].ival);
		YYERROR;
	}

}
break;
case 123:
#line 1178 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_warmup;
	yyval.cmd->cmd_qty = yyvsp[0].ival;
}
break;
case 124:
#line 1185 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_warmup_variable;
	yyval.cmd->cmd_tgt1 = fb_stralloc(yyvsp[0].sval);
}
break;
case 125:
#line 1193 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_sleep;
	yyval.cmd->cmd_qty = yyvsp[0].ival;
}
break;
case 126:
#line 1200 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_sleep_variable;
	yyval.cmd->cmd_tgt1 = fb_stralloc(yyvsp[0].sval);
}
break;
case 127:
#line 1208 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_run;
	yyval.cmd->cmd_qty = yyvsp[0].ival;
}
break;
case 128:
#line 1215 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_run_variable;
	yyval.cmd->cmd_tgt1 = fb_stralloc(yyvsp[0].sval);
}
break;
case 129:
#line 1222 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_run;
	yyval.cmd->cmd_qty = 60UL;
}
break;
case 130:
#line 1230 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd = parser_help;
}
break;
case 131:
#line 1237 "parser_gram.y"
{
	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;
	yyval.cmd->cmd_name = fb_stralloc(yyvsp[0].sval);
}
break;
case 132:
#line 1243 "parser_gram.y"
{
	yyvsp[-1].cmd->cmd_attr_list = yyvsp[0].attr;
}
break;
case 133:
#line 1248 "parser_gram.y"
{
	FILE *newfile;
	char loadfile[128];

	if ((yyval.cmd = alloc_cmd()) == NULL)
		YYERROR;

	(void) strcpy(loadfile, yyvsp[0].sval);
	(void) strcat(loadfile, ".f");

	if ((newfile = fopen(loadfile, "r")) == NULL) {
		(void) strcpy(loadfile, fbbasepath);
		(void) strcat(loadfile, "/workloads/");
		(void) strcat(loadfile, yyvsp[0].sval);
		(void) strcat(loadfile, ".f");
		if ((newfile = fopen(loadfile, "r")) == NULL) {
			filebench_log(LOG_ERROR, "Cannot open %s", loadfile);
			YYERROR;
		}
	}

	parentscript = yyin;
	yyin = newfile;
	yy_switchfileparent(yyin);
}
break;
case 134:
#line 1275 "parser_gram.y"
{yyval.ival = FSE_PROC;}
break;
case 135:
#line 1276 "parser_gram.y"
{yyval.ival = FSE_THREAD;}
break;
case 136:
#line 1277 "parser_gram.y"
{yyval.ival = FSE_FILESET;}
break;
case 137:
#line 1278 "parser_gram.y"
{yyval.ival = FSE_FILE;}
break;
case 138:
#line 1280 "parser_gram.y"
{ yyval.val.i = yyvsp[0].ival;}
break;
case 139:
#line 1281 "parser_gram.y"
{ yyval.val.s = yyvsp[0].sval;}
break;
case 140:
#line 1282 "parser_gram.y"
{ yyval.val.b = yyvsp[0].bval;}
break;
case 142:
#line 1288 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 143:
#line 1292 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 144:
#line 1306 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 145:
#line 1310 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 146:
#line 1324 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 147:
#line 1329 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yyvsp[0].ival;
}
break;
case 148:
#line 1336 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 149:
#line 1341 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yyvsp[0].ival;
}
break;
case 150:
#line 1349 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 151:
#line 1353 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 152:
#line 1366 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-6].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	
	if ((attr = alloc_attr()) == NULL)
		YYERROR;

	attr->attr_name = FSA_RANDTABLE;
	attr->attr_obj = (void *)yyvsp[-1].rndtb;
	list_end->attr_next = attr;
	yyval.attr = yyvsp[-6].attr;
}
break;
case 153:
#line 1385 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 154:
#line 1390 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yyvsp[0].ival;
}
break;
case 155:
#line 1396 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = FSA_TYPE;
}
break;
case 156:
#line 1401 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = FSA_RANDSRC;
}
break;
case 157:
#line 1407 "parser_gram.y"
{
	if ((yyval.rndtb = alloc_probtabent()) == NULL)
		YYERROR;
	yyval.rndtb->pte_percent = yyvsp[-5].avd;
	yyval.rndtb->pte_segmin  = yyvsp[-3].avd;
	yyval.rndtb->pte_segmax  = yyvsp[-1].avd;
}
break;
case 158:
#line 1417 "parser_gram.y"
{
	yyval.rndtb = yyvsp[0].rndtb;
}
break;
case 159:
#line 1421 "parser_gram.y"
{
	probtabent_t *pte = NULL;
	probtabent_t *ptelist_end = NULL;

	for (pte = yyvsp[-2].rndtb; pte != NULL;
	    pte = pte->pte_next)
		ptelist_end = pte; /* Find end of prob table entry list */

	ptelist_end->pte_next = yyvsp[0].rndtb;

	yyval.rndtb = yyvsp[-2].rndtb;
}
break;
case 160:
#line 1436 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 161:
#line 1440 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 162:
#line 1454 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 163:
#line 1459 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yyvsp[0].ival;
}
break;
case 164:
#line 1467 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 165:
#line 1471 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 166:
#line 1484 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 167:
#line 1498 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 168:
#line 1503 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yyvsp[0].ival;
}
break;
case 169:
#line 1511 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 170:
#line 1515 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 171:
#line 1529 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 172:
#line 1534 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_name = yyvsp[0].ival;
}
break;
case 173:
#line 1542 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 174:
#line 1546 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 175:
#line 1560 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 176:
#line 1566 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = FSA_VALUE;
}
break;
case 177:
#line 1572 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_str_alloc(yyvsp[0].sval);
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 178:
#line 1580 "parser_gram.y"
{yyval.ival = FSK_PLUS;}
break;
case 179:
#line 1581 "parser_gram.y"
{yyval.ival = FSK_MINUS;}
break;
case 180:
#line 1582 "parser_gram.y"
{yyval.ival = FSK_MULTIPLY;}
break;
case 181:
#line 1583 "parser_gram.y"
{yyval.ival = FSK_DIVIDE;}
break;
case 189:
#line 1598 "parser_gram.y"
{ yyval.ival = FSA_NICE;}
break;
case 190:
#line 1599 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 191:
#line 1600 "parser_gram.y"
{ yyval.ival = FSA_INSTANCES;}
break;
case 192:
#line 1603 "parser_gram.y"
{ yyval.ival = FSA_SIZE;}
break;
case 193:
#line 1604 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 194:
#line 1605 "parser_gram.y"
{ yyval.ival = FSA_PATH;}
break;
case 195:
#line 1606 "parser_gram.y"
{ yyval.ival = FSA_READONLY;}
break;
case 196:
#line 1607 "parser_gram.y"
{ yyval.ival = FSA_TRUSTTREE;}
break;
case 197:
#line 1608 "parser_gram.y"
{ yyval.ival = FSA_REUSE;}
break;
case 198:
#line 1609 "parser_gram.y"
{ yyval.ival = FSA_PREALLOC;}
break;
case 199:
#line 1610 "parser_gram.y"
{ yyval.ival = FSA_PARALLOC;}
break;
case 200:
#line 1613 "parser_gram.y"
{ yyval.ival = FSA_SIZE;}
break;
case 201:
#line 1614 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 202:
#line 1615 "parser_gram.y"
{ yyval.ival = FSA_PATH;}
break;
case 203:
#line 1616 "parser_gram.y"
{ yyval.ival = FSA_DIRWIDTH;}
break;
case 204:
#line 1617 "parser_gram.y"
{ yyval.ival = FSA_DIRDEPTHRV;}
break;
case 205:
#line 1618 "parser_gram.y"
{ yyval.ival = FSA_PREALLOC;}
break;
case 206:
#line 1619 "parser_gram.y"
{ yyval.ival = FSA_PARALLOC;}
break;
case 207:
#line 1620 "parser_gram.y"
{ yyval.ival = FSA_REUSE;}
break;
case 208:
#line 1621 "parser_gram.y"
{ yyval.ival = FSA_READONLY;}
break;
case 209:
#line 1622 "parser_gram.y"
{ yyval.ival = FSA_TRUSTTREE;}
break;
case 210:
#line 1623 "parser_gram.y"
{ yyval.ival = FSA_FILESIZEGAMMA;}
break;
case 211:
#line 1624 "parser_gram.y"
{ yyval.ival = FSA_DIRGAMMA;}
break;
case 212:
#line 1625 "parser_gram.y"
{ yyval.ival = FSA_CACHED;}
break;
case 213:
#line 1626 "parser_gram.y"
{ yyval.ival = FSA_ENTRIES;}
break;
case 214:
#line 1627 "parser_gram.y"
{ yyval.ival = FSA_LEAFDIRS;}
break;
case 215:
#line 1630 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 216:
#line 1631 "parser_gram.y"
{ yyval.ival = FSA_TYPE;}
break;
case 217:
#line 1632 "parser_gram.y"
{ yyval.ival = FSA_RANDSEED;}
break;
case 218:
#line 1633 "parser_gram.y"
{ yyval.ival = FSA_ENTRIES;}
break;
case 219:
#line 1634 "parser_gram.y"
{ yyval.ival = FSA_RANDMAX;}
break;
case 220:
#line 1637 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 221:
#line 1638 "parser_gram.y"
{ yyval.ival = FSA_RANDSEED;}
break;
case 222:
#line 1639 "parser_gram.y"
{ yyval.ival = FSA_RANDGAMMA;}
break;
case 223:
#line 1640 "parser_gram.y"
{ yyval.ival = FSA_RANDMEAN;}
break;
case 224:
#line 1641 "parser_gram.y"
{ yyval.ival = FSA_RANDMIN;}
break;
case 225:
#line 1642 "parser_gram.y"
{ yyval.ival = FSA_RANDROUND;}
break;
case 226:
#line 1645 "parser_gram.y"
{ yyval.ival = FSS_TYPE;}
break;
case 227:
#line 1646 "parser_gram.y"
{ yyval.ival = FSS_SRC;}
break;
case 228:
#line 1647 "parser_gram.y"
{ yyval.ival = FSS_SEED;}
break;
case 229:
#line 1648 "parser_gram.y"
{ yyval.ival = FSS_GAMMA;}
break;
case 230:
#line 1649 "parser_gram.y"
{ yyval.ival = FSS_MEAN;}
break;
case 231:
#line 1650 "parser_gram.y"
{ yyval.ival = FSS_MIN;}
break;
case 232:
#line 1651 "parser_gram.y"
{ yyval.ival = FSS_ROUND;}
break;
case 233:
#line 1654 "parser_gram.y"
{ yyval.ival = FSS_SEED;}
break;
case 234:
#line 1655 "parser_gram.y"
{ yyval.ival = FSS_GAMMA;}
break;
case 235:
#line 1656 "parser_gram.y"
{ yyval.ival = FSS_MEAN;}
break;
case 236:
#line 1657 "parser_gram.y"
{ yyval.ival = FSS_MIN;}
break;
case 237:
#line 1658 "parser_gram.y"
{ yyval.ival = FSS_ROUND;}
break;
case 238:
#line 1661 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_int_alloc(yyvsp[0].ival);
}
break;
case 239:
#line 1668 "parser_gram.y"
{ yyval.ival = FSV_RANDUNI;}
break;
case 240:
#line 1669 "parser_gram.y"
{ yyval.ival = FSV_RANDTAB;}
break;
case 241:
#line 1670 "parser_gram.y"
{ yyval.ival = FSA_RANDGAMMA;}
break;
case 242:
#line 1673 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_int_alloc(yyvsp[0].ival);
}
break;
case 243:
#line 1680 "parser_gram.y"
{ yyval.ival = FSV_URAND;}
break;
case 244:
#line 1681 "parser_gram.y"
{ yyval.ival = FSV_RAND48;}
break;
case 245:
#line 1684 "parser_gram.y"
{ yyval.ival = FSA_PROCESS;}
break;
case 246:
#line 1685 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 247:
#line 1686 "parser_gram.y"
{ yyval.ival = FSA_MEMSIZE;}
break;
case 248:
#line 1687 "parser_gram.y"
{ yyval.ival = FSA_USEISM;}
break;
case 249:
#line 1688 "parser_gram.y"
{ yyval.ival = FSA_INSTANCES;}
break;
case 250:
#line 1691 "parser_gram.y"
{ yyval.ival = FSA_WSS;}
break;
case 251:
#line 1692 "parser_gram.y"
{ yyval.ival = FSA_FILE;}
break;
case 252:
#line 1693 "parser_gram.y"
{ yyval.ival = FSA_POSSET;}
break;
case 253:
#line 1694 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 254:
#line 1695 "parser_gram.y"
{ yyval.ival = FSA_RANDOM;}
break;
case 255:
#line 1696 "parser_gram.y"
{ yyval.ival = FSA_FD;}
break;
case 256:
#line 1697 "parser_gram.y"
{ yyval.ival = FSA_SRCFD;}
break;
case 257:
#line 1698 "parser_gram.y"
{ yyval.ival = FSA_ROTATEFD;}
break;
case 258:
#line 1699 "parser_gram.y"
{ yyval.ival = FSA_DSYNC;}
break;
case 259:
#line 1700 "parser_gram.y"
{ yyval.ival = FSA_DIRECTIO;}
break;
case 260:
#line 1701 "parser_gram.y"
{ yyval.ival = FSA_INDEXED;}
break;
case 261:
#line 1702 "parser_gram.y"
{ yyval.ival = FSA_TARGET;}
break;
case 262:
#line 1703 "parser_gram.y"
{ yyval.ival = FSA_ITERS;}
break;
case 263:
#line 1704 "parser_gram.y"
{ yyval.ival = FSA_VALUE;}
break;
case 264:
#line 1705 "parser_gram.y"
{ yyval.ival = FSA_BLOCKING;}
break;
case 265:
#line 1706 "parser_gram.y"
{ yyval.ival = FSA_HIGHWATER;}
break;
case 266:
#line 1707 "parser_gram.y"
{ yyval.ival = FSA_IOSIZE;}
break;
case 267:
#line 1708 "parser_gram.y"
{ yyval.ival = FSA_NOREADAHEAD;}
break;
case 268:
#line 1711 "parser_gram.y"
{ yyval.ival = FSA_RATE;}
break;
case 269:
#line 1714 "parser_gram.y"
{ yyval.ival = FSA_MASTER;}
break;
case 270:
#line 1715 "parser_gram.y"
{ yyval.ival = FSA_CLIENT;}
break;
case 271:
#line 1718 "parser_gram.y"
{ yyval.ival = FSA_PATH;}
break;
case 272:
#line 1719 "parser_gram.y"
{ yyval.ival = FSA_FSTYPE;}
break;
case 273:
#line 1722 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
}
break;
case 274:
#line 1726 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 275:
#line 1739 "parser_gram.y"
{
	attr_t *attr = NULL;
	attr_t *list_end = NULL;

	for (attr = yyvsp[-2].attr; attr != NULL;
	    attr = attr->attr_next)
		list_end = attr; /* Find end of list */

	list_end->attr_next = yyvsp[0].attr;

	yyval.attr = yyvsp[-2].attr;
}
break;
case 276:
#line 1753 "parser_gram.y"
{
	yyval.attr = yyvsp[0].attr;
	yyval.attr->attr_name = yyvsp[-2].ival;
}
break;
case 277:
#line 1759 "parser_gram.y"
{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_boolean(yyvsp[-2].sval, yyvsp[0].bval))) == NULL)
		YYERROR;
}
break;
case 278:
#line 1764 "parser_gram.y"
{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_integer(yyvsp[-2].sval, yyvsp[0].ival))) == NULL)
		YYERROR;
}
break;
case 279:
#line 1769 "parser_gram.y"
{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_string(yyvsp[-4].sval, yyvsp[-1].sval))) == NULL)
		YYERROR;
}
break;
case 280:
#line 1774 "parser_gram.y"
{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_string(yyvsp[-2].sval, yyvsp[0].sval))) == NULL)
		YYERROR;
}
break;
case 281:
#line 1779 "parser_gram.y"
{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_assign_var(yyvsp[-2].sval, yyvsp[0].sval))) == NULL)
		YYERROR;
}
break;
case 282:
#line 1784 "parser_gram.y"
{
	if ((yyval.attr = alloc_lvar_attr(var_lvar_alloc_local(yyvsp[0].sval))) == NULL)
		YYERROR;
}
break;
case 283:
#line 1791 "parser_gram.y"
{ yyval.ival = FSA_NAME;}
break;
case 284:
#line 1792 "parser_gram.y"
{ yyval.ival = FSA_ITERS;}
break;
case 285:
#line 1795 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_str_alloc(yyvsp[0].sval);
}
break;
case 286:
#line 1799 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_int_alloc(yyvsp[0].ival);
}
break;
case 287:
#line 1803 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_bool_alloc(yyvsp[0].bval);
}
break;
case 288:
#line 1807 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = var_ref_attr(yyvsp[0].sval);
}
break;
case 289:
#line 1813 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_param_list = yyvsp[0].list;
}
break;
case 290:
#line 1817 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_str_alloc(yyvsp[0].sval);
}
break;
case 291:
#line 1821 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_int_alloc(yyvsp[0].ival);
}
break;
case 292:
#line 1825 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = avd_bool_alloc(yyvsp[0].bval);
}
break;
case 293:
#line 1829 "parser_gram.y"
{
	if ((yyval.attr = alloc_attr()) == NULL)
		YYERROR;
	yyval.attr->attr_avd = var_ref_attr(yyvsp[0].sval);
}
break;
case 294:
#line 1836 "parser_gram.y"
{
	yyval.avd = avd_int_alloc(yyvsp[0].ival);
}
break;
case 295:
#line 1839 "parser_gram.y"
{
	yyval.avd = var_ref_attr(yyvsp[0].sval);
}
break;
#line 6638 "y.tab.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yysslim && yygrowstack())
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
