\section{Entropy Generator}\label{sec:ent_imp}

The entropy generator is organized into two modules \verb+entropy.c+ and \verb+source.c+ . \verb+entropy.c+ is a library that contains a group of helping functions to build
 data sources with random generation capabilities. \verb+source.h+ has the definition of the \verb+source+ and \verb+source_operations+ structures.
\lstset{language=C}
\begin{lstlisting}
struct source {
    double s_entropy;
    struct source_operations *s_ops; 
};

struct source_operations {
    int (*fill)(struct source *, void *, unsigned int);
};

\end{lstlisting}


 In \verb+sources.c+ we can find few declared instances of the later structure. Filebench uses \verb+dummy_operations+ by default unless an entropy is specified as a parameter to the fileset declaration statement.
 In that case, Filebench will assign \verb+entropy_operations+ to the fileset source structure. Both structures are minimal and can be expanded for any future needs.

\subsection{Calculating the pdf}

As explained in section \ref{sub:ent_des} we explained the algorithm to calculate the pdf.
However, the equation is not easily solvable analytically. To overcome this problem. Numerical methods can be used to solve the problem. We implemented the secant method to find the roots of the equation. The secant method was chosen as it is easy to implement, converge fast enough, only 20 iterations needed !. Not to mention that the requirements are easy to prepare, you have to specify the range that you expect the solution to be in.


\subsection{Populating algorithm}

Filebench is calling \verb+entropy_fill+ operation to fill the buffer with data with the specific entropy. \verb+entropy_fill+ is an interface that call the actual algorithm that calculate the PDF and populate the data.

Many algorithms were proposed to generate data, differs mainly in the way they generate the data stream out of the calculated PDF.

In section \ref{sub:ent_des} we explained how can we map the PDF to generate symbols according to their probability. This method is described in literature as roulette selection algorithm, our own implementation is called
 \verb+entropy_search_fill+. Although the time complexity of such algorithm is linear. The constant factors can go up to 10; the binary search takes at most 8 comparisons as the symbols table size is 256.


In an effort to minimize the time used to fill the buffer the following methods were implemented:

\begin{itemize}
\item \verb+entropy_cont_fill+. \\
   fills the buffer with random data according to
    the pdf. It will generate contiguous segments of data in the
    buffer to make different same size buffer look different, we
    shuffle the symbols table. It takes less time but it does not
    give homogeneous entropy data stream. Because of rounding errors
    we will have some remaining elements are not filled, so we will
    use the search method to fill them.
\item \verb+entropy_permutate_fill+\\
    fills the buffer with random data according to
    the pdf. It will generate contiguous segments of data in the
    buffer. After that a permutation function will be called to make
    the buffer looks with homogeneous entropy. The permutation
    function has high overhead, because it is not cache friendly.
    tests show 16x overhead

\item \verb+entropy_4k_fill+ \\
    To help the permutate function overcome the caching problem. Benchmarks
    shows 3x speedup. However, _4k_fill should be sure that the pages filling
    algorithm is using the same set of symbols for each page, otherwise the
    entropy of the whole file will increase more than the specified value. If
    you are using \verb+entropy_permutate_fill+ that will call cont_fill then comment the 
    symbols shuffle step. Still slower that _lookup_fill by a factor of 2.

\item \verb+entropy_lookup_fill+
    initializes a vector using _*_fill method then
    using that vector we will initialize our buffer by looking up
    different elements using a random index.The fastest method 
    after cont_fill it is slower by a factor of 3.
\end{itemize}


